abort	<font color=blue>功  能</font>: 异常终止一个进程<br><font color=blue>用  法</font>: void abort(void);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < stdlib.h ><br>int main(void)<br>{<br>  printf("Calling abort()\\n");<br>  abort();<br>  return 0; /* This is never reached */<br>}\n
abs	<font color=blue>功  能</font>: 求整数的绝对值<br><font color=blue>用  法</font>: int abs(int i);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < math.h ><br>int main(void)<br>{<br>  int number = -1234;<br>  printf("number: %d  absolute value: %d\\n", number, abs(number));<br>  return 0;<br>}\n
absread, abswirte	<font color=blue>功  能</font>: 绝对磁盘扇区读、写数据<br><font color=blue>用  法</font>: int absread(int drive, int nsects, int sectno, void *buffer);<br> int abswrite(int drive, int nsects, in tsectno, void *buffer);<br><font color=blue>程序例</font>:<br>/* absread example */<br>#include < stdio.h ><br>#include < conio.h ><br>#include < process.h ><br>#include < dos.h ><br>int main(void)<br>{<br>  int i, strt, ch_out, sector;<br>  char buf[512];<br>  printf("Insert a diskette into drive A and press any key\\n");<br>  getch();<br>  sector = 0;<br>  if (absread(0, 1, sector, &buf) != 0)<br>  {<br>     perror("Disk problem");<br>     exit(1);<br>  }<br>  printf("Read OK\\n");<br>  strt = 3;<br>  for (i=0; i< 80; i++)<br>  {<br>     ch_out = buf[strt+i];<br>     putchar(ch_out);<br>  }<br>  printf("\\n");<br>  return(0);<br>}</>\n
access	<font color=blue>功  能</font>: 确定文件的访问权限<br><font color=blue>用  法</font>: int access(const char *filename, int amode);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < io.h ><br>int file_exists(char *filename);<br>int main(void)<br>{<br>  printf("Does NOTEXIST.FIL exist: %s\\n",<br>  file_exists("NOTEXISTS.FIL") ? "YES" : "NO");<br>  return 0;<br>}<br>int file_exists(char *filename)<br>{<br>  return (access(filename, 0) == 0);<br>}<br> <br>\n
acos	<font color=blue>功  能</font>: 反余弦函数<br><font color=blue>用  法</font>: double acos(double x);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < math.h ><br>int main(void)<br>{<br>  double result;<br>  double x = 0.5;<br>  result = acos(x);<br>  printf("The arc cosine of %lf is %lf\\n", x, result);<br>  return 0;<br>}\n
allocmem	<font color=blue>功  能</font>: 分配DOS存储段<br><font color=blue>用  法</font>: int allocmem(unsigned size, unsigned *seg);<br><font color=blue>程序例</font>:<br>#include < dos.h ><br>#include < alloc.h ><br>#include < stdio.h ><br>int main(void)<br>{<br>  unsigned int size, segp;<br>  int stat;<br>  size = 64; /* (64 x 16) = 1024 bytes */<br>  stat = allocmem(size, &segp);<br>  if (stat == -1)<br>     printf("Allocated memory at segment: %x\\n", segp);<br>  else<br>     printf("Failed: maximum number of paragraphs available is %u\\n",<br>            stat);<br>  return 0;<br>}\n
arc	<font color=blue>功  能</font>: 画一弧线<br><font color=blue>用  法</font>: void far arc(int x, int y, int stangle, int endangle, int radius);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>int main(void)<br>{<br>    /* request auto detection */<br>   int gdriver = DETECT, gmode, errorcode;<br>   int midx, midy;<br>   int stangle = 45, endangle = 135;<br>   int radius = 100;<br>   /* initialize graphics and local variables */<br>   initgraph(&gdriver, &gmode, "");<br>   /* read result of initialization */<br>   errorcode = graphresult();    /* an error occurred */<br>   if (errorcode != grOk)<br>   {<br>      printf("Graphics error: %s\\n", grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>      exit(1);    /* terminate with an error code */<br>   }<br>   midx = getmaxx() / 2;<br>   midy = getmaxy() / 2;<br>   setcolor(getmaxcolor());<br>   /* draw arc */<br>   arc(midx, midy, stangle, endangle, radius);<br>   /* clean up */<br>   getch();<br>   closegraph();<br>   return 0;<br>}\n
asctime	<font color=blue>功  能</font>: 转换日期和时间为ASCII码<br><font color=blue>用  法</font>: char *asctime(const struct tm *tblock);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < string.h ><br>#include < time.h ><br>int main(void)<br>{<br>   struct tm t;<br>   char str[80];<br>   /* sample loading of tm structure  */<br>   t.tm_sec    = 1;  /* Seconds */<br>   t.tm_min    = 30; /* Minutes */<br>   t.tm_hour   = 9;  /* Hour */<br>   t.tm_mday   = 22; /* Day of the Month  */<br>   t.tm_mon    = 11; /* Month */<br>   t.tm_year   = 56; /* Year - does not include century */<br>   t.tm_wday   = 4;  /* Day of the week  */<br>   t.tm_yday   = 0;  /* Does not show in asctime  */<br>   t.tm_isdst  = 0;  /* Is Daylight SavTime; does not show in asctime */<br>   /* converts structure to null terminated<br>   string */<br>   strcpy(str, asctime(&t));<br>   printf("%s\\n", str);<br>   return 0;<br>}</>\n
asin	<font color=blue>功  能</font>: 反正弦函数<br><font color=blue>用  法</font>: double asin(double x);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < math.h ><br>int main(void)<br>{<br>   double result;<br>   double x = 0.5;<br>   result = asin(x);<br>   printf("The arc sin of %lf is %lf\\n", x, result);<br>   return(0);<br>}</>\n
assert	<font color=blue>功  能</font>: 测试一个条件并可能使程序终止<br><font color=blue>用  法</font>: void assert(int test);<br><font color=blue>程序例</font>:<br>#include < assert.h ><br>#include < stdio.h ><br>#include < stdlib.h ><br>struct ITEM {<br>   int key;<br>   int value;<br>};<br>/* add item to list, make sure list is not null */<br>void additem(struct ITEM *itemptr) {<br>   assert(itemptr != NULL);<br>   /* add item to list */<br>}<br>int main(void)<br>{<br>   additem(NULL);<br>   return 0;<br>}</>\n
atan	<font color=blue>功  能</font>: 反正切函数<br><font color=blue>用  法</font>: double atan(double x);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < math.h ><br>int main(void)<br>{<br>   double result;<br>   double x = 0.5;<br>   result = atan(x);<br>   printf("The arc tangent of %lf is %lf\\n", x, result);<br>   return(0);<br>}\n
atan2	<font color=blue>功  能</font>: 计算Y/X的反正切值<br><font color=blue>用  法</font>: double atan2(double y, double x);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < math.h ><br>int main(void)<br>{<br>   double result;<br>   double x = 90.0, y = 45.0;<br>   result = atan2(y, x);<br>   printf("The arc tangent ratio of %lf is %lf\\n", (y / x), result);<br>   return 0;<br>}\n
atexit	<font color=blue>功  能</font>: 注册终止函数<br><font color=blue>用  法</font>: int atexit(atexit_t func);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < stdlib.h ><br>void exit_fn1(void)<br>{<br>   printf("Exit function #1 called\\n");<br>}<br>void exit_fn2(void)<br>{<br>   printf("Exit function #2 called\\n");<br>}<br>int main(void)<br>{<br>   /* post exit function #1 */<br>   atexit(exit_fn1);<br>   /* post exit function #2 */<br>   atexit(exit_fn2);<br>   return 0;<br>}</>\n
atof	<font color=blue>功  能</font>: 把字符串转换成浮点数<br><font color=blue>用  法</font>: double atof(const char *nptr);<br><font color=blue>程序例</font>:<br>#include < stdlib.h ><br>#include < stdio.h ><br>int main(void)<br>{<br>   float f;<br>   char *str = "12345.67";<br>   f = atof(str);<br>   printf("string = %s float = %f\\n", str, f);<br>   return 0;<br>}\n
atoi	<font color=blue>功  能</font>: 把字符串转换成长整型数<br><font color=blue>用  法</font>: int atoi(const char *nptr);<br><font color=blue>程序例</font>:<br>#include < stdlib.h ><br>#include < stdio.h ><br>int main(void)<br>{<br>   int n;<br>   char *str = "12345.67";<br>   n = atoi(str);<br>   printf("string = %s integer = %d\\n", str, n);<br>   return 0;<br>}\n
atol	<font color=blue>功  能</font>: 把字符串转换成长整型数<br><font color=blue>用  法</font>: long atol(const char *nptr);<br><font color=blue>程序例</font>:<br>#include < stdlib.h ><br>#include < stdio.h ><br>int main(void)<br>{<br>   long l;<br>   char *str = "98765432";<br>   l = atol(lstr);<br>   printf("string = %s integer = %ld\\n", str, l);<br>   return(0);<br>}<br>\n
bar	<font color=blue>功  能</font>: 画一个二维条形图<br><font color=blue>用  法</font>: void far bar(int left, int top, int right, int bottom);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>int main(void)<br>{<br>   /* request auto detection */<br>   int gdriver = DETECT, gmode, errorcode;<br>   int midx, midy, i;<br>   /* initialize graphics and local variables */<br>   initgraph(&gdriver, &gmode, "");<br>   /* read result of initialization */<br>   errorcode = graphresult();<br>   if (errorcode != grOk)  /* an error occurred */<br>   {<br>      printf("Graphics error: %s\\n", grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>      exit(1); /* terminate with an error code */<br>   }<br>   midx = getmaxx() / 2;<br>   midy = getmaxy() / 2;<br>   /* loop through the fill patterns */<br>   for (i=SOLID_FILL; i< USER_FILL; i++)<br>   {<br>      /* set the fill style */<br>      setfillstyle(i, getmaxcolor());<br>      /* draw the bar */<br>      bar(midx-50, midy-50, midx+50,<br>         midy+50);<br>      getch();<br>   }<br>   /* clean up */<br>   closegraph();<br>   return 0;<br>}</>\n
bar3d	<font color=blue>功  能</font>: 画一个三维条形图<br><font color=blue>用  法</font>: void far bar3d(int left, int top, int right, int bottom,<br>                       int depth, int topflag);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>int main(void)<br>{<br>   /* request auto detection */<br>   int gdriver = DETECT, gmode, errorcode;<br>   int midx, midy, i;<br>   /* initialize graphics, local variables */<br>   initgraph(&gdriver, &gmode, "");<br>   /* read result of initialization */<br>   errorcode = graphresult();<br>   if (errorcode != grOk)  /* an error occurred */<br>   {<br>      printf("Graphics error: %s\\n", grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>      exit(1); /* terminate with error code */<br>   }<br>   midx = getmaxx() / 2;<br>   midy = getmaxy() / 2;<br>   /* loop through the fill patterns */<br>   for (i=EMPTY_FILL; i< USER_FILL; i++)<br>   {<br>      /* set the fill style */<br>      setfillstyle(i, getmaxcolor());<br>      /* draw the 3-d bar */<br>      bar3d(midx-50, midy-50, midx+50, midy+50, 10, 1);<br>      getch();<br>   }<br>   /* clean up */<br>   closegraph();<br>   return 0;<br>}</>\n
bdos	<font color=blue>功  能</font>: DOS系统调用<br><font color=blue>用  法</font>: int bdos(int dosfun, unsigned dosdx, unsigned dosal);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < dos.h ><br>/* Get current drive as 'A', 'B', ... */<br>char current_drive(void)<br>{<br>   char curdrive;<br>   /* Get current disk as 0, 1, ... */<br>   curdrive = bdos(0x19, 0, 0);<br>   return('A' + curdrive);<br>}<br>int main(void)<br>{<br>   printf("The current drive is %c:\\n", current_drive());<br>   return 0;<br>}</>\n
bdosptr	<font color=blue>功  能</font>: DOS系统调用<br><font color=blue>用  法</font>: int bdosptr(int dosfun, void *argument, unsigned dosal);<br><font color=blue>程序例</font>:<br>#include < string.h ><br>#include < stdio.h ><br>#include < dir.h ><br>#include < dos.h ><br>#include < errno.h ><br>#include < stdlib.h ><br>#define  BUFLEN  80<br>int main(void)<br>{<br>   char  buffer[BUFLEN];<br>   int   test;<br>   printf("Enter full pathname of a directory\\n");<br>   gets(buffer);<br>   test = bdosptr(0x3B,buffer,0);<br>      if(test)<br>      {<br>  printf("DOS error message: %d\\n", errno);<br>  /* See errno.h for error listings */<br>  exit (1);<br>      }<br>   getcwd(buffer, BUFLEN);<br>   printf("The current directory is: %s\\n", buffer);<br>   return 0;<br>}</>\n
bioscom	<font color=blue>功  能</font>: 串行I/O通信<br><font color=blue>用  法</font>: int bioscom(int cmd, char abyte, int port);<br><font color=blue>程序例</font>:<br>#include < bios.h ><br>#include < conio.h ><br>#define COM1       0<br>#define DATA_READY 0x100<br>#define TRUE       1<br>#define FALSE      0<br>#define SETTINGS ( 0x80 | 0x02 | 0x00 | 0x00)<br>int main(void)<br>{<br>   int in, out, status, DONE = FALSE;<br>   bioscom(0, SETTINGS, COM1);<br>   cprintf("... BIOSCOM [ESC] to exit ...\\n");<br>   while (!DONE)<br>   {<br>      status = bioscom(3, 0, COM1);<br>      if (status & DATA_READY)<br>  if ((out = bioscom(2, 0, COM1) & 0x7F) != 0)<br>     putch(out);<br>  if (kbhit())<br>  {<br>     if ((in = getch()) == '\\x1B')<br>        DONE = TRUE;<br>     bioscom(1, in, COM1);<br>  }<br>   }<br>   return 0;<br>}</>\n
biosdisk	<font color=blue>功  能</font>: 软硬盘I/O<br><font color=blue>用  法</font>: int biosdisk(int cmd, int drive, int head, int track, int sector<br>       int nsects, void *buffer);<br><font color=blue>程序例</font>:<br>#include < bios.h ><br>#include < stdio.h ><br>int main(void)<br>{<br>   int result;<br>   char buffer[512];<br>   printf("Testing to see if drive a: is ready\\n");<br>   result = biosdisk(4,0,0,0,0,1,buffer);<br>   result &= 0x02;<br>   (result) ? (printf("Drive A: Ready\\n")) :<br>       (printf("Drive A: Not Ready\\n"));<br>   return 0;<br>}</>\n
biosequip	<font color=blue>功  能</font>: 检查设备<br><font color=blue>用  法</font>: int biosequip(void);<br><font color=blue>程序例</font>:<br>#include < bios.h ><br>#include < stdio.h ><br>int main(void)<br>{<br>   int result;<br>   char buffer[512];<br>   printf("Testing to see if drive a: is ready\\n");<br>   result = biosdisk(4,0,0,0,0,1,buffer);<br>   result &= 0x02;<br>   (result) ? (printf("Drive A: Ready\\n")) :<br>       (printf("Drive A: Not Ready\\n"));<br>   return 0;<br>}</>\n
bioskey	<font color=blue>功  能</font>: 直接使用BIOS服务的键盘接口<br><font color=blue>用  法</font>: int bioskey(int cmd);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < bios.h ><br>#include < ctype.h ><br>#define RIGHT  0x01<br>#define LEFT   0x02<br>#define CTRL   0x04<br>#define ALT    0x08<br>int main(void)<br>{<br>   int key, modifiers;<br>   /* function 1 returns 0 until a key is pressed */<br>   while (bioskey(1) == 0);<br>   /* function 0 returns the key that is waiting */<br>   key = bioskey(0);<br>   /* use function 2 to determine if shift keys were used */<br>   modifiers = bioskey(2);<br>   if (modifiers)<br>   {<br>      printf("[");<br>      if (modifiers & RIGHT) printf("RIGHT");<br>      if (modifiers & LEFT)  printf("LEFT");<br>      if (modifiers & CTRL)  printf("CTRL");<br>      if (modifiers & ALT)   printf("ALT");<br>      printf("]");<br>   }<br>   /* print out the character read */<br>   if (isalnum(key & 0xFF))<br>      printf("'%c'\\n", key);<br>   else<br>      printf("%#02x\\n", key);<br>   return 0;<br>}\n
biosmemory	<font color=blue>功  能</font>: 返回存储块大小<br><font color=blue>用  法</font>:int biosmemory(void);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < bios.h ><br>int main(void)<br>{<br>   int memory_size;<br>   memory_size = biosmemory();  /* returns value up to 640K */<br>   printf("RAM size = %dK\\n",memory_size);<br>   return 0;<br>}</>\n
biosprint	<font color=blue>功  能</font>: 直接使用BIOS服务的打印机I/O<br><font color=blue>用  法</font>: int biosprint(int cmd, int byte, int port);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < conio.h ><br>#include < bios.h ><br>int main(void)<br>{<br>   #define STATUS  2    /* printer status command */<br>   #define PORTNUM 0    /* port number for LPT1 */<br>   int status, abyte=0;<br>   printf("Please turn off your printer.  Press any key to continue\\n");<br>   getch();<br>   status = biosprint(STATUS, abyte, PORTNUM);<br>   if (status & 0x01)<br>      printf("Device time out.\\n");<br>   if (status & 0x08)<br>      printf("I/O error.\\n");<br>   if (status & 0x10)<br>      printf("Selected.\\n");<br>   if (status & 0x20)<br>      printf("Out of paper.\\n");<br>   if (status & 0x40)<br>      printf("Acknowledge.\\n");<br>   if (status & 0x80)<br>      printf("Not busy.\\n");<br>   return 0;<br>}</>\n
biostime	<font color=blue>功  能</font>: 读取或设置BIOS时间<br><font color=blue>用  法</font>: long biostime(int cmd, long newtime);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < bios.h ><br>#include < time.h ><br>#include < conio.h ><br>int main(void)<br>{<br>   long bios_time;<br>   clrscr();<br>   cprintf("The number of clock ticks since midnight is:\\r\\n");<br>   cprintf("The number of seconds since midnight is:\\r\\n");<br>   cprintf("The number of minutes since midnight is:\\r\\n");<br>   cprintf("The number of hours since midnight is:\\r\\n");<br>   cprintf("\\r\\nPress any key to quit:");<br>   while(!kbhit())<br>   {<br>      bios_time = biostime(0, 0L);<br>      gotoxy(50, 1);<br>      cprintf("%lu", bios_time);<br>      gotoxy(50, 2);<br>      cprintf("%.4f", bios_time / CLK_TCK);<br>      gotoxy(50, 3);<br>      cprintf("%.4f", bios_time / CLK_TCK / 60);<br>      gotoxy(50, 4);<br>      cprintf("%.4f", bios_time / CLK_TCK / 3600);<br>   }<br>   return 0;<br>}</>\n
brk	<font color=blue>功  能</font>: 改变数据段空间分配<br><font color=blue>用  法</font>: int brk(void *endds);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < alloc.h ><br>int main(void)<br>{<br>   char *ptr;<br>   printf("Changing allocation with brk()\\n");<br>   ptr = malloc(1);<br>   printf("Before brk() call: %lu bytes free\\n", coreleft());<br>   brk(ptr+1000);<br>   printf(" After brk() call: %lu bytes free\\n", coreleft());<br>   return 0;<br>}</>\n
bsearch	<font color=blue>功  能</font>: 二分法搜索<br><font color=blue>用  法</font>: void *bsearch(const void *key, const void *base, size_t *nelem,<br>        size_t width, int(*fcmp)(const void *, const *));<br><font color=blue>程序例</font>:<br>#include < stdlib.h ><br>#include < stdio.h ><br>#define NELEMS(arr) (sizeof(arr) / sizeof(arr[0]))<br>int numarray[] = {123, 145, 512, 627, 800, 933};<br>int numeric (const int *p1, const int *p2)<br>{<br>   return(*p1 - *p2);<br>}<br>int lookup(int key)<br>{<br>   int *itemptr;<br>   /* The cast of (int(*)(const void *,const void*))<br>      is needed to avoid a type mismatch error at<br>      compile time */<br>   itemptr = bsearch (&key, numarray, NELEMS(numarray),<br>      sizeof(int), (int(*)(const void *,const void *))numeric);<br>   return (itemptr != NULL);<br>}<br>int main(void)<br>{<br>   if (lookup(512))<br>      printf("512 is in the table.\\n");<br>   else<br>      printf("512 isn't in the table.\\n");<br>   return 0;<br>}<br>\n
cabs	<font color=blue>功  能</font>: 计算复数的绝对值<br><font color=blue>用  法</font>: double cabs(struct complex z);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < math.h ><br>int main(void)<br>{<br>   struct complex z;<br>   double val;<br>   z.x = 2.0;<br>   z.y = 1.0;<br>   val = cabs(z);<br>   printf("The absolute value of %.2lfi %.2lfj is %.2lf", z.x, z.y, val);<br>   return 0;<br>}</>\n
calloc	<font color=blue>功  能</font>: 分配主存储器<br><font color=blue>用  法</font>: void *calloc(size_t nelem, size_t elsize);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < alloc.h ><br>int main(void)<br>{<br>   char *str = NULL;<br>   /* allocate memory for string */<br>   str = calloc(10, sizeof(char));<br>   /* copy "Hello" into string */<br>   strcpy(str, "Hello");<br>   /* display string */<br>   printf("String is %s\\n", str);<br>   /* free memory */<br>   free(str);<br>   return 0;<br>}</>\n
ceil	<font color=blue>功  能</font>: 向上舍入<br><font color=blue>用  法</font>: double ceil(double x);<br><font color=blue>程序例</font>:<br>#include < math.h ><br>#include < stdio.h ><br>int main(void)<br>{<br>   double number = 123.54;<br>   double down, up;<br>   down = floor(number);<br>   up = ceil(number);<br>   printf("original number     %5.2lf\\n", number);<br>   printf("number rounded down %5.2lf\\n", down);<br>   printf("number rounded up   %5.2lf\\n", up);<br>   return 0;<br>}</>\n
cgets	<font color=blue>功  能</font>: 从控制台读字符串<br><font color=blue>用  法</font>: char *cgets(char *str);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < conio.h ><br>int main(void)<br>{<br>   char buffer[83];<br>   char *p;<br>   /* There's space for 80 characters plus the NULL terminator */<br>   buffer[0] = 81;<br>   printf("Input some chars:");<br>   p = cgets(buffer);<br>   printf("\\ncgets read %d characters: \\"%s\\"\\n", buffer[1], p);<br>   printf("The returned pointer is %p, buffer[0] is at %p\\n", p, &buffer);<br>   /* Leave room for 5 characters plus the NULL terminator */<br>   buffer[0] = 6;<br>   printf("Input some chars:");<br>   p = cgets(buffer);<br>   printf("\\ncgets read %d characters: \\"%s\\"\\n", buffer[1], p);<br>   printf("The returned pointer is %p, buffer[0] is at %p\\n", p, &buffer);<br>   return 0;<br>}</>\n
chdir	<font color=blue>功  能</font>: 改变工作目录<br><font color=blue>用  法</font>: int chdir(const char *path);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < stdlib.h ><br>#include < dir.h ><br>char old_dir[MAXDIR];<br>char new_dir[MAXDIR];<br>int main(void)<br>{<br>   if (getcurdir(0, old_dir))<br>   {<br>      perror("getcurdir()");<br>      exit(1);<br>   }<br>   printf("Current directory is: \\\\%s\\n", old_dir);<br>   if (chdir("\\\\"))<br>   {<br>      perror("chdir()");<br>      exit(1);<br>   }<br>   if (getcurdir(0, new_dir))<br>   {<br>      perror("getcurdir()");<br>      exit(1);<br>   }<br>   printf("Current directory is now: \\\\%s\\n", new_dir);<br>   printf("\\nChanging back to orignal directory: \\\\%s\\n", old_dir);<br>   if (chdir(old_dir))<br>   {<br>      perror("chdir()");<br>      exit(1);<br>   }<br>   return 0;<br>}\n
chmod	<font color=blue>功  能</font>: 改变文件的访问方式<br><font color=blue>用  法</font>: int chmod(const char *filename, int permiss);<br><font color=blue>程序例</font>:<br>#include < sys\\stat.h ><br>#include < stdio.h ><br>#include < io.h ><br>void make_read_only(char *filename);<br>int main(void)<br>{<br>   make_read_only("NOTEXIST.FIL");<br>   make_read_only("MYFILE.FIL");<br>   return 0;<br>}<br>void make_read_only(char *filename)<br>{<br>   int stat;<br>   stat = chmod(filename, S_IREAD);<br>   if (stat)<br>      printf("Couldn't make %s read-only\\n", filename);<br>   else<br>      printf("Made %s read-only\\n", filename);<br>}</>\n
chsize	<font color=blue>功  能</font>: 改变文件大小<br><font color=blue>用  法</font>: int chsize(int handle, long size);<br><font color=blue>程序例</font>:<br>#include < string.h ><br>#include < fcntl.h ><br>#include < io.h ><br>int main(void)<br>{<br>   int handle;<br>   char buf[11] = "0123456789";<br>   /* create text file containing 10 bytes */<br>   handle = open("DUMMY.FIL", O_CREAT);<br>   write(handle, buf, strlen(buf));<br>   /* truncate the file to 5 bytes in size */<br>   chsize(handle, 5);<br>   /* close the file */<br>   close(handle);<br>   return 0;<br>}\n
circle	<font color=blue>功  能</font>: 在给定半径以(x, y)为圆心画圆<br><font color=blue>用  法</font>: void far circle(int x, int y, int radius);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>int main(void)<br>{<br>   /* request auto detection */<br>   int gdriver = DETECT, gmode, errorcode;<br>   int midx, midy;<br>   int radius = 100;<br>   /* initialize graphics and local variables */<br>   initgraph(&gdriver, &gmode, "");<br>   /* read result of initialization */<br>   errorcode = graphresult();<br>   if (errorcode != grOk)  /* an error occurred */<br>   {<br>      printf("Graphics error: %s\\n", grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>      exit(1); /* terminate with an error code */<br>   }<br>   midx = getmaxx() / 2;<br>   midy = getmaxy() / 2;<br>   setcolor(getmaxcolor());<br>   /* draw the circle */<br>   circle(midx, midy, radius);<br>   /* clean up */<br>   getch();<br>   closegraph();<br>   return 0;<br>}</>\n
cleardevice	<font color=blue>功  能</font>: 清除图形屏幕<br><font color=blue>用  法</font>: void far cleardevice(void);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>int main(void)<br>{<br>   /* request auto detection */<br>   int gdriver = DETECT, gmode, errorcode;<br>   int midx, midy;<br>   /* initialize graphics and local variables */<br>   initgraph(&gdriver, &gmode, "");<br>   /* read result of initialization */<br>   errorcode = graphresult();<br>   if (errorcode != grOk)  /* an error occurred */<br>   {<br>      printf("Graphics error: %s\\n", grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>      exit(1); /* terminate with an error code */<br>   }<br>   midx = getmaxx() / 2;<br>   midy = getmaxy() / 2;<br>   setcolor(getmaxcolor());<br>   /* for centering screen messages */<br>   settextjustify(CENTER_TEXT, CENTER_TEXT);<br>   /* output a message to the screen */<br>   outtextxy(midx, midy, "press any key to clear the screen:");<br>   /* wait for a key */<br>   getch();<br>   /* clear the screen */<br>   cleardevice();<br>   /* output another message */<br>   outtextxy(midx, midy, "press any key to quit:");<br>   /* clean up */<br>   getch();<br>   closegraph();<br>   return 0;<br>}</>\n
clearerr	<font color=blue>功  能</font>: 复位错误标志<br><font color=blue>用  法</font>:void clearerr(FILE *stream);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>int main(void)<br>{<br>   FILE *fp;<br>   char ch;<br>   /* open a file for writing */<br>   fp = fopen("DUMMY.FIL", "w");<br>   /* force an error condition by attempting to read */<br>   ch = fgetc(fp);<br>   printf("%c\\n",ch);<br>   if (ferror(fp))<br>   {<br>      /* display an error message */<br>      printf("Error reading from DUMMY.FIL\\n");<br>      /* reset the error and EOF indicators */<br>      clearerr(fp);<br>   }<br>   fclose(fp);<br>   return 0;<br>}</>\n
clearviewport	<font color=blue>功  能</font>: 清除图形视区<br><font color=blue>用  法</font>: void far clearviewport(void);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>#define CLIP_ON 1   /* activates clipping in viewport */<br>int main(void)<br>{<br>   /* request auto detection */<br>   int gdriver = DETECT, gmode, errorcode;<br>   int ht;<br>   /* initialize graphics and local variables */<br>   initgraph(&gdriver, &gmode, "");<br>   /* read result of initialization */<br>   errorcode = graphresult();<br>   if (errorcode != grOk)  /* an error occurred */<br>   {<br>      printf("Graphics error: %s\\n", grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>      exit(1); /* terminate with an error code */<br>   }<br>   setcolor(getmaxcolor());<br>   ht = textheight("W");<br>   /* message in default full-screen viewport */<br>   outtextxy(0, 0, "* < -- (0, 0) in default viewport");<br>   /* create a smaller viewport */<br>   setviewport(50, 50, getmaxx()-50, getmaxy()-50, CLIP_ON);<br>   /* display some messages */<br>   outtextxy(0, 0, "* < -- (0, 0) in smaller viewport");<br>   outtextxy(0, 2*ht, "Press any key to clear viewport:");<br>   /* wait for a key */<br>   getch();<br>   /* clear the viewport */<br>   clearviewport();<br>   /* output another message */<br>   outtextxy(0, 0, "Press any key to quit:");<br>   /* clean up */<br>   getch();<br>   closegraph();<br>   return 0;<br>}</>\n
clock	<font color=blue>功  能</font>: 确定处理器时间<br><font color=blue>用  法</font>: clock_t clock(void);<br><font color=blue>程序例</font>:<br>#include < time.h ><br>#include < stdio.h ><br>#include < dos.h ><br>int main(void)<br>{<br>   clock_t start, end;<br>   start = clock();<br>   delay(2000);<br>   end = clock();<br>   printf("The time was: %f\\n", (end - start) / CLK_TCK);<br>   return 0;<br>}</>\n
close	<font color=blue>功  能</font>: 关闭文件句柄<br><font color=blue>用  法</font>: int close(int handle);<br><font color=blue>程序例</font>:<br>#include < string.h ><br>#include < stdio.h ><br>#include < fcntl.h ><br>#include < io.h ><br>main()<br>{<br>   int handle;<br>   char buf[11] = "0123456789";<br>   /* create a file containing 10 bytes */<br>   handle = open("NEW.FIL", O_CREAT);<br>   if (handle > -1)<br>   {<br>       write(handle, buf, strlen(buf));<br>       /* close the file */<br>       close(handle);<br>   }<br>   else<br>   {<br>       printf("Error opening file\\n");<br>   }<br>   return 0;<br>}</>\n
closegraph	<font color=blue>功  能</font>: 关闭图形系统<br><font color=blue>用  法</font>: void far closegraph(void);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>int main(void)<br>{<br>   /* request auto detection */<br>   int gdriver = DETECT, gmode, errorcode;<br>   int x, y;<br>   /* initialize graphics mode */<br>   initgraph(&gdriver, &gmode, "");<br>   /* read result of initialization */<br>   errorcode = graphresult();<br>   if (errorcode != grOk)  /* an error<br>      occurred */<br>   {<br>      printf("Graphics error: %s\\n", grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>      exit(1); /* terminate with an error code */<br>   }<br>   x = getmaxx() / 2;<br>   y = getmaxy() / 2;<br>   /* output a message */<br>   settextjustify(CENTER_TEXT, CENTER_TEXT);<br>   outtextxy(x, y, "Press a key to close the graphics system:");<br>   /* wait for a key */<br>   getch();<br>   /* closes down the graphics system */<br>   closegraph();<br>   printf("We're now back in text mode.\\n");<br>   printf("Press any key to halt:");<br>   getch();<br>   return 0;<br>}</>\n
clreol	<font color=blue>功  能</font>: 在文本窗口中清除字符到行末<br><font color=blue>用  法</font>: void clreol(void);<br><font color=blue>程序例</font>:<br>#include < conio.h ><br>int main(void)<br>{<br>   clrscr();<br>   cprintf("The function CLREOL clears all characters from the\\r\\n");<br>   cprintf("cursor position to the end of the line within the\\r\\n");<br>   cprintf("current text window, without moving the cursor.\\r\\n");<br>   cprintf("Press any key to continue . . .");<br>   gotoxy(14, 4);<br>   getch();<br>   clreol();<br>   getch();<br>   return 0;<br>}</>\n
clrscr	<font color=blue>功  能</font>: 清除文本模式窗口<br><font color=blue>用  法</font>: void clrscr(void);<br><font color=blue>程序例</font>:<br>#include < conio.h ><br>int main(void)<br>{<br>   int i;<br>   clrscr();<br>   for (i = 0; i < 20; i++)<br>      cprintf("%d\\r\\n", i);<br>   cprintf("\\r\\nPress any key to clear screen");<br>   getch();<br>   clrscr();<br>   cprintf("The screen has been cleared!");<br>   getch();<br>   return 0;<br>}</>\n
coreleft	<font color=blue>功  能</font>: 返回未使用内存的大小<br><font color=blue>用  法</font>: unsigned coreleft(void);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < alloc.h ><br>int main(void)<br>{<br>   printf("The difference between the highest allocated block and\\n");<br>   printf("the top of the heap is: %lu bytes\\n", (unsigned long) coreleft());<br>   return 0;<br>}<br> <br>\n
cos	<font color=blue>功  能</font>: 余弦函数<br><font color=blue>用  法</font>: double cos(double x);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < math.h ><br>int main(void)<br>{<br>   double result;<br>   double x = 0.5;<br>   result = cos(x);<br>   printf("The cosine of %lf is %lf\\n", x, result);<br>   return 0;<br>}</>\n
cosh	<font color=blue>功  能</font>: 双曲余弦函数<br><font color=blue>用  法</font>: dluble cosh(double x);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < math.h ><br>int main(void)<br>{<br>   double result;<br>   double x = 0.5;<br>   result = cosh(x);<br>   printf("The hyperboic cosine of %lf is %lf\\n", x, result);<br>   return 0;<br>}</>\n
country	<font color=blue>功  能</font>: 返回与国家有关的信息<br><font color=blue>用  法</font>: struct COUNTRY *country(int countrycode, struct country *country);<br><font color=blue>程序例</font>:<br>#include < dos.h ><br>#include < stdio.h ><br>#define USA 0<br>int main(void)<br>{<br>   struct COUNTRY country_info;<br>   country(USA, &country_info);<br>   printf("The currency symbol for the USA is: %s\\n",<br>           country_info.co_curr);<br>   return 0;<br>}</>\n
cprintf	<font color=blue>功  能</font>: 送格式化输出至屏幕<br><font color=blue>用  法</font>: int cprintf(const char *format[, argument, ...]);<br><font color=blue>程序例</font>:<br>#include < conio.h ><br>int main(void)<br>{<br>   /* clear the screen */<br>   clrscr();<br>   /* create a text window */<br>   window(10, 10, 80, 25);<br>   /* output some text in the window */<br>   cprintf("Hello world\\r\\n");<br>   /* wait for a key */<br>   getch();<br>   return 0;<br>}</>\n
cputs	<font color=blue>功  能</font>: 写字符到屏幕<br><font color=blue>用  法</font>: void cputs(const char *string);<br><font color=blue>程序例</font>:<br>#include < conio.h ><br>int main(void)<br>{<br>   /* clear the screen */<br>   clrscr();<br>   /* create a text window */<br>   window(10, 10, 80, 25);<br>   /* output some text in the window */<br>   cputs("This is within the window\\r\\n");<br>   /* wait for a key */<br>   getch();<br>   return 0;<br>}</>\n
creat	<font color=blue>功  能</font>: 创建一个新文件或重写一个已存在的文件<br><font color=blue>用  法</font>: int creat (const char *filename, int permiss);<br><font color=blue>程序例</font>:<br>#include < sys\\stat.h ><br>#include < string.h ><br>#include < fcntl.h ><br>#include < io.h ><br>int main(void)<br>{<br>   int handle;<br>   char buf[11] = "0123456789";<br>   /* change the default file mode from text to binary */<br>   _fmode = O_BINARY;<br>   /* create a binary file for reading and writing */<br>   handle = creat("DUMMY.FIL", S_IREAD | S_IWRITE);<br>   /* write 10 bytes to the file */<br>   write(handle, buf, strlen(buf));<br>   /* close the file */<br>   close(handle);<br>   return 0;<br>}<br> <br>\n
creatnew	<font color=blue>功  能</font>: 创建一个新文件<br><font color=blue>用  法</font>: int creatnew(const char *filename, int attrib);<br><font color=blue>程序例</font>:<br>#include < string.h ><br>#include < stdio.h ><br>#include < errno.h ><br>#include < dos.h ><br>#include < io.h ><br>int main(void)<br>{<br>   int handle;<br>   char buf[11] = "0123456789";<br>   /* attempt to create a file that doesn't already exist */<br>   handle = creatnew("DUMMY.FIL", 0);<br>   if (handle == -1)<br>      printf("DUMMY.FIL already exists.\\n");<br>   else<br>   {<br>      printf("DUMMY.FIL successfully created.\\n");<br>      write(handle, buf, strlen(buf));<br>      close(handle);<br>   }<br>   return 0;<br>}</>\n
creattemp	<font color=blue>功  能</font>: 创建一个新文件或重写一个已存在的文件<br><font color=blue>用  法</font>: int creattemp(const char *filename, int attrib);<br><font color=blue>程序例</font>:<br>#include < string.h ><br>#include < stdio.h ><br>#include < io.h ><br>int main(void)<br>{<br>   int handle;<br>   char pathname[128];<br>   strcpy(pathname, "\\\\");<br>   /* create a unique file in the root directory */<br>   handle = creattemp(pathname, 0);<br>   printf("%s was the unique file created.\\n", pathname);<br>   close(handle);<br>   return 0;<br>}</>\n
cscanf	<font color=blue>功  能</font>: 从控制台执行格式化输入<br><font color=blue>用  法</font>: int cscanf(char *format[,argument, ...]);<br><font color=blue>程序例</font>:<br>#include < conio.h ><br>int main(void)<br>{<br>   char string[80];<br>   /* clear the screen */<br>   clrscr();<br>   /* Prompt the user for input */<br>   cprintf("Enter a string with no spaces:");<br>   /* read the input */<br>   cscanf("%s", string);<br>   /* display what was read */<br>   cprintf("\\r\\nThe string entered is: %s", string);<br>   return 0;<br>}</>\n
ctime	<font color=blue>功  能</font>: 把日期和时间转换为字符串<br><font color=blue>用  法</font>: char *ctime(const time_t *time);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < time.h ><br>int main(void)<br>{<br>   time_t t;<br>   time(&t);<br>   printf("Today's date and time: %s\\n", ctime(&t));<br>   return 0;<br>}</>\n
ctrlbrk	<font color=blue>功  能</font>: 设置Ctrl-Break处理程序<br><font color=blue>用  法</font>: void ctrlbrk(*fptr)(void);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < dos.h ><br>#define ABORT 0<br>int c_break(void)<br>{<br>   printf("Control-Break pressed.  Program aborting ...\\n");<br>   return (ABORT);<br>}<br>int main(void)<br>{<br>   ctrlbrk(c_break);<br>   for(;;)<br>   {<br>      printf("Looping... Press < Ctrl-Break > to quit:\\n");<br>   }<br>   return 0;<br>}<br>\n
delay	<font color=blue>功  能</font>: 将程序的执行暂停一段时间(毫秒)<br><font color=blue>用  法</font>: void delay(unsigned milliseconds);<br><font color=blue>程序例</font>:<br>/* Emits a 440-Hz tone for 500 milliseconds */<br>#include < dos.h ><br>int main(void)<br>{<br>   sound(440);<br>   delay(500);<br>   nosound();<br>   return 0;<br>}\n
delline	<font color=blue>功  能</font>: 在文本窗口中删去一行<br><font color=blue>用  法</font>: void delline(void);<br><font color=blue>程序例</font>:<br>#include < conio.h ><br>int main(void)<br>{<br>   clrscr();<br>   cprintf("The function DELLINE deletes \\<br>    the line containing the\\r\\n");<br>   cprintf("cursor and moves all lines \\<br>    below it one line up.\\r\\n");<br>   cprintf("DELLINE operates within the \\<br>    currently active text\\r\\n");<br>   cprintf("window.  Press any key to \\<br>    continue . . .");<br>   gotoxy(1,2);  /* Move the cursor to the<br>      second line and first column */<br>   getch();<br>   delline();<br>   getch();<br>   return 0;<br>}<br> <br>\n
detectgraph	<font color=blue>功  能</font>: 通过检测硬件确定图形驱动程序和模式<br><font color=blue>用  法</font>: void far detectgraph(int far *graphdriver, int far *graphmode);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>/* names of the various cards supported */<br>char *dname[] = { "requests detection",<br>    "a CGA",<br>    "an MCGA",<br>    "an EGA",<br>    "a 64K EGA",<br>    "a monochrome EGA",<br>    "an IBM 8514",<br>    "a Hercules monochrome",<br>    "an AT&T 6300 PC",<br>    "a VGA",<br>    "an IBM 3270 PC"<br>  };<br>int main(void)<br>{<br>   /* returns detected hardware info. */<br>   int gdriver, gmode, errorcode;<br>  /* detect graphics hardware available */<br>   detectgraph(&gdriver, &gmode);<br>   /* read result of detectgraph call */<br>   errorcode = graphresult();<br>   if (errorcode != grOk)  /* an error<br>         occurred */<br>   {<br>      printf("Graphics error: %s\\n", \\<br>      grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>      exit(1); /* terminate with an error<br>    code */<br>   }<br>   /* display the information detected */<br>   clrscr();<br>   printf("You have %s video display \\<br>   card.\\n", dname[gdriver]);<br>   printf("Press any key to halt:");<br>   getch();<br>   return 0;<br>}</>\n
difftime	<font color=blue>功  能</font>: 计算两个时刻之间的时间差<br><font color=blue>用  法</font>: double difftime(time_t time2, time_t time1);<br><font color=blue>程序例</font>:<br>#include < time.h ><br>#include < stdio.h ><br>#include < dos.h ><br>#include < conio.h ><br>int main(void)<br>{<br>   time_t first, second;<br>   clrscr();<br>   first = time(NULL);  /* Gets system<br>      time */<br>   delay(2000);         /* Waits 2 secs */<br>   second = time(NULL); /* Gets system time<br>      again */<br>   printf("The difference is: %f \\<br>   seconds\\n",difftime(second,first));<br>   getch();<br>   return 0;<br>}\n
disable	<font color=blue>功  能</font>: 屏蔽中断<br><font color=blue>用  法</font>: void disable(void);<br><font color=blue>程序例</font>:<br>/***NOTE: This is an interrupt service<br> routine. You cannot compile this program<br> with Test Stack Overflow turned on and<br> get an executable file that operates<br> correctly. */<br>#include < stdio.h ><br>#include < dos.h ><br>#include < conio.h ><br>#define INTR 0X1C    /* The clock tick<br>   interrupt */<br>void interrupt ( *oldhandler)(void);<br>int count=0;<br>void interrupt handler(void)<br>{<br>/* disable interrupts during the handling of<br>   the interrupt */<br>   disable();<br>/* increase the global counter */<br>   count++;<br>/* reenable interrupts at the end of the<br>   handler */<br>   enable();<br>/* call the old routine */<br>   oldhandler();<br>}<br>int main(void)<br>{<br>/* save the old interrupt vector */<br>   oldhandler = getvect(INTR);<br>/* install the new interrupt handler */<br>   setvect(INTR, handler);<br>/* loop until the counter exceeds 20 */<br>   while (count < 20)<br>      printf("count is %d\\n",count);<br>/* reset the old interrupt handler */<br>   setvect(INTR, oldhandler);<br>   return 0;<br>}<br>\n
div	<font color=blue>功  能</font>: 将两个整数相除, 返回商和余数<br><font color=blue>用  法</font>: div_t (int number, int denom);<br><font color=blue>程序例</font>:<br>#include < stdlib.h ><br>#include < stdio.h ><br>div_t x;<br>int main(void)<br>{<br>   x = div(10,3);<br>   printf("10 div 3 = %d remainder %d\\n", x.quot, x.rem);<br>   return 0;<br>}\n
dosexterr	<font color=blue>功  能</font>: 获取扩展DOS错误信息<br><font color=blue>用  法</font>: int dosexterr(struct DOSERR *dblkp);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < dos.h ><br>int main(void)<br>{<br>   FILE *fp;<br>   struct DOSERROR info;<br>   fp = fopen("perror.dat","r");<br>   if (!fp) perror("Unable to open file for<br>     reading");<br>   dosexterr(&info);<br>   printf("Extended DOS error \\<br>   information:\\n");<br>   printf("   Extended error: \\<br>   %d\\n",info.exterror);<br>   printf("            Class: \\<br>   %x\\n",info.class);<br>   printf("           Action: \\<br>   %x\\n",info.action);<br>   printf("      Error Locus: \\<br>   %x\\n",info.locus);<br>   return 0;<br>}\n
dostounix	<font color=blue>功  能</font>: 转换日期和时间为UNIX时间格式<br><font color=blue>用  法</font>: long dostounix(struct date *dateptr, struct time *timeptr);<br><font color=blue>程序例</font>:<br> #include < time.h ><br> #include < stddef.h ><br> #include < dos.h ><br> #include < stdio.h ><br> int main(void)<br> {<br>    time_t t;<br>    struct time d_time;<br>    struct date d_date;<br>    struct tm *local;<br>    getdate(&d_date);<br>    gettime(&d_time);<br>    t = dostounix(&d_date, &d_time);<br>    local = localtime(&t);<br>    printf("Time and Date: %s\\n", \\<br>    asctime(local));<br>    return 0;<br>}\n
drawpoly	<font color=blue>功  能</font>: 画多边形<br><font color=blue>用  法</font>: void far drawpoly(int numpoints, int far *polypoints);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>int main(void)<br>{<br>   /* request auto detection */<br>   int gdriver = DETECT, gmode, errorcode;<br>   int maxx, maxy;<br>   /* our polygon array */<br>   int poly[10];<br>   /* initialize graphics and local<br>      variables */<br>   initgraph(&gdriver, &gmode, "");<br>   /* read result of initialization */<br>   errorcode = graphresult();<br>   if (errorcode != grOk)<br>   /* an error occurred */<br>   {<br>      printf("Graphics error: %s\\n", \\<br>      grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>   /* terminate with an error code */<br>      exit(1);<br>   }<br>   maxx = getmaxx();<br>   maxy = getmaxy();<br>   poly[0] = 20;        /* 1st vertext */<br>   poly[1] = maxy / 2;<br>   poly[2] = maxx - 20; /* 2nd */<br>   poly[3] = 20;<br>   poly[4] = maxx - 50; /* 3rd */<br>   poly[5] = maxy - 20;<br>   poly[6] = maxx / 2;  /* 4th */<br>   poly[7] = maxy / 2;<br>/<br>*   drawpoly doesn't automatically close<br>   the polygon, so we close it.<br>*/<br>   poly[8] = poly[0];<br>   poly[9] = poly[1];<br>   /* draw the polygon */<br>   drawpoly(5, poly);<br>   /* clean up */<br>   getch();<br>   closegraph();<br>   return 0;<br>}\n
dup	<font color=blue>功  能</font>: 复制一个文件句柄<br><font color=blue>用  法</font>: int dup(int handle);<br><font color=blue>程序例</font>:<br>#include < string.h ><br>#include < stdio.h ><br>#include < conio.h ><br>#include < io.h ><br>void flush(FILE *stream);<br>int main(void)<br>{<br>   FILE *fp;<br>   char msg[] = "This is a test";<br>   /* create a file */<br>   fp = fopen("DUMMY.FIL", "w");<br>   /* write some data to the file */<br>   fwrite(msg, strlen(msg), 1, fp);<br>   clrscr();<br>   printf("Press any key to flush \\<br>   DUMMY.FIL:");<br>   getch();<br>   /* flush the data to DUMMY.FIL without<br>      closing it */<br>   flush(fp);<br>   printf("\\nFile was flushed, Press any \\<br>   key to quit:");<br>   getch();<br>   return 0;<br>}<br>void flush(FILE *stream)<br>{<br>   int duphandle;<br>   /* flush TC's internal buffer */<br>   fflush(stream);<br>   /* make a duplicate file handle */<br>   duphandle = dup(fileno(stream));<br>   /* close the duplicate handle to flush the<br>      DOS buffer */<br>   close(duphandle);<br>}\n
dup2	<font color=blue>功  能</font>: 复制文件句柄<br><font color=blue>用  法</font>: int dup2(int oldhandle, int newhandle);<br><font color=blue>程序例</font>:<br>#include < sys\\stat.h ><br>#include < string.h ><br>#include < fcntl.h ><br>#include < io.h ><br>int main(void)<br>{<br>   #define STDOUT 1<br>   int nul, oldstdout;<br>   char msg[] = "This is a test";<br>   /* create a file */<br>   nul = open("DUMMY.FIL", O_CREAT | O_RDWR,<br>      S_IREAD | S_IWRITE);<br>   /* create a duplicate handle for standard<br>      output */<br>   oldstdout = dup(STDOUT);<br>   /<br>*      redirect standard output to DUMMY.FIL<br>      by duplicating the file handle onto the<br>      file handle for standard output.<br>   */<br>   dup2(nul, STDOUT);<br>   /* close the handle for DUMMY.FIL */<br>   close(nul);<br>   /* will be redirected into DUMMY.FIL */<br>   write(STDOUT, msg, strlen(msg));<br>   /* restore original standard output<br>      handle */<br>   dup2(oldstdout, STDOUT);<br>   /* close duplicate handle for STDOUT */<br>   close(oldstdout);<br>   return 0;<br>}<br> <br>\n
ecvt	<font color=blue>功  能</font>: 把一个浮点数转换为字符串<br><font color=blue>用  法</font>: char ecvt(double value, int ndigit, int *decpt, int *sign);<br><font color=blue>程序例</font>:<br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>int main(void)<br>{<br>   char *string;<br>   double value;<br>   int dec, sign;<br>   int ndig = 10;<br>   clrscr();<br>   value = 9.876;<br>   string = ecvt(value, ndig, &dec, &sign);<br>   printf("string = %s      dec = %d \\<br>   sign = %d\\n", string, dec, sign);<br>   value = -123.45;<br>   ndig= 15;<br>   string = ecvt(value,ndig,&dec,&sign);<br>   printf("string = %s dec = %d sign = %d\\n",<br>   string, dec, sign);<br> <br>   value = 0.6789e5; /* scientific<br>   notation */<br>   ndig = 5;<br>   string = ecvt(value,ndig,&dec,&sign);<br>   printf("string = %s           dec = %d\\<br>   sign = %d\\n", string, dec, sign);<br>   return 0;<br>}\n
ellipse	<font color=blue>功  能</font>: 画一椭圆<br><font color=blue>用  法</font>: void far ellipse(int x, int y, int stangle, int endangle,<br>    int xradius, int yradius);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>int main(void)<br>{<br>   /* request auto detection */<br>   int gdriver = DETECT, gmode, errorcode;<br>   int midx, midy;<br>   int stangle = 0, endangle = 360;<br>   int xradius = 100, yradius = 50;<br>   /* initialize graphics, local variables */<br>   initgraph(&gdriver, &gmode, "");<br>   /* read result of initialization */<br>   errorcode = graphresult();<br>   if (errorcode != grOk)<br>   /* an error occurred */<br>   {<br>      printf("Graphics error: %s\\n",<br>      grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>      exit(1);<br>   /* terminate with an error code */<br>   }<br>   midx = getmaxx() / 2;<br>   midy = getmaxy() / 2;<br>   setcolor(getmaxcolor());<br>   /* draw ellipse */<br>   ellipse(midx, midy, stangle, endangle,<br>    xradius, yradius);<br>   /* clean up */<br>   getch();<br>   closegraph();<br>   return 0;<br>}\n
enable	<font color=blue>功  能</font>: 开放硬件中断<br><font color=blue>用  法</font>: void enable(void);<br><font color=blue>程序例</font>:<br>/* ** NOTE:<br>This is an interrupt service routine. You can NOT compile this program<br>with Test Stack Overflow turned on and get an executable file which will<br>operate correctly.<br>*/<br>#include < stdio.h ><br>#include < dos.h ><br>#include < conio.h ><br>/* The clock tick interrupt */<br>#define INTR 0X1C<br>void interrupt ( *oldhandler)(void);<br>int count=0;<br>void interrupt handler(void)<br>{<br>/<br>*   disable interrupts during the handling of the interrupt<br>*/<br>   disable();<br>/* increase the global counter */<br>   count++;<br>/<br>*   re enable interrupts at the end of the handler<br>*/<br>   enable();<br>/* call the old routine */<br>   oldhandler();<br>}<br>int main(void)<br>{<br>/* save the old interrupt vector */<br>   oldhandler = getvect(INTR);<br>/* install the new interrupt handler */<br>   setvect(INTR, handler);<br>/* loop until the counter exceeds 20 */<br>   while (count < 20)<br>      printf("count is %d\\n",count);<br>/* reset the old interrupt handler */<br>   setvect(INTR, oldhandler);<br>   return 0;<br>}\n
eof	<font color=blue>功  能</font>: 检测文件结束<br><font color=blue>用  法</font>: int eof(int *handle);<br><font color=blue>程序例</font>:<br>#include < sys\\stat.h ><br>#include < string.h ><br>#include < stdio.h ><br>#include < fcntl.h ><br>#include < io.h ><br>int main(void)<br>{<br>   int handle;<br>   char msg[] = "This is a test";<br>   char ch;<br>   /* create a file */<br>   handle = open("DUMMY.FIL",<br>   O_CREAT | O_RDWR,<br>   S_IREAD | S_IWRITE);<br>   /* write some data to the file */<br>   write(handle, msg, strlen(msg));<br>   /* seek to the beginning of the file */<br>   lseek(handle, 0L, SEEK_SET);<br>   /<br>*      reads chars from the file until hit EOF<br>   */<br>   do<br>   {<br>      read(handle, &ch, 1);<br>      printf("%c", ch);<br>   } while (!eof(handle));<br>   close(handle);<br>   return 0;<br>}\n
exec...	<font color=blue>功  能</font>: 装入并运行其它程序的函数<br><font color=blue>用  法</font>: int execl(char *pathname, char *arg0, arg1, ..., argn, NULL);<br> int execle(char *pathname, char *arg0, arg1, ..., argn, NULL,<br>     char *envp[]);<br> int execlp(char *pathname, char *arg0, arg1, .., NULL);<br> int execple(char *pathname, char *arg0, arg1, ..., NULL,<br>      char *envp[]);<br> int execv(char *pathname, char *argv[]);<br> int execve(char *pathname, char *argv[], char *envp[]);<br> int execvp(char *pathname, char *argv[]);<br> int execvpe(char *pathname, char *argv[], char *envp[]);<br><font color=blue>程序例</font>:<br>/* execv example */<br>#include < process.h ><br>#include < stdio.h ><br>#include < errno.h ><br>void main(int argc, char *argv[])<br>{<br>   int i;<br>   printf("Command line arguments:\\n");<br>   for (i=0; i< argc; i++)<br>      printf("[%2d] : %s\\n", i, argv[i]);<br>   printf("About to exec child with arg1 arg2 ...\\n");<br>   execv("CHILD.EXE", argv);<br>   perror("exec error");<br>   exit(1);<br>}\n
exit	<font color=blue>功  能</font>: 终止程序<br><font color=blue>用  法</font>: void exit(int status);<br><font color=blue>程序例</font>:<br>#include < stdlib.h ><br>#include < conio.h ><br>#include < stdio.h ><br>int main(void)<br>{<br>   int status;<br>   printf("Enter either 1 or 2\\n");<br>   status = getch();<br>   /* Sets DOS errorlevel  */<br>   exit(status - '0');<br>/* Note: this line is never reached */<br>   return 0;<br>}\n
exp	<font color=blue>功  能</font>: 指数函数<br><font color=blue>用  法</font>: double exp(double x);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < math.h ><br>int main(void)<br>{<br>   double result;<br>   double x = 4.0;<br>   result = exp(x);<br>   printf("'e' raised to the power \\<br>   of %lf (e ^ %lf) = %lf\\n",<br>   x, x, result);<br>   return 0;<br>}<br> <br>\n
fabs	<font color=blue>功  能</font>: 返回浮点数的绝对值<br><font color=blue>用  法</font>: double fabs(double x);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < math.h ><br>int main(void)<br>{<br>   float  number = -1234.0;<br>   printf("number: %f  absolute value: %f\\n",<br>   number, fabs(number));<br>   return 0;<br>}</>\n
farcalloc	<font color=blue>功  能</font>: 从远堆栈中申请空间<br><font color=blue>用  法</font>: void far *farcalloc(unsigned long units, unsigned ling unitsz);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < alloc.h ><br>#include < string.h ><br>#include < dos.h ><br>int main(void)<br>{<br>   char far *fptr;<br>   char *str = "Hello";<br>   /* allocate memory for the far pointer */<br>   fptr = farcalloc(10, sizeof(char));<br>   /* copy "Hello" into allocated memory */<br>   /<br>*      Note: movedata is used because you<br>      might be in a small data model, in<br>      which case a normal string copy routine<br>      can not be used since it assumes the<br>      pointer size is near.<br>   */<br>   movedata(FP_SEG(str), FP_OFF(str),<br>     FP_SEG(fptr), FP_OFF(fptr),<br>            strlen(str));<br>   /* display string (note the F modifier) */<br>   printf("Far string is: %Fs\\n", fptr);<br>   /* free the memory */<br>   farfree(fptr);<br>   return 0;<br>}</>\n
farcoreleft	<font color=blue>功  能</font>: 返回远堆中未作用存储区大小<br><font color=blue>用  法</font>: long farcoreleft(void);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < alloc.h ><br>int main(void)<br>{<br>   printf("The difference between the\\<br>    highest allocated block in the\\<br>           far\\n");<br>   printf("heap and the top of the far heap\\<br>           is: %lu bytes\\n", farcoreleft());<br>   return 0;<br>}</>\n
farfree	<font color=blue>功  能</font>: 从远堆中释放一块<br><font color=blue>用  法</font>: void farfree(void);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < alloc.h ><br>#include < string.h ><br>#include < dos.h ><br>int main(void)<br>{<br>   char far *fptr;<br>   char *str = "Hello";<br>   /* allocate memory for the far pointer */<br>   fptr = farcalloc(10, sizeof(char));<br>   /* copy "Hello" into allocated memory */<br>   /<br>*      Note: movedata is used because you might be in a small data model,<br>      in which case a normal string copy routine can't be used since it<br>      assumes the pointer size is near.<br>   */<br>   movedata(FP_SEG(str), FP_OFF(str),<br>            FP_SEG(fptr), FP_OFF(fptr),<br>            strlen(str));<br>   /* display string (note the F modifier) */<br>   printf("Far string is: %Fs\\n", fptr);<br>   /* free the memory */<br>   farfree(fptr);<br>   return 0;<br>}</>\n
farmalloc	<font color=blue>功  能</font>: 从远堆中分配存储块<br><font color=blue>用  法</font>: void far *farmalloc(unsigned long size);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < alloc.h ><br>#include < string.h ><br>#include < dos.h ><br>int main(void)<br>{<br>   char far *fptr;<br>   char *str = "Hello";<br>   /* allocate memory for the far pointer */<br>   fptr = farmalloc(10);<br>   /* copy "Hello" into allocated memory */<br>   /<br>*      Note: movedata is used because we might<br>      be in a small data model, in which case<br>      a normal string copy routine can not be<br>      used since it assumes the pointer size<br>      is near.<br>   */<br>   movedata(FP_SEG(str), FP_OFF(str),<br>     FP_SEG(fptr), FP_OFF(fptr),<br>     strlen(str));<br>   /* display string (note the F modifier) */<br>   printf("Far string is: %Fs\\n", fptr);<br>   /* free the memory */<br>   farfree(fptr);<br>   return 0;<br>}</>\n
farrealloc	<font color=blue>功  能</font>: 调整远堆中的分配块<br><font color=blue>用  法</font>: void far *farrealloc(void far *block, unsigned long newsize);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < alloc.h ><br>int main(void)<br>{<br>   char far *fptr;<br>   fptr = farmalloc(10);<br>   printf("First address: %Fp\\n", fptr);<br>   fptr = farrealloc(fptr,20);<br>   printf("New address  : %Fp\\n", fptr);<br>   farfree(fptr);<br>   return 0;<br>}\n
fclose	<font color=blue>功  能</font>: 关闭一个流<br><font color=blue>用  法</font>: int fclose(FILE *stream);<br><font color=blue>程序例</font>:<br>#include < string.h ><br>#include < stdio.h ><br>int main(void)<br>{<br>   FILE *fp;<br>   char buf[11] = "0123456789";<br>   /* create a file containing 10 bytes */<br>   fp = fopen("DUMMY.FIL", "w");<br>   fwrite(&buf, strlen(buf), 1, fp);<br>   /* close the file */<br>   fclose(fp);<br>   return 0;<br>}</>\n
fcloseall	<font color=blue>功  能</font>: 关闭打开流<br><font color=blue>用  法</font>: int fcloseall(void);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>int main(void)<br>{<br>   int streams_closed;<br>   /* open two streams */<br>   fopen("DUMMY.ONE", "w");<br>   fopen("DUMMY.TWO", "w");<br>   /* close the open streams */<br>   streams_closed = fcloseall();<br>   if (streams_closed == EOF)<br>      /* issue an error message */<br>      perror("Error");<br>   else<br>      /* print result of fcloseall() function */<br>      printf("%d streams were closed.\\n", streams_closed);<br>   return 0;<br>}\n
fcvt	<font color=blue>功  能</font>: 把一个浮点数转换为字符串<br><font color=blue>用  法</font>: char *fcvt(double value, int ndigit, int *decpt, int *sign);<br><font color=blue>程序例</font>:<br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>int main(void)<br>{<br>   char *string;<br>   double value;<br>   int dec, sign;<br>   int ndig = 10;<br>   clrscr();<br>   value = 9.876;<br>   string = ecvt(value, ndig, &dec, &sign);<br>   printf("string = %s      dec = %d \\<br>          sign = %d\\n", string, dec, sign);<br>   value = -123.45;<br>   ndig= 15;<br>   string = ecvt(value,ndig,&dec,&sign);<br>   printf("string = %s dec = %d sign = %d\\n",<br>          string, dec, sign);<br> <br>   value = 0.6789e5; /* scientific<br>                        notation */<br>   ndig = 5;<br>   string = ecvt(value,ndig,&dec,&sign);<br>   printf("string = %s           dec = %d\\<br>          sign = %d\\n", string, dec, sign);<br>   return 0;<br>}</>\n
fdopen	<font color=blue>功  能</font>: 把流与一个文件句柄相接<br><font color=blue>用  法</font>: FILE *fdopen(int handle, char *type);<br><font color=blue>程序例</font>:<br>#include < sys\\stat.h ><br>#include < stdio.h ><br>#include < fcntl.h ><br>#include < io.h ><br>int main(void)<br>{<br>   int handle;<br>   FILE *stream;<br>   /* open a file */<br>   handle = open("DUMMY.FIL", O_CREAT,<br>    S_IREAD | S_IWRITE);<br>   /* now turn the handle into a stream */<br>   stream = fdopen(handle, "w");<br>   if (stream == NULL)<br>      printf("fdopen failed\\n");<br>   else<br>   {<br>      fprintf(stream, "Hello world\\n");<br>      fclose(stream);<br>   }<br>   return 0;<br>}\n
feof	<font color=blue>功  能</font>: 检测流上的文件结束符<br><font color=blue>用  法</font>: int feof(FILE *stream);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>int main(void)<br>{<br>   FILE *stream;<br>   /* open a file for reading */<br>   stream = fopen("DUMMY.FIL", "r");<br>   /* read a character from the file */<br>   fgetc(stream);<br>   /* check for EOF */<br>   if (feof(stream))<br>      printf("We have reached end-of-file\\n");<br>   /* close the file */<br>   fclose(stream);<br>   return 0;<br>}\n
ferror	<font color=blue>功  能</font>: 检测流上的错误<br><font color=blue>用  法</font>: int ferror(FILE *stream);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>int main(void)<br>{<br>   FILE *stream;<br>   /* open a file for writing */<br>   stream = fopen("DUMMY.FIL", "w");<br>   /* force an error condition by attempting to read */<br>   (void) getc(stream);<br>   if (ferror(stream))  /* test for an error on the stream */<br>   {<br>      /* display an error message */<br>      printf("Error reading from DUMMY.FIL\\n");<br>      /* reset the error and EOF indicators */<br>      clearerr(stream);<br>   }<br>   fclose(stream);<br>   return 0;<br>}</>\n
fflush	<font color=blue>功  能</font>: 清除一个流<br><font color=blue>用  法</font>: int fflush(FILE *stream);<br><font color=blue>程序例</font>:<br>#include < string.h ><br>#include < stdio.h ><br>#include < conio.h ><br>#include < io.h ><br>void flush(FILE *stream);<br>int main(void)<br>{<br>   FILE *stream;<br>   char msg[] = "This is a test";<br>   /* create a file */<br>   stream = fopen("DUMMY.FIL", "w");<br>   /* write some data to the file */<br>   fwrite(msg, strlen(msg), 1, stream);<br>   clrscr();<br>   printf("Press any key to flush\\<br>   DUMMY.FIL:");<br>   getch();<br>   /* flush the data to DUMMY.FIL without\\<br>      closing it */<br>   flush(stream);<br>   printf("\\nFile was flushed, Press any key\\<br>   to quit:");<br>   getch();<br>   return 0;<br>}<br>void flush(FILE *stream)<br>{<br>     int duphandle;<br>     /* flush the stream's internal buffer */<br>     fflush(stream);<br>     /* make a duplicate file handle */<br>     duphandle = dup(fileno(stream));<br>     /* close the duplicate handle to flush\\<br>        the DOS buffer */<br>     close(duphandle);<br>}</>\n
fgetc	<font color=blue>功  能</font>: 从流中读取字符<br><font color=blue>用  法</font>: int fgetc(FILE *stream);<br><font color=blue>程序例</font>:<br>#include < string.h ><br>#include < stdio.h ><br>#include < conio.h ><br>int main(void)<br>{<br>   FILE *stream;<br>   char string[] = "This is a test";<br>   char ch;<br>   /* open a file for update */<br>   stream = fopen("DUMMY.FIL", "w+");<br>   /* write a string into the file */<br>   fwrite(string, strlen(string), 1, stream);<br>   /* seek to the beginning of the file */<br>   fseek(stream, 0, SEEK_SET);<br>   do<br>   {<br>      /* read a char from the file */<br>      ch = fgetc(stream);<br>      /* display the character */<br>      putch(ch);<br>   } while (ch != EOF);<br>   fclose(stream);<br>   return 0;<br>}</>\n
fgetchar	<font color=blue>功  能</font>: 从流中读取字符<br><font color=blue>用  法</font>: int fgetchar(void);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>int main(void)<br>{<br>   char ch;<br>   /* prompt the user for input */<br>   printf("Enter a character followed by \\<br>   < Enter >: ");<br>   /* read the character from stdin */<br>   ch = fgetchar();<br>   /* display what was read */<br>   printf("The character read is: '%c'\\n",<br>          ch);<br>   return 0;<br>}</>\n
fgetpos	<font color=blue>功  能</font>: 取得当前文件的句柄<br><font color=blue>用  法</font>: int fgetpos(FILE *stream);<br><font color=blue>程序例</font>:<br>#include < string.h ><br>#include < stdio.h ><br>int main(void)<br>{<br>   FILE *stream;<br>   char string[] = "This is a test";<br>   fpos_t filepos;<br>   /* open a file for update */<br>   stream = fopen("DUMMY.FIL", "w+");<br>   /* write a string into the file */<br>   fwrite(string, strlen(string), 1, stream);<br>   /* report the file pointer position */<br>   fgetpos(stream, &filepos);<br>   printf("The file pointer is at byte\\<br>          %ld\\n", filepos);<br>   fclose(stream);<br>   return 0;<br>}</>\n
fgets	<font color=blue>功  能</font>: 从流中读取一字符串<br><font color=blue>用  法</font>: char *fgets(char *string, int n, FILE *stream);<br><font color=blue>程序例</font>:<br>#include < string.h ><br>#include < stdio.h ><br>int main(void)<br>{<br>   FILE *stream;<br>   char string[] = "This is a test";<br>   char msg[20];<br>   /* open a file for update */<br>   stream = fopen("DUMMY.FIL", "w+");<br>   /* write a string into the file */<br>   fwrite(string, strlen(string), 1, stream);<br>   /* seek to the start of the file */<br>   fseek(stream, 0, SEEK_SET);<br>   /* read a string from the file */<br>   fgets(msg, strlen(string)+1, stream);<br>   /* display the string */<br>   printf("%s", msg);<br>   fclose(stream);<br>   return 0;<br>}</>\n
filelength	<font color=blue>功  能</font>: 取文件长度字节数<br><font color=blue>用  法</font>: long filelength(int handle);<br><font color=blue>程序例</font>:<br>#include < string.h ><br>#include < stdio.h ><br>#include < fcntl.h ><br>#include < io.h ><br>int main(void)<br>{<br>   int handle;<br>   char buf[11] = "0123456789";<br>   /* create a file containing 10 bytes */<br>   handle = open("DUMMY.FIL", O_CREAT);<br>   write(handle, buf, strlen(buf));<br>   /* display the size of the file */<br>   printf("file length in bytes: %ld\\n",<br>   filelength(handle));<br>   /* close the file */<br>   close(handle);<br>   return 0;<br>}\n
fillellipse	<font color=blue>功  能</font>: 画出并填充一椭圆<br><font color=blue>用  法</font>: void far fillellipse(int x, int y, int xradius, int yradius);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < conio.h ><br>int main(void)<br>{<br>   int gdriver = DETECT, gmode;<br>   int xcenter, ycenter, i;<br>   initgraph(&gdriver,&gmode,"");<br>   xcenter = getmaxx() / 2;<br>   ycenter = getmaxy() / 2;<br>   for (i=0; i< 13; i++)<br>   {<br>      setfillstyle(i,WHITE);<br>      fillellipse(xcenter,ycenter,100,50);<br>      getch();<br>   }<br>   closegraph();<br>   return 0;<br>}</>\n
fillpoly	<font color=blue>功  能</font>: 画并填充一个多边形<br><font color=blue>用  法</font>: void far fillpoly(int numpoints, int far *polypoints);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>int main(void)<br>{<br>   /* request auto detection */<br>   int gdriver = DETECT, gmode, errorcode;<br>   int i, maxx, maxy;<br>   /* our polygon array */<br>   int poly[8];<br>   /* initialize graphics, local variables */<br>   initgraph(&gdriver, &gmode, "");<br>   /* read result of initialization */<br>   errorcode = graphresult();<br>   if (errorcode != grOk)<br>   /* an error occurred */<br>   {<br>      printf("Graphics error: %s\\n",<br>             grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>      exit(1);<br>      /* terminate with an error code */<br>   }<br>   maxx = getmaxx();<br>   maxy = getmaxy();<br>   poly[0] = 20;        /* 1st vertext */<br>   poly[1] = maxy / 2;<br>   poly[2] = maxx - 20; /* 2nd */<br>   poly[3] = 20;<br>   poly[4] = maxx - 50; /* 3rd */<br>   poly[5] = maxy - 20;<br>   /<br>*      4th vertex. fillpoly automatically<br>      closes the polygon.<br>   */<br>   poly[6] = maxx / 2;<br>   poly[7] = maxy / 2;<br>   /* loop through the fill patterns */<br>   for (i=EMPTY_FILL; i< USER_FILL; i++)<br>   {<br>      /* set fill pattern */<br>      setfillstyle(i, getmaxcolor());<br>      /* draw a filled polygon */<br>      fillpoly(4, poly);<br>      getch();<br>   }<br>   /* clean up */<br>   closegraph();<br>   return 0;<br>}</>\n
findfirst, findnext	<font color=blue>功  能</font>: 搜索磁盘目录; 取得下一个匹配的findfirst模式的文件<br><font color=blue>用  法</font>: int findfirst(char *pathname, struct ffblk *ffblk, int attrib);<br> int findnext(struct ffblk *ffblk);<br><font color=blue>程序例</font>:<br>/* findnext example */<br>#include < stdio.h ><br>#include < dir.h ><br>int main(void)<br>{<br>   struct ffblk ffblk;<br>   int done;<br>   printf("Directory listing of *.*\\n");<br>   done = findfirst("*.*",&ffblk,0);<br>   while (!done)<br>   {<br>      printf("  %s\\n", ffblk.ff_name);<br>      done = findnext(&ffblk);<br>   }<br>   return 0;<br>}</>\n
floodfill	<font color=blue>功  能</font>: 填充一个有界区域<br><font color=blue>用  法</font>: void far floodfill(int x, int y, int border);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>int main(void)<br>{<br>   /* request auto detection */<br>   int gdriver = DETECT, gmode, errorcode;<br>   int maxx, maxy;<br>   /* initialize graphics, local variables */<br>   initgraph(&gdriver, &gmode, "");<br>   /* read result of initialization */<br>   errorcode = graphresult();<br>   if (errorcode != grOk)<br>   /* an error occurred */<br>   {<br>      printf("Graphics error: %s\\n",<br>             grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>      exit(1);<br>      /* terminate with an error code */<br>   }<br>   maxx = getmaxx();<br>   maxy = getmaxy();<br>   /* select drawing color */<br>   setcolor(getmaxcolor());<br>   /* select fill color */<br>   setfillstyle(SOLID_FILL, getmaxcolor());<br>   /* draw a border around the screen */<br>   rectangle(0, 0, maxx, maxy);<br>   /* draw some circles */<br>   circle(maxx / 3, maxy /2, 50);<br>   circle(maxx / 2, 20, 100);<br>   circle(maxx-20, maxy-50, 75);<br>   circle(20, maxy-20, 25);<br>   /* wait for a key */<br>   getch();<br>   /* fill in bounded region */<br>   floodfill(2, 2, getmaxcolor());<br>   /* clean up */<br>   getch();<br>   closegraph();<br>   return 0;<br>}</>\n
floor	<font color=blue>功  能</font>: 向下舍入<br><font color=blue>用  法</font>: double floor(double x);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < math.h ><br>int main(void)<br>{<br>   double number = 123.54;<br>   double down, up;<br>   down = floor(number);<br>   up = ceil(number);<br>   printf("original number     %10.2lf\\n",<br>          number);<br>   printf("number rounded down %10.2lf\\n",<br>          down);<br>   printf("number rounded up   %10.2lf\\n",<br>          up);<br>   return 0;<br>}</>\n
flushall	<font color=blue>功  能</font>: 清除所有缓冲区<br><font color=blue>用  法</font>: int flushall(void);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>int main(void)<br>{<br>   FILE *stream;<br>   /* create a file */<br>   stream = fopen("DUMMY.FIL", "w");<br>   /* flush all open streams */<br>   printf("%d streams were flushed.\\n",<br>   flushall());<br>   /* close the file */<br>   fclose(stream);<br>   return 0;<br>}</>\n
fmod	<font color=blue>功  能</font>: 计算x对y的模, 即x/y的余数<br><font color=blue>用  法</font>: double fmod(double x, double y);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < math.h ><br>int main(void)<br>{<br>   double x = 5.0, y = 2.0;<br>   double result;<br>   result = fmod(x,y);<br>   printf("The remainder of (%lf / %lf) is \\<br>          %lf\\n", x, y, result);<br>   return 0;<br>}</>\n
fnmerge	<font color=blue>功  能</font>: 建立新文件名<br><font color=blue>用  法</font>: void fnerge(char *path, char *drive, char *dir);<br><font color=blue>程序例</font>:<br>#include < string.h ><br>#include < stdio.h ><br>#include < dir.h ><br> <br>int main(void)<br>{<br>    char s[MAXPATH];<br>    char drive[MAXDRIVE];<br>    char dir[MAXDIR];<br>    char file[MAXFILE];<br>    char ext[MAXEXT];<br>    getcwd(s,MAXPATH);              /* get the current working directory */<br>    strcat(s,"\\\\");                  /* append on a trailing \\ character */<br>    fnsplit(s,drive,dir,file,ext); /* split the string to separate elems */<br>    strcpy(file,"DATA");<br>    strcpy(ext,".TXT");<br>    fnmerge(s,drive,dir,file,ext);   /* merge everything into one string */<br>    puts(s);                                 /* display resulting string */<br>    return 0;<br>}</>\n
fopen	<font color=blue>功  能</font>: 打开一个流<br><font color=blue>用  法</font>: FILE *fopen(char *filename, char *type);<br><font color=blue>程序例</font>:<br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < dir.h ><br>int main(void)<br>{<br>    char *s;<br>    char drive[MAXDRIVE];<br>    char dir[MAXDIR];<br>    char file[MAXFILE];<br>    char ext[MAXEXT];<br>    int flags;<br>    s=getenv("COMSPEC"); /* get the comspec environment parameter */<br>    flags=fnsplit(s,drive,dir,file,ext);<br>    printf("Command processor info:\\n");<br>    if(flags & DRIVE)<br>       printf("\\tdrive: %s\\n",drive);<br>    if(flags & DIRECTORY)<br>       printf("\\tdirectory: %s\\n",dir);<br>    if(flags & FILENAME)<br>       printf("\\tfile: %s\\n",file);<br>    if(flags & EXTENSION)<br>       printf("\\textension: %s\\n",ext);<br>    return 0;<br>}<br> <br>\n
FP_OFF	<font color=blue>功  能</font>: 获取远地址偏移量<br><font color=blue>用  法</font>: unsigned FP_OFF(void far *farptr);<br><font color=blue>程序例</font>:<br>/* FP_OFF */<br>#include < dos.h ><br>#include < stdio.h ><br>int main(void)<br>{<br>   char *str = "fpoff.c";<br>   printf("The offset of this file in memory\\<br>          is: %Fp\\n", FP_OFF(str));<br>   return 0;<br>}\n
fprintf	<font color=blue>功  能</font>: 传送格式化输出到一个流中<br><font color=blue>用  法</font>: int fprintf(FILE *stream, char *format[, argument,...]);<br><font color=blue>程序例</font>:<br>/* Program to create backup of the<br>   AUTOEXEC.BAT file */<br>#include < stdio.h ><br>int main(void)<br>{<br>   FILE *in, *out;<br>   if ((in = fopen("\\\\AUTOEXEC.BAT", "rt"))<br>       == NULL)<br>   {<br>      fprintf(stderr, "Cannot open input \\<br>       file.\\n");<br>      return 1;<br>   }<br>   if ((out = fopen("\\\\AUTOEXEC.BAK", "wt"))<br>       == NULL)<br>   {<br>      fprintf(stderr, "Cannot open output \\<br>       file.\\n");<br>      return 1;<br>   }<br>   while (!feof(in))<br>      fputc(fgetc(in), out);<br>   fclose(in);<br>   fclose(out);<br>   return 0;<br>}</>\n
FP_SEG	<font color=blue>功  能</font>: 获取远地址段值<br><font color=blue>用  法</font>: unsigned FP_SEG(void far *farptr);<br><font color=blue>程序例</font>:<br>/* FP_SEG */<br>#include < dos.h ><br>#include < stdio.h ><br>int main(void)<br>{<br>   char *filename = "fpseg.c";<br>   printf("The offset of this file in memory\\<br>   is: %Fp\\n", FP_SEG(filename));<br>   return(0);<br>}</>\n
fputc	<font color=blue>功  能</font>: 送一个字符到一个流中<br><font color=blue>用  法</font>: int fputc(int ch, FILE *stream);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>int main(void)<br>{<br>   char msg[] = "Hello world";<br>   int i = 0;<br>   while (msg[i])<br>   {<br>      fputc(msg[i], stdout);<br>      i++;<br>   }<br>   return 0;<br>}</>\n
fputchar	<font color=blue>功  能</font>: 送一个字符到标准输出流(stdout)中<br><font color=blue>用  法</font>: int fputchar(char ch);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>int main(void)<br>{<br>   char msg[] = "This is a test";<br>   int i = 0;<br>   while (msg[i])<br>   {<br>      fputchar(msg[i]);<br>      i++;<br>   }<br>   return 0;<br>}</>\n
fputs	<font color=blue>功  能</font>: 送一个字符到一个流中<br><font color=blue>用  法</font>: int fputs(char *string, FILE *stream);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>int main(void)<br>{<br>   /* write a string to standard output */<br>   fputs("Hello world\\n", stdout);<br>   return 0;<br>}</>\n
fread	<font color=blue>功  能</font>: 从一个流中读数据<br><font color=blue>用  法</font>: int fread(void *ptr, int size, int nitems, FILE *stream);<br><font color=blue>程序例</font>:<br>#include < string.h ><br>#include < stdio.h ><br>int main(void)<br>{<br>   FILE *stream;<br>   char msg[] = "this is a test";<br>   char buf[20];<br>   if ((stream = fopen("DUMMY.FIL", "w+"))<br>       == NULL)<br>   {<br>      fprintf(stderr,<br>              "Cannot open output file.\\n");<br>      return 1;<br>   }<br>   /* write some data to the file */<br>   fwrite(msg, strlen(msg)+1, 1, stream);<br>   /* seek to the beginning of the file */<br>   fseek(stream, SEEK_SET, 0);<br>   /* read the data and display it */<br>   fread(buf, strlen(msg)+1, 1, stream);<br>   printf("%s\\n", buf);<br>   fclose(stream);<br>   return 0;<br>}\n
free	<font color=blue>功  能</font>: 释放已分配的块<br><font color=blue>用  法</font>: void free(void *ptr);<br><font color=blue>程序例</font>:<br>#include < string.h ><br>#include < stdio.h ><br>#include < alloc.h ><br>int main(void)<br>{<br>   char *str;<br>   /* allocate memory for string */<br>   str = malloc(10);<br>   /* copy "Hello" to string */<br>   strcpy(str, "Hello");<br>   /* display string */<br>   printf("String is %s\\n", str);<br>   /* free memory */<br>   free(str);<br>   return 0;<br>}<br> <br>\n
freemem	<font color=blue>功  能</font>: 释放先前分配的DOS内存块<br><font color=blue>用  法</font>: int freemem(unsigned seg);<br><font color=blue>程序例</font>:<br>#include < dos.h ><br>#include < alloc.h ><br>#include < stdio.h ><br>int main(void)<br>{<br>   unsigned int size, segp;<br>   int stat;<br>   size = 64; /* (64 x 16) = 1024 bytes */<br>   stat = allocmem(size, &segp);<br>   if (stat < 0)<br>      printf("Allocated memory at segment:\\<br>      %x\\n", segp);<br>   else<br>      printf("Failed: maximum number of\\<br>      paragraphs available is %u\\n",<br>      stat);<br>   freemem(segp);<br>   return 0;<br>}\n
freopen	<font color=blue>功  能</font>: 替换一个流<br><font color=blue>用  法</font>: FILE *freopen(char *filename, char *type, FILE *stream);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>int main(void)<br>{<br>   /* redirect standard output to a file */<br>   if (freopen("OUTPUT.FIL", "w", stdout)<br>       == NULL)<br>      fprintf(stderr, "error redirecting\\<br>              stdout\\n");<br>   /* this output will go to a file */<br>   printf("This will go into a file.");<br>   /* close the standard output stream */<br>   fclose(stdout);<br>   return 0;<br>}</>\n
frexp	<font color=blue>功  能</font>: 把一个双精度数分解为尾数的指数<br><font color=blue>用  法</font>: double frexp(double value, int *eptr);<br><font color=blue>程序例</font>:<br>#include < math.h ><br>#include < stdio.h ><br>int main(void)<br>{<br>   double mantissa, number;<br>   int exponent;<br>   number = 8.0;<br>   mantissa = frexp(number, &exponent);<br>   printf("The number %lf is ", number);<br>   printf("%lf times two to the ", mantissa);<br>   printf("power of %d\\n", exponent);<br>   return 0;<br>}\n
fscanf	<font color=blue>功  能</font>: 从一个流中执行格式化输入<br><font color=blue>用  法</font>: int fscanf(FILE *stream, char *format[,argument...]);<br><font color=blue>程序例</font>:<br>#include < stdlib.h ><br>#include < stdio.h ><br>int main(void)<br>{<br>   int i;<br>   printf("Input an integer: ");<br>   /* read an integer from the<br>      standard input stream */<br>   if (fscanf(stdin, "%d", &i))<br>      printf("The integer read was: %i\\n",<br>             i);<br>   else<br>   {<br>      fprintf(stderr, "Error reading an \\<br>              integer from stdin.\\n");<br>      exit(1);<br>   }<br>   return 0;<br>}</>\n
fseek	<font color=blue>功  能</font>: 重定位流上的文件指针<br><font color=blue>用  法</font>: int fseek(FILE *stream, long offset, int fromwhere);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>long filesize(FILE *stream);<br>int main(void)<br>{<br>   FILE *stream;<br>   stream = fopen("MYFILE.TXT", "w+");<br>   fprintf(stream, "This is a test");<br>   printf("Filesize of MYFILE.TXT is %ld bytes\\n", filesize(stream));<br>   fclose(stream);<br>   return 0;<br>}<br>long filesize(FILE *stream)<br>{<br>   long curpos, length;<br>   curpos = ftell(stream);<br>   fseek(stream, 0L, SEEK_END);<br>   length = ftell(stream);<br>   fseek(stream, curpos, SEEK_SET);<br>   return length;<br>}<br> <br> </>\n
fsetpos	<font color=blue>功  能</font>: 定位流上的文件指针<br><font color=blue>用  法</font>: int fsetpos(FILE *stream, const fpos_t *pos);<br><font color=blue>程序例</font>:<br>#include < stdlib.h ><br>#include < stdio.h ><br>void showpos(FILE *stream);<br>int main(void)<br>{<br>   FILE *stream;<br>   fpos_t filepos;<br>   /* open a file for update */<br>   stream = fopen("DUMMY.FIL", "w+");<br>   /* save the file pointer position */<br>   fgetpos(stream, &filepos);<br>   /* write some data to the file */<br>   fprintf(stream, "This is a test");<br>   /* show the current file position */<br>   showpos(stream);<br>   /* set a new file position, display it */<br>   if (fsetpos(stream, &filepos) == 0)<br>     showpos(stream);<br>   else<br>   {<br>      fprintf(stderr, "Error setting file \\<br>       pointer.\\n");<br>      exit(1);<br>   }<br>   /* close the file */<br>   fclose(stream);<br>   return 0;<br>}<br>void showpos(FILE *stream)<br>{<br>   fpos_t pos;<br>   /* display the current file pointer<br>      position of a stream */<br>   fgetpos(stream, &pos);<br>   printf("File position: %ld\\n", pos);<br>}<br> <br>\n
fstat	<font color=blue>功  能</font>: 获取打开文件信息<br><font color=blue>用  法</font>: int fstat(char *handle, struct stat *buff);<br><font color=blue>程序例</font>:<br>#include < sys\\stat.h ><br>#include < stdio.h ><br>#include < time.h ><br>int main(void)<br>{<br>   struct stat statbuf;<br>   FILE *stream;<br>   /* open a file for update */<br>   if ((stream = fopen("DUMMY.FIL", "w+"))<br>       == NULL)<br>   {<br>      fprintf(stderr, "Cannot open output \\<br>              file.\\n");<br>      return(1);<br>   }<br>   fprintf(stream, "This is a test");<br>   fflush(stream);<br>   /* get information about the file */<br>   fstat(fileno(stream), &statbuf);<br>   fclose(stream);<br>   /* display the information returned */<br>   if (statbuf.st_mode & S_IFCHR)<br>      printf("Handle refers to a device.\\n");<br>   if (statbuf.st_mode & S_IFREG)<br>      printf("Handle refers to an ordinary \\<br>             file.\\n");<br>   if (statbuf.st_mode & S_IREAD)<br>      printf("User has read permission on \\<br>             file.\\n");<br>   if (statbuf.st_mode & S_IWRITE)<br>      printf("User has write permission on \\<br>              file.\\n");<br>   printf("Drive letter of file: %c\\n",<br>   'A'+statbuf.st_dev);<br>   printf("Size of file in bytes: %ld\\n",<br>   statbuf.st_size);<br>   printf("Time file last opened: %s\\n",<br>   ctime(&statbuf.st_ctime));<br>   return 0;<br>}</>\n
ftell	<font color=blue>功  能</font>: 返回当前文件指针<br><font color=blue>用  法</font>: long ftell(FILE *stream);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>int main(void)<br>{<br>   FILE *stream;<br>   stream = fopen("MYFILE.TXT", "w+");<br>   fprintf(stream, "This is a test");<br>   printf("The file pointer is at byte \\<br>          %ld\\n", ftell(stream));<br>   fclose(stream);<br>   return 0;<br>}</>\n
fwrite	<font color=blue>功  能</font>: 写内容到流中<br><font color=blue>用  法</font>: int fwrite(void *ptr, int size, int nitems, FILE *stream);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>struct mystruct<br>{<br>  int i;<br>  char ch;<br>};<br>int main(void)<br>{<br>   FILE *stream;<br>   struct mystruct s;<br>   if ((stream = fopen("TEST.$$$", "wb")) == NULL) /* open file TEST.$$$ */<br>   {<br>      fprintf(stderr, "Cannot open output file.\\n");<br>      return 1;<br>   }<br>   s.i = 0;<br>   s.ch = 'A';<br>   fwrite(&s, sizeof(s), 1, stream); /* write struct s to file */<br>   fclose(stream); /* close file */<br>   return 0;<br>}<br> <br> <br>\n
gcvt	<font color=blue>功  能</font>: 把浮点数转换成字符串<br><font color=blue>用  法</font>: char *gcvt(double value, int ndigit, char *buf);<br><font color=blue>程序例</font>:<br>#include < stdlib.h ><br>#include < stdio.h ><br>int main(void)<br>{<br>   char str[25];<br>   double num;<br>   int sig = 5; /* significant digits */<br>   /* a regular number */<br>   num = 9.876;<br>   gcvt(num, sig, str);<br>   printf("string = %s\\n", str);<br>   /* a negative number */<br>   num = -123.4567;<br>   gcvt(num, sig, str);<br>   printf("string = %s\\n", str);<br>   /* scientific notation */<br>   num = 0.678e5;<br>   gcvt(num, sig, str);<br>   printf("string = %s\\n", str);<br>   return(0);<br>}</>\n
geninterrupt	<font color=blue>功  能</font>: 产生一个软中断<br><font color=blue>用  法</font>: void geninterrupt(int intr_num);<br><font color=blue>程序例</font>:<br>#include < conio.h ><br>#include < dos.h ><br>/* function prototype */<br>void writechar(char ch);<br>int main(void)<br>{<br>   clrscr();<br>   gotoxy(80,25);<br>   writechar('*');<br>   getch();<br>   return 0;<br>}<br>/<br>*   outputs a character at the current cursor<br>   position using the video BIOS to avoid the<br>   scrolling of the screen when writing to<br>   location (80,25).<br>*/<br>void writechar(char ch)<br>{<br>   struct text_info ti;<br>   /* grab current text settings */<br>   gettextinfo(&ti);<br>   /* interrupt 0x10 sub-function 9 */<br>   _AH = 9;<br>   /* character to be output */<br>   _AL = ch;<br>   _BH = 0;                  /* video page */<br>   _BL = ti.attribute;  /* video attribute */<br>   _CX = 1;           /* repetition factor */<br>   geninterrupt(0x10);  /* output the char */<br>}\n
getarccoords	<font color=blue>功  能</font>: 取得最后一次调用arc的坐标<br><font color=blue>用  法</font>: void far getarccoords(struct arccoordstype far *arccoords);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>int main(void)<br>{<br>/* request auto detection */<br>   int gdriver = DETECT, gmode, errorcode;<br>   struct arccoordstype arcinfo;<br>   int midx, midy;<br>   int stangle = 45, endangle = 270;<br>   char sstr[80], estr[80];<br>/* initialize graphics and local variables */<br>   initgraph(&gdriver, &gmode, "");<br>/* read result of initialization */<br>   errorcode = graphresult();<br>/* an error occurred */<br>   if (errorcode != grOk)<br>   {<br>      printf("Graphics error: %s\\n",<br>             grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>/* terminate with an error code */<br>      exit(1);<br>   }<br>   midx = getmaxx() / 2;<br>   midy = getmaxy() / 2;<br>/* draw arc and get coordinates */<br>   setcolor(getmaxcolor());<br>   arc(midx, midy, stangle, endangle, 100);<br>   getarccoords(&arcinfo);<br>/* convert arc information into strings */<br>   sprintf(sstr, "*- (%d, %d)",<br>           arcinfo.xstart, arcinfo.ystart);<br>   sprintf(estr, "*- (%d, %d)",<br>           arcinfo.xend, arcinfo.yend);<br>   /* output the arc information */<br>   outtextxy(arcinfo.xstart,<br>             arcinfo.ystart, sstr);<br>   outtextxy(arcinfo.xend,<br>             arcinfo.yend, estr);<br>   /* clean up */<br>   getch();<br>   closegraph();<br>   return 0;<br>}</>\n
getaspectratio	<font color=blue>功  能</font>: 返回当前图形模式的纵横比<br><font color=blue>用  法</font>: void far getaspectratio(int far *xasp, int far *yasp);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>int main(void)<br>{<br>/* request auto detection */<br>   int gdriver = DETECT, gmode, errorcode;<br>   int xasp, yasp, midx, midy;<br>/* initialize graphics and local variables */<br>   initgraph(&gdriver, &gmode, "");<br>/* read result of initialization */<br>   errorcode = graphresult();<br>/* an error occurred */<br>   if (errorcode != grOk)<br>   {<br>      printf("Graphics error: %s\\n",<br>             grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>/* terminate with an error code */<br>      exit(1);<br>   }<br>   midx = getmaxx() / 2;<br>   midy = getmaxy() / 2;<br>   setcolor(getmaxcolor());<br>/* get current aspect ratio settings */<br>   getaspectratio(&xasp, &yasp);<br>/* draw normal circle */<br>   circle(midx, midy, 100);<br>   getch();<br>/* draw wide circle */<br>   cleardevice();<br>   setaspectratio(xasp/2, yasp);<br>   circle(midx, midy, 100);<br>   getch();<br>/* draw narrow circle */<br>   cleardevice();<br>   setaspectratio(xasp, yasp/2);<br>   circle(midx, midy, 100);<br>/* clean up */<br>   getch();<br>   closegraph();<br>   return 0;<br>}</>\n
getbkcolor	<font color=blue>功  能</font>: 返回当前背景颜色<br><font color=blue>用  法</font>: int far getbkcolor(void);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < string.h ><br>#include < stdio.h ><br>#include < conio.h ><br>int main(void)<br>{<br>   /* request auto detection */<br>   int gdriver = DETECT, gmode, errorcode;<br>   int bkcolor, midx, midy;<br>   char bkname[35];<br>/* initialize graphics and local variables */<br>   initgraph(&gdriver, &gmode, "");<br>/* read result of initialization */<br>   errorcode = graphresult();<br>/* an error occurred */<br>   if (errorcode != grOk)<br>   {<br>      printf("Graphics error: %s\\n",<br>             grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>/* terminate with an error code */<br>      exit(1);<br>   }<br>   midx = getmaxx() / 2;<br>   midy = getmaxy() / 2;<br>   setcolor(getmaxcolor());<br>/* for centering text on the display */<br>   settextjustify(CENTER_TEXT, CENTER_TEXT);<br>/* get the current background color */<br>   bkcolor = getbkcolor();<br>/* convert color value into a string */<br>   itoa(bkcolor, bkname, 10);<br>   strcat(bkname,<br> " is the current background color.");<br>/* display a message */<br>   outtextxy(midx, midy, bkname);<br>/* clean up */<br>   getch();<br>   closegraph();<br>   return 0;<br>}</>\n
getc	<font color=blue>功  能</font>: 从流中取字符<br><font color=blue>用  法</font>: int getc(FILE *stream);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>int main(void)<br>{<br>   char ch;<br>   printf("Input a character:");<br>/* read a character from the<br>   standard input stream */<br>   ch = getc(stdin);<br>   printf("The character input was: '%c'\\n",<br>          ch);<br>   return 0;<br>}</>\n
getcbrk	<font color=blue>功  能</font>: 获取Control_break设置<br><font color=blue>用  法</font>: int getcbrk(void);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < dos.h ><br>int main(void)<br>{<br>   if (getcbrk())<br>      printf("Cntrl-brk flag is on\\n");<br>   else<br>      printf("Cntrl-brk flag is off\\n");<br>   return 0;<br>}\n
getch	<font color=blue>功  能</font>: 从控制台无回显地取一个字符<br><font color=blue>用  法</font>: int getch(void);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < conio.h ><br>int main(void)<br>{<br>   char ch;<br>   printf("Input a character:");<br>   ch = getche();<br>   printf("\\nYou input a '%c'\\n", ch);<br>   return 0;<br>}\n
getchar	<font color=blue>功  能</font>: 从stdin流中读字符<br><font color=blue>用  法</font>: int getchar(void);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>int main(void)<br>{<br>   int c;<br>   /* Note that getchar reads from stdin and<br>      is line buffered; this means it will<br>      not return until you press ENTER. */<br>   while ((c = getchar()) != '\\n')<br>      printf("%c", c);<br>   return 0;<br>}\n
getche	<font color=blue>功  能</font>: 从控制台取字符(带回显)<br><font color=blue>用  法</font>: int getche(void);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < conio.h ><br>int main(void)<br>{<br>   char ch;<br>   printf("Input a character:");<br>   ch = getche();<br>   printf("\\nYou input a '%c'\\n", ch);<br>   return 0;<br>}\n
getcolor	<font color=blue>功  能</font>: 返回当前画线颜色<br><font color=blue>用  法</font>: int far getcolor(void);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < string.h ><br>#include < stdio.h ><br>#include < conio.h ><br>int main(void)<br>{<br>/* request auto detection */<br>   int gdriver = DETECT, gmode, errorcode;<br>   int color, midx, midy;<br>   char colname[35];<br>/* initialize graphics and local variables */<br>   initgraph(&gdriver, &gmode, "");<br>/* read result of initialization */<br>   errorcode = graphresult();<br>/* an error occurred */<br>   if (errorcode != grOk)<br>   {<br>      printf("Graphics error: %s\\n",<br>             grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>/* terminate with an error code */<br>      exit(1);<br>   }<br>   midx = getmaxx() / 2;<br>   midy = getmaxy() / 2;<br>   setcolor(getmaxcolor());<br>/* for centering text on the display */<br>   settextjustify(CENTER_TEXT, CENTER_TEXT);<br>/* get the current drawing color */<br>   color = getcolor();<br>/* convert color value into a string */<br>   itoa(color, colname, 10);<br>   strcat(colname,<br>   " is the current drawing color.");<br>/* display a message */<br>   outtextxy(midx, midy, colname);<br>/* clean up */<br>   getch();<br>   closegraph();<br>   return 0;<br>}\n
getcurdir	<font color=blue>功  能</font>: 取指定驱动器的当前目录<br><font color=blue>用  法</font>: int getcurdir(int drive, char *direc);<br><font color=blue>程序例</font>:<br>#include < dir.h ><br>#include < stdio.h ><br>#include < string.h ><br>char *current_directory(char *path)<br>{<br>   strcpy(path, "X:\\\\");      /* fill string with form of response: X:\\ */<br>   path[0] = 'A' + getdisk();    /* replace X with current drive letter */<br>   getcurdir(0, path+3);  /* fill rest of string with current directory */<br>   return(path);<br>}<br>int main(void)<br>{<br>   char curdir[MAXPATH];<br>   current_directory(curdir);<br>   printf("The current directory is %s\\n", curdir);<br>   return 0;<br>}\n
getcwd	<font color=blue>功  能</font>: 取当前工作目录<br><font color=blue>用  法</font>: char *getcwd(char *buf, int n);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < dir.h ><br>int main(void)<br>{<br>   char buffer[MAXPATH];<br>   getcwd(buffer, MAXPATH);<br>   printf("The current directory is: %s\\n", buffer);<br>   return 0;<br>}\n
getdate	<font color=blue>功  能</font>: 取DOS日期<br><font color=blue>用  法</font>: void getdate(struct *dateblk);<br><font color=blue>程序例</font>:<br>#include < dos.h ><br>#include < stdio.h ><br>int main(void)<br>{<br>   struct date d;<br>   getdate(&d);<br>   printf("The current year is: %d\\n",<br>   d.da_year);<br>   printf("The current day is: %d\\n",<br>   d.da_day);<br>   printf("The current month is: %d\\n",<br>   d.da_mon);<br>   return 0;<br>}\n
getdefaultpalette	<font color=blue>功  能</font>: 返回调色板定义结构<br><font color=blue>用  法</font>: struct palettetype *far getdefaultpalette(void);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>int main(void)<br>{<br>/* request auto detection */<br>   int gdriver = DETECT, gmode, errorcode;<br>   int i;<br>/* structure for returning palette copy */<br>   struct palettetype far *pal=(void *) 0;<br>/* initialize graphics and local variables */<br>   initgraph(&gdriver, &gmode, "");<br>/* read result of initialization */<br>   errorcode = graphresult();<br>/* an error occurred */<br>   if (errorcode != grOk)<br>   {<br>      printf("Graphics error: %s\\n",<br>             grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>/* terminate with an error code */<br>      exit(1);<br>   }<br>   setcolor(getmaxcolor());<br>/* return a pointer to the default palette */<br>   pal = getdefaultpalette();<br>   for (i=0; i< 16; i++)<br>   {<br>      printf("colors[%d] = %d\\n", i,<br>             pal- >colors[i]);<br>      getch();<br>   }<br>/* clean up */<br>   getch();<br>   closegraph();<br>   return 0;<br>}\n
getdisk	<font color=blue>功  能</font>: 取当前磁盘驱动器号<br><font color=blue>用  法</font>: int getdisk(void);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < dir.h ><br>int main(void)<br>{<br>   int disk;<br>   disk = getdisk() + 'A';<br>   printf("The current drive is: %c\\n",<br>    disk);<br>   return 0;<br>}</>\n
getdrivername	<font color=blue>功  能</font>: 返回指向包含当前图形驱动程序名字的字符串指针<br><font color=blue>用  法</font>: char *getdrivename(void);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>int main(void)<br>{<br>/* request auto detection */<br>   int gdriver = DETECT, gmode, errorcode;<br>/* stores the device driver name */<br>   char *drivername;<br>/* initialize graphics and local variables */<br>   initgraph(&gdriver, &gmode, "");<br>/* read result of initialization */<br>   errorcode = graphresult();<br>/* an error occurred */<br>   if (errorcode != grOk)<br>   {<br>      printf("Graphics error: %s\\n",<br>              grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>/* terminate with an error code */<br>      exit(1);<br>   }<br>   setcolor(getmaxcolor());<br>/* get name of the device driver in use */<br>   drivername = getdrivername();<br>/* for centering text on the screen */<br>   settextjustify(CENTER_TEXT, CENTER_TEXT);<br>/* output the name of the driver */<br>   outtextxy(getmaxx() / 2, getmaxy() / 2,<br>      drivername);<br>/* clean up */<br>   getch();<br>   closegraph();<br>   return 0;<br>}\n
getdta	<font color=blue>功  能</font>: 取磁盘传输地址<br><font color=blue>用  法</font>: char far *getdta(void);<br><font color=blue>程序例</font>:<br>#include < dos.h ><br>#include < stdio.h ><br>int main(void)<br>{<br>   char far *dta;<br>   dta = getdta();<br>   printf("The current disk transfer \\<br>   address is: %Fp\\n", dta);<br>   return 0;<br>}\n
getenv	<font color=blue>功  能</font>: 从环境中取字符串<br><font color=blue>用  法</font>: char *getenv(char *envvar);<br><font color=blue>程序例</font>:<br>#include < stdlib.h ><br>#include < stdio.h ><br> <br>int main(void)<br>{<br>    char *s;<br>    s=getenv("COMSPEC");       /* get the comspec environment parameter */<br>    printf("Command processor: %s\\n",s);   /* display comspec parameter */<br>    return 0;<br>}</>\n
getfat, getfatd	<font color=blue>功  能</font>: 取文件分配表信息<br><font color=blue>用  法</font>: void getfat(int drive, struct fatinfo *fatblkp);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < dos.h ><br>int main(void)<br>{<br>   struct fatinfo diskinfo;<br>   int flag = 0;<br>   printf("Please insert disk in drive A\\n");<br>   getchar();<br>   getfat(1, &diskinfo);<br>/* get drive information */<br>   printf("\\nDrive A: is ");<br>   switch((unsigned char) diskinfo.fi_fatid)<br>   {<br>      case 0xFD:<br> printf("360K low density\\n");<br> break;<br>      case 0xF9:<br> printf("1.2 Meg high density\\n");<br> break;<br>      default:<br> printf("unformatted\\n");<br> flag = 1;<br>   }<br>   if (!flag)<br>   {<br>      printf("  sectors per cluster %5d\\n",<br>       diskinfo.fi_sclus);<br>      printf("   number of clusters %5d\\n",<br>       diskinfo.fi_nclus);<br>      printf("     bytes per sector %5d\\n",<br>       diskinfo.fi_bysec);<br>   }<br>   return 0;<br>}\n
getfillpattern	<font color=blue>功  能</font>: 将用户定义的填充模式拷贝到内存中<br><font color=blue>用  法</font>: void far getfillpattern(char far *upattern);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>int main(void)<br>{<br>   /* request auto detection */<br>   int gdriver = DETECT, gmode, errorcode;<br>   int maxx, maxy;<br>   char pattern[8] = {0x00, 0x70, 0x20, 0x27, 0x25, 0x27, 0x04, 0x04};<br>   /* initialize graphics and local variables */<br>   initgraph(&gdriver, &gmode, "");<br>   /* read result of initialization */<br>   errorcode = graphresult();<br>   if (errorcode != grOk)  /* an error occurred */<br>   {<br>      printf("Graphics error: %s\\n", grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>      exit(1); /* terminate with an error code */<br>   }<br>   maxx = getmaxx();<br>   maxy = getmaxy();<br>   setcolor(getmaxcolor());<br>   /* select a user defined fill pattern */<br>   setfillpattern(pattern, getmaxcolor());<br>   /* fill the screen with the pattern */<br>   bar(0, 0, maxx, maxy);<br>   getch();<br>   /* get the current user defined fill pattern */<br>   getfillpattern(pattern);<br>   /* alter the pattern we grabbed */<br>   pattern[4] -= 1;<br>   pattern[5] -= 3;<br>   pattern[6] += 3;<br>   pattern[7] -= 4;<br>   /* select our new pattern */<br>   setfillpattern(pattern, getmaxcolor());<br>   /* fill the screen with the new pattern */<br>   bar(0, 0, maxx, maxy);<br>   /* clean up */<br>   getch();<br>   closegraph();<br>   return 0;<br>}\n
getfillsettings	<font color=blue>功  能</font>: 取得有关当前填充模式和填充颜色的信息<br><font color=blue>用  法</font>: void far getfillsettings(struct fillsettingstype far *fillinfo);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>/  the names of the fill styles supported */<br>char *fname[] = { "EMPTY_FILL",<br>                  "SOLID_FILL",<br>                  "LINE_FILL",<br>                  "LTSLASH_FILL",<br>                  "SLASH_FILL",<br>                  "BKSLASH_FILL",<br>                  "LTBKSLASH_FILL",<br>                  "HATCH_FILL",<br>                  "XHATCH_FILL",<br>                  "INTERLEAVE_FILL",<br>                  "WIDE_DOT_FILL",<br>                  "CLOSE_DOT_FILL",<br>                  "USER_FILL"<br>        };<br>int main(void)<br>{<br>   /* request auto detection */<br>   int gdriver = DETECT, gmode, errorcode;<br>   struct fillsettingstype fillinfo;<br>   int midx, midy;<br>   char patstr[40], colstr[40];<br>   /* initialize graphics and local variables */<br>   initgraph(&gdriver, &gmode, "");<br>   /* read result of initialization */<br>   errorcode = graphresult();<br>   if (errorcode != grOk)  /* an error occurred */<br>   {<br>      printf("Graphics error: %s\\n", grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>      exit(1); /* terminate with an error code */<br>   }<br>   midx = getmaxx() / 2;<br>   midy = getmaxy() / 2;<br>   /* get information about current fill pattern and color */<br>   getfillsettings(&fillinfo);<br>   /* convert fill information into strings */<br>   sprintf(patstr, "%s is the fill style.", fname[fillinfo.pattern]);<br>   sprintf(colstr, "%d is the fill color.", fillinfo.color);<br>   /* display the information */<br>   settextjustify(CENTER_TEXT, CENTER_TEXT);<br>   outtextxy(midx, midy, patstr);<br>   outtextxy(midx, midy+2*textheight("W"), colstr);<br>   /* clean up */<br>   getch();<br>   closegraph();<br>   return 0;<br>}</>\n
getftime	<font color=blue>功  能</font>: 取文件日期和时间<br><font color=blue>用  法</font>: int getftime(int handle, struct ftime *ftimep);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < io.h ><br>int main(void)<br>{<br>   FILE *stream;<br>   struct ftime ft;<br>   if ((stream = fopen("TEST.$$$",<br>        "wt")) == NULL)<br>   {<br>      fprintf(stderr,<br>             "Cannot open output file.\\n");<br>      return 1;<br>   }<br>   getftime(fileno(stream), &ft);<br>   printf("File time: %u:%u:%u\\n",<br>          ft.ft_hour, ft.ft_min,<br>          ft.ft_tsec * 2);<br>   printf("File date: %u/%u/%u\\n",<br>   ft.ft_month, ft.ft_day,<br>   ft.ft_year+1980);<br>   fclose(stream);<br>   return 0;<br>}</>\n
getgraphmode	<font color=blue>功  能</font>: 返回当前图形模式<br><font color=blue>用  法</font>: int far getgraphmode(void);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>int main(void)<br>{<br>/* request auto detection */<br>   int gdriver = DETECT, gmode, errorcode;<br>   int midx, midy, mode;<br>   char numname[80], modename[80];<br>/* initialize graphics and local variables */<br>   initgraph(&gdriver, &gmode, "");<br>/* read result of initialization */<br>   errorcode = graphresult();<br>/* an error occurred */<br>   if (errorcode != grOk)<br>   {<br>      printf("Graphics error: %s\\n",<br>             grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>/* terminate with an error code */<br>      exit(1);<br>   }<br>   midx = getmaxx() / 2;<br>   midy = getmaxy() / 2;<br>/* get mode number and name strings */<br>   mode = getgraphmode();<br>   sprintf(numname,<br>           "%d is the current mode number.",<br>           mode);<br>   sprintf(modename,<br>           "%s is the current graphics mode",<br>           getmodename(mode));<br>/* display the information */<br>   settextjustify(CENTER_TEXT, CENTER_TEXT);<br>   outtextxy(midx, midy, numname);<br>   outtextxy(midx, midy+2*textheight("W"),<br>             modename);<br>/* clean up */<br>   getch();<br>   closegraph();<br>   return 0;<br>}\n
getimage	<font color=blue>功  能</font>: 将指定区域的一个位图存到主存中<br><font color=blue>用  法</font>: void far getimage(int left, int top, int right, int bottom,<br>     void far *bitmap);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>#include < alloc.h ><br>void save_screen(void far *buf[4]);<br>void restore_screen(void far *buf[4]);<br>int maxx, maxy;<br>int main(void)<br>{<br>   int gdriver=DETECT, gmode, errorcode;<br>   void far *ptr[4];<br>   /* auto-detect the graphics driver and mode */<br>   initgraph(&gdriver, &gmode, "");<br>   errorcode = graphresult(); /* check for any errors */<br>   if (errorcode != grOk)<br>   {<br>      printf("Graphics error: %s\\n", grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>      exit(1);<br>   }<br>   maxx = getmaxx();<br>   maxy = getmaxy();<br>   /* draw an image on the screen */<br>   rectangle(0, 0, maxx, maxy);<br>   line(0, 0, maxx, maxy);<br>   line(0, maxy, maxx, 0);<br>   save_screen(ptr);    /* save the current screen */<br>   getch();             /* pause screen */<br>   cleardevice();       /* clear screen */<br>   restore_screen(ptr); /* restore the screen */<br>   getch();             /* pause screen */<br>   closegraph();<br>   return 0;<br>}<br>void save_screen(void far *buf[4])<br>{<br>   unsigned size;<br>   int ystart=0, yend, yincr, block;<br>   yincr = (maxy+1) / 4;<br>   yend = yincr;<br>   size = imagesize(0, ystart, maxx, yend); /* get byte size of image */<br>   for (block=0; block< =3; block++)<br>   {<br>      if ((buf[block] = farmalloc(size)) == NULL)<br>      {<br>         closegraph();<br>         printf("Error: not enough heap space in save_screen().\\n");<br>  exit(1);<br>      }<br>      getimage(0, ystart, maxx, yend, buf[block]);<br>      ystart = yend + 1;<br>      yend += yincr + 1;<br>   }<br>}<br>void save_screen(void far *buf[4])<br>{<br>   unsigned size;<br>   int ystart=0, yend, yincr, block;<br>   yincr = (maxy+1) / 4;<br>   yend = yincr;<br>   size = imagesize(0, ystart, maxx, yend); /* get byte size of image */<br>   for (block=0; block< =3; block++)<br>   {<br>      if ((buf[block] = farmalloc(size)) == NULL)<br>      {<br>         closegraph();<br>         printf("Error: not enough heap space in save_screen().\\n");<br>  exit(1);<br>      }<br>      getimage(0, ystart, maxx, yend, buf[block]);<br>      ystart = yend + 1;<br>      yend += yincr + 1;<br>   }<br>}<br>void restore_screen(void far *buf[4])<br>{<br>   int ystart=0, yend, yincr, block;<br>   yincr = (maxy+1) / 4;<br>   yend = yincr;<br>   for (block=0; block< =3; block++)<br>   {<br>      putimage(0, ystart, buf[block], COPY_PUT);<br>      farfree(buf[block]);<br>      ystart = yend + 1;<br>      yend += yincr + 1;<br>   }<br>}\n
getlinesettings	<font color=blue>功  能</font>: 取当前线型、模式和宽度<br><font color=blue>用  法</font>: void far getlinesettings(struct linesettingstype far *lininfo):<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>/* the names of the line styles supported */<br>char *lname[] = { "SOLID_LINE",<br>                  "DOTTED_LINE",<br>                  "CENTER_LINE",<br>                  "DASHED_LINE",<br>                  "USERBIT_LINE"<br>                };<br>int main(void)<br>{<br>   /* request auto detection */<br>   int gdriver = DETECT, gmode, errorcode;<br>   struct linesettingstype lineinfo;<br>   int midx, midy;<br>   char lstyle[80], lpattern[80], lwidth[80];<br>   /* initialize graphics and local variables */<br>   initgraph(&gdriver, &gmode, "");<br>   /* read result of initialization */<br>   errorcode = graphresult();<br>   if (errorcode != grOk)  /* an error occurred */<br>   {<br>      printf("Graphics error: %s\\n", grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>      exit(1); /* terminate with an error code */<br>   }<br>   midx = getmaxx() / 2;<br>   midy = getmaxy() / 2;<br>   /* get information about current line settings */<br>   getlinesettings(&lineinfo);<br>   /* convert line information into strings */<br>   sprintf(lstyle, "%s is the line style.",<br>           lname[lineinfo.linestyle]);<br>   sprintf(lpattern, "0x%X is the user-defined line pattern.",<br>           lineinfo.upattern);<br>   sprintf(lwidth, "%d is the line thickness.",<br>    lineinfo.thickness);<br>   /* display the information */<br>   settextjustify(CENTER_TEXT, CENTER_TEXT);<br>   outtextxy(midx, midy, lstyle);<br>   outtextxy(midx, midy+2*textheight("W"), lpattern);<br>   outtextxy(midx, midy+4*textheight("W"), lwidth);<br>   /* clean up */<br>   getch();<br>   closegraph();<br>   return 0;<br>}\n
getmaxcolor	<font color=blue>功  能</font>: 返回可以传给函数setcolor的最大颜色值<br><font color=blue>用  法</font>: int far getmaxcolor(void);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>int main(void)<br>{<br>   /* request auto detection */<br>   int gdriver = DETECT, gmode, errorcode;<br>   int midx, midy;<br>   char colstr[80];<br>   /* initialize graphics and local variables<br>  */ initgraph(&gdriver, &gmode, "");<br>   /* read result of initialization */<br>   errorcode = graphresult();<br>   if (errorcode != grOk)  /* an error occurred */<br>   {<br>      printf("Graphics error: %s\\n", grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>      exit(1); /* terminate with an error code */<br>   }<br>   midx = getmaxx() / 2;<br>   midy = getmaxy() / 2;<br>   /* grab the color info. and convert it to a string */<br>   sprintf(colstr, "This mode supports colors 0..%d", getmaxcolor());<br>   /* display the information */<br>   settextjustify(CENTER_TEXT, CENTER_TEXT);<br>   outtextxy(midx, midy, colstr);<br>   /* clean up */<br>   getch();<br>   closegraph();<br>   return 0;<br>}</>\n
getmaxx	<font color=blue>功  能</font>: 返回屏幕的最大x坐标<br><font color=blue>用  法</font>: int far getmaxx(void);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>int main(void)<br>{<br>   /* request auto detection */<br>   int gdriver = DETECT, gmode, errorcode;<br>   int midx, midy;<br>   char xrange[80], yrange[80];<br>   /* initialize graphics and local variables */<br>   initgraph(&gdriver, &gmode, "");<br>   /* read result of initialization */<br>   errorcode = graphresult();<br>   if (errorcode != grOk)  /* an error occurred */<br>   {<br>      printf("Graphics error: %s\\n", grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>      exit(1); /* terminate with an error code */<br>   }<br>   midx = getmaxx() / 2;<br>   midy = getmaxy() / 2;<br>   /* convert max resolution values into strings */<br>   sprintf(xrange, "X values range from 0..%d", getmaxx());<br>   sprintf(yrange, "Y values range from 0..%d", getmaxy());<br>   /* display the information */<br>   settextjustify(CENTER_TEXT, CENTER_TEXT);<br>   outtextxy(midx, midy, xrange);<br>   outtextxy(midx, midy+textheight("W"), yrange);<br>   /* clean up */<br>   getch();<br>   closegraph();<br>   return 0;<br>}\n
getmaxy	<font color=blue>功  能</font>: 返回屏幕的最大y坐标<br><font color=blue>用  法</font>: int far getmaxy(void);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>int main(void)<br>{<br>   /* request auto detection */<br>   int gdriver = DETECT, gmode, errorcode;<br>   int midx, midy;<br>   char xrange[80], yrange[80];<br>   /* initialize graphics and local variables */<br>   initgraph(&gdriver, &gmode, "");<br>   /* read result of initialization */<br>   errorcode = graphresult();<br>   if (errorcode != grOk)  /* an error occurred */<br>   {<br>      printf("Graphics error: %s\\n", grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>      exit(1); /* terminate with an error code */<br>   }<br>   midx = getmaxx() / 2;<br>   midy = getmaxy() / 2;<br>   /* convert max resolution values into strings */<br>   sprintf(xrange, "X values range from 0..%d", getmaxx());<br>   sprintf(yrange, "Y values range from 0..%d", getmaxy());<br>   /* display the information */<br>   settextjustify(CENTER_TEXT, CENTER_TEXT);<br>   outtextxy(midx, midy, xrange);<br>   outtextxy(midx, midy+textheight("W"), yrange);<br>   /* clean up */<br>   getch();<br>   closegraph();<br>   return 0;<br>}<br> <br>\n
getmodename	<font color=blue>功  能</font>: 返回含有指定图形模式名的字符串指针<br><font color=blue>用  法</font>: char *far getmodename(int mode_name);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>int main(void)<br>{<br>   /* request autodetection */<br>   int gdriver = DETECT, gmode, errorcode;<br>   int midx, midy, mode;<br>   char numname[80], modename[80];<br>   /* initialize graphics and local variables */<br>   initgraph(&gdriver, &gmode, "");<br>   /* read result of initialization */<br>   errorcode = graphresult();<br>   if (errorcode != grOk)  /* an error occurred */<br>   {<br>      printf("Graphics error: %s\\n", grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>      exit(1); /* terminate with an error code */<br>   }<br>   midx = getmaxx() / 2;<br>   midy = getmaxy() / 2;<br>   /* get mode number and name strings */<br>   mode = getgraphmode();<br>   sprintf(numname, "%d is the current mode number.", mode);<br>   sprintf(modename, "%s is the current graphics mode.", getmodename(mode));<br>   /* display the information */<br>   settextjustify(CENTER_TEXT, CENTER_TEXT);<br>   outtextxy(midx, midy, numname);<br>   outtextxy(midx, midy+2*textheight("W"), modename);<br>   /* clean up */<br>   getch();<br>   closegraph();<br>   return 0;<br>}\n
getmoderange	<font color=blue>功  能</font>: 取给定图形驱动程序的模式范围<br><font color=blue>用  法</font>: void far getmoderange(int graphdriver, int far *lomode,<br>    int far *himode);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>int main(void)<br>{<br>   /* request auto detection */<br>   int gdriver = DETECT, gmode, errorcode;<br>   int midx, midy;<br>   int low, high;<br>   char mrange[80];<br>   /* initialize graphics and local variables */<br>   initgraph(&gdriver, &gmode, "");<br>   /* read result of initialization */<br>   errorcode = graphresult();<br>   if (errorcode != grOk)  /* an error occurred */<br>   {<br>      printf("Graphics error: %s\\n", grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>      exit(1); /* terminate with an error code */<br>   }<br>   midx = getmaxx() / 2;<br>   midy = getmaxy() / 2;<br>   /* get the mode range for this driver */<br>   getmoderange(gdriver, &low, &high);<br>   /* convert mode range info. into strings */<br>   sprintf(mrange, "This driver supports modes %d..%d", low, high);<br>   /* display the information */<br>   settextjustify(CENTER_TEXT, CENTER_TEXT);<br>   outtextxy(midx, midy, mrange);<br>   /* clean up */<br>   getch();<br>   closegraph();<br>   return 0;<br>}\n
getpalette	<font color=blue>功  能</font>: 返回有关当前调色板的信息<br><font color=blue>用  法</font>: void far getpalette(struct palettetype far *palette);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>int main(void)<br>{<br>/* request auto detection */<br>   int gdriver = DETECT, gmode, errorcode;<br>   struct palettetype pal;<br>   char psize[80], pval[20];<br>   int i, ht;<br>   int y = 10;<br>/* initialize graphics and local variables */<br>   initgraph(&gdriver, &gmode, "");<br>/* read result of initialization */<br>   errorcode = graphresult();<br>/* an error occurred */<br>   if (errorcode != grOk)<br>   {<br>      printf("Graphics error: %s\\n",<br>             grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>/* terminate with an error code */<br>      exit(1);<br>   }<br>/* grab a copy of the palette */<br>   getpalette(&pal);<br>/* convert palette info. into strings */<br>   sprintf(psize, "The palette has %d \\<br>           modifiable entries.", pal.size);<br>/* display the information */<br>   outtextxy(0, y, psize);<br>   if (pal.size != 0)<br>   {<br>      ht = textheight("W");<br>      y += 2*ht;<br>      outtextxy(0, y, "Here are the current \\<br>  values:");<br>      y += 2*ht;<br>      for (i=0; i< pal.size; i++, y+=ht)<br>      {<br>  sprintf(pval,<br>   "palette[%02d]: 0x%02X", i,<br>   pal.colors[i]);<br>  outtextxy(0, y, pval);<br>      }<br>   }<br>/* clean up */<br>   getch();<br>   closegraph();<br>   return 0;<br>}<br> <br>\n
getpass	<font color=blue>功  能</font>: 读一个口令<br><font color=blue>用  法</font>: char *getpass(char *prompt);<br><font color=blue>程序例</font>:<br>#include < conio.h ><br>int main(void)<br>{<br>   char *password;<br>   password = getpass("Input a password:");<br>   cprintf("The password is: %s\\r\\n",<br>    password);<br>   return 0;<br>}</>\n
getpixel	<font color=blue>功  能</font>: 取得指定像素的颜色<br><font color=blue>用  法</font>: int far getpixel(int x, int y);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>#include < dos.h ><br>#define PIXEL_COUNT 1000<br>#define DELAY_TIME  100  /* in milliseconds */<br>int main(void)<br>{<br>   /* request auto detection */<br>   int gdriver = DETECT, gmode, errorcode;<br>   int i, x, y, color, maxx, maxy,<br>       maxcolor, seed;<br>/* initialize graphics and local variables */<br>   initgraph(&gdriver, &gmode, "");<br>/* read result of initialization */<br>   errorcode = graphresult();<br>/* an error occurred */<br>   if (errorcode != grOk)<br>   {<br>      printf("Graphics error: %s\\n",<br>             grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>/* terminate with an error code */<br>      exit(1);<br>   }<br>   maxx = getmaxx() + 1;<br>   maxy = getmaxy() + 1;<br>   maxcolor = getmaxcolor() + 1;<br>   while (!kbhit())<br>   {<br>/* seed the random number generator */<br>      seed = random(32767);<br>      srand(seed);<br>      for (i=0; i< PIXEL_COUNT; i++)<br>      {<br>         x = random(maxx);<br>         y = random(maxy);<br>         color = random(maxcolor);<br>         putpixel(x, y, color);<br>      }<br>      delay(DELAY_TIME);<br>      srand(seed);<br>      for (i=0; i< PIXEL_COUNT; i++)<br>      {<br>         x = random(maxx);<br>         y = random(maxy);<br>         color = random(maxcolor);<br>         if (color == getpixel匇? ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ;h;(;);;; ;e;t;p;s;p;(;););;; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ;e;s;e;t; ;t;o; ;s;e;g;m;e;n;t; ;o;f; ;t;h;e; ;P;S;P; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ;i;n;e; ;i;s; ;l;o;c;a;t;e;d; ;a;t; ;o;f;f;s;e;t; ;0;x;8;1; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ;t; ;o;f; ;P;S;P; ; ; ; ; ; ; ; ;<br> <br>\n
gets	<font color=blue>功  能</font>: 从流中取一字符串<br><font color=blue>用  法</font>: char *gets(char *string);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>int main(void)<br>{<br>   char string[80];<br>   printf("Input a string:");<br>   gets(string);<br>   printf("The string input was: %s\\n",<br>   string);<br>   return 0;<br>}\n
gettext	<font color=blue>功  能</font>: 将文本方式屏幕上的文本拷贝到存储区<br><font color=blue>用  法</font>: int gettext(int left, int top, int right, int  bottom, void *destin);<br><font color=blue>程序例</font>:<br>#include < conio.h ><br>char buffer[4096];<br>int main(void)<br>{<br>   int i;<br>   clrscr();<br>   for (i = 0; i < = 20; i++)<br>      cprintf("Line #%d\\r\\n", i);<br>   gettext(1, 1, 80, 25, buffer);<br>   gotoxy(1, 25);<br>   cprintf("Press any key to clear screen...");<br>   getch();<br>   clrscr();<br>   gotoxy(1, 25);<br>   cprintf("Press any key to restore screen...");<br>   getch();<br>   puttext(1, 1, 80, 25, buffer);<br>   gotoxy(1, 25);<br>   cprintf("Press any key to quit...");<br>   getch();<br>   return 0;<br>}\n
gettextinfo	<font color=blue>功  能</font>: 取得文本模式的显示信息<br><font color=blue>用  法</font>: void gettextinfo(struct text_info *inforec);<br><font color=blue>程序例</font>:<br>#include < conio.h ><br>int main(void)<br>{<br>   struct text_info ti;<br>   gettextinfo(&ti);<br>   cprintf("window left      %2d\\r\\n",ti.winleft);<br>   cprintf("window top       %2d\\r\\n",ti.wintop);<br>   cprintf("window right     %2d\\r\\n",ti.winright);<br>   cprintf("window bottom    %2d\\r\\n",ti.winbottom);<br>   cprintf("attribute        %2d\\r\\n",ti.attribute);<br>   cprintf("normal attribute %2d\\r\\n",ti.normattr);<br>   cprintf("current mode     %2d\\r\\n",ti.currmode);<br>   cprintf("screen height    %2d\\r\\n",ti.screenheight);<br>   cprintf("screen width     %2d\\r\\n",ti.screenwidth);<br>   cprintf("current x        %2d\\r\\n",ti.curx);<br>   cprintf("current y        %2d\\r\\n",ti.cury);<br>   return 0;<br>}\n
gettextsettings	<font color=blue>功  能</font>: 返回有关当前图形文本字体的信息<br><font color=blue>用  法</font>: void far gettextsettings(struct textsettingstype far *textinfo);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>/* the names of the fonts supported */<br>char *font[] = { "DEFAULT_FONT",<br>                 "TRIPLEX_FONT",<br>                 "SMALL_FONT",<br>                 "SANS_SERIF_FONT",<br>                 "GOTHIC_FONT"<br>               };<br>/* the names of the text directions supported */<br>char *dir[] = { "HORIZ_DIR", "VERT_DIR" };<br>/* horizontal text justifications supported */<br>char *hjust[] = { "LEFT_TEXT", "CENTER_TEXT", "RIGHT_TEXT" };<br>/* vertical text justifications supported */<br>char *vjust[] = { "BOTTOM_TEXT", "CENTER_TEXT", "TOP_TEXT" };<br>int main(void)<br>{<br>   /* request auto detection */<br>   int gdriver = DETECT, gmode, errorcode;<br>   struct textsettingstype textinfo;<br>   int midx, midy, ht;<br>   char fontstr[80], dirstr[80], sizestr[80];<br>   char hjuststr[80], vjuststr[80];<br>   /* initialize graphics and local variables */<br>   initgraph(&gdriver, &gmode, "");<br>   /* read result of initialization */<br>   errorcode = graphresult();<br>   if (errorcode != grOk)  /* an error occurred */<br>   {<br>      printf("Graphics error: %s\\n", grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>      exit(1); /* terminate with an error code */<br>   }<br>   midx = getmaxx() / 2;<br>   midy = getmaxy() / 2;<br>   /* get information about current text settings */<br>   gettextsettings(&textinfo);<br>   /* convert text information into strings */<br>   sprintf(fontstr, "%s is the text style.", font[textinfo.font]);<br>   sprintf(dirstr, "%s is the text direction.", dir[textinfo.direction]);<br>   sprintf(sizestr, "%d is the text size.", textinfo.charsize);<br>   sprintf(hjuststr, "%s is the horizontal justification.",<br>           hjust[textinfo.horiz]);<br>   sprintf(vjuststr, "%s is the vertical justification.",<br>           vjust[textinfo.vert]);<br>   /* display the information */<br>   ht = textheight("W");<br>   settextjustify(CENTER_TEXT, CENTER_TEXT);<br>   outtextxy(midx, midy, fontstr);<br>   outtextxy(midx, midy+2*ht, dirstr);<br>   outtextxy(midx, midy+4*ht, sizestr);<br>   outtextxy(midx, midy+6*ht, hjuststr);<br>   outtextxy(midx, midy+8*ht, vjuststr);<br>   /* clean up */<br>   getch();<br>   closegraph();<br>   return 0;<br>}<br> <br>\n
gettime	<font color=blue>功  能</font>: 取得系统时间<br><font color=blue>用  法</font>: void gettime(struct time *timep);<br><font color=blue>程序例</font>:<br>#include   < stdio.h ><br>#include   < dos.h ><br>int main(void)<br>{<br>   struct  time t;<br>   gettime(&t);<br>   printf("The current time is: %2d:%02d:%02d.%02d\\n",<br>          t.ti_hour, t.ti_min, t.ti_sec, t.ti_hund);<br>   return 0;<br>}</>\n
getvect	<font color=blue>功  能</font>: 取得中断向量入口<br><font color=blue>用  法</font>: void interrupt(*getvect(int intr_num));<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < dos.h ><br>void interrupt get_out(); /* interrupt prototype */<br>void interrupt (*oldfunc)(); /* interrupt function pointer */<br>int looping = 1;<br>int main(void)<br>{<br>  puts("Press < Shift >< Prt Sc > to terminate");<br>  /* save the old interrupt */<br>  oldfunc  = getvect(5);<br>   /* install interrupt handler */<br>  setvect(5,get_out);<br>   /* do nothing */<br>  while (looping);<br>   /* restore to original interrupt routine */<br>   setvect(5,oldfunc);<br>  puts("Success");<br>  return 0;<br>}<br>void interrupt get_out()<br>{<br>  looping = 0; /* change global variable to get out of loop */<br>}\n
getverify	<font color=blue>功  能</font>: 返回DOS校验标志状态<br><font color=blue>用  法</font>: int getverify(void);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < dos.h ><br>int main(void)<br>{<br>   if (getverify())<br>      printf("DOS verify flag is on\\n");<br>   else<br>      printf("DOS verify flag is off\\n");<br>   return 0;<br>}<br> <br>\n
getviewsetting	<font color=blue>功  能</font>: 返回有关当前视区的信息<br><font color=blue>用  法</font>: void far getviewsettings(struct viewporttype far *viewport);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>char *clip[] = { "OFF", "ON" };<br>int main(void)<br>{<br>   /* request auto detection */<br>   int gdriver = DETECT, gmode, errorcode;<br>   struct viewporttype viewinfo;<br>   int midx, midy, ht;<br>   char topstr[80], botstr[80], clipstr[80];<br>   /* initialize graphics and local variables */<br>   initgraph(&gdriver, &gmode, "");<br>   /* read result of initialization */<br>   errorcode = graphresult();<br>   if (errorcode != grOk)  /* an error occurred */<br>   {<br>      printf("Graphics error: %s\\n", grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>      exit(1); /* terminate with an error code */<br>   }<br>   midx = getmaxx() / 2;<br>   midy = getmaxy() / 2;<br>   /* get information about current viewport */<br>   getviewsettings(&viewinfo);<br>   /* convert text information into strings */<br>   sprintf(topstr, "(%d, %d) is the upper left viewport corner.",<br>           viewinfo.left, viewinfo.top);<br>   sprintf(botstr, "(%d, %d) is the lower right viewport corner.",<br>           viewinfo.right, viewinfo.bottom);<br>   sprintf(clipstr, "Clipping is turned %s.", clip[viewinfo.clip]);<br>   /* display the information */<br>   settextjustify(CENTER_TEXT, CENTER_TEXT);<br>   ht = textheight("W");<br>   outtextxy(midx, midy, topstr);<br>   outtextxy(midx, midy+2*ht, botstr);<br>   outtextxy(midx, midy+4*ht, clipstr);<br>   /* clean up */<br>   getch();<br>   closegraph();<br>   return 0;<br>}\n
getw	<font color=blue>功  能</font>: 从流中取一整数<br><font color=blue>用  法</font>: int getw(FILE *strem);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < stdlib.h ><br>#define FNAME "test.$$$"<br>int main(void)<br>{<br>   FILE *fp;<br>   int word;<br>   /* place the word in a file */<br>   fp = fopen(FNAME, "wb");<br>   if (fp == NULL)<br>   {<br>      printf("Error opening file %s\\n", FNAME);<br>      exit(1);<br>   }<br>   word = 94;<br>   putw(word,fp);<br>   if (ferror(fp))<br>       printf("Error writing to file\\n");<br>   else<br>       printf("Successful write\\n");<br>   fclose(fp);<br>   /* reopen the file */<br>   fp = fopen(FNAME, "rb");<br>   if (fp == NULL)<br>   {<br>      printf("Error opening file %s\\n", FNAME);<br>      exit(1);<br>   }<br>   /* extract the word */<br>   word = getw(fp);<br>   if (ferror(fp))<br>       printf("Error reading file\\n");<br>   else<br>       printf("Successful read: word = %d\\n", word);<br>   /* clean up */<br>   fclose(fp);<br>   unlink(FNAME);<br>   return 0;<br>}</>\n
getx	<font color=blue>功  能</font>: 返回当前图形位置的x坐标<br><font color=blue>用  法</font>: int far getx(void);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>int main(void)<br>{<br>   /* request auto detection */<br>   int gdriver = DETECT, gmode, errorcode;<br>   char msg[80];<br>   /* initialize graphics and local variables */<br>   initgraph(&gdriver, &gmode, "");<br>   /* read result of initialization */<br>   errorcode = graphresult();<br>   if (errorcode != grOk)  /* an error occurred */<br>   {<br>      printf("Graphics error: %s\\n", grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>      exit(1); /* terminate with an error code */<br>   }<br>   /* move to the screen center point */<br>   moveto(getmaxx() / 2, getmaxy() / 2);<br>   /* create a message string */<br>   sprintf(msg, "< -(%d, %d) is the here.", getx(), gety());<br>   /* display the message */<br>   outtext(msg);<br>   /* clean up */<br>   getch();<br>   closegraph();<br>   return 0;<br>}\n
gety	<font color=blue>功  能</font>: 返回当前图形位置的y坐标<br><font color=blue>用  法</font>: int far gety(void);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>int main(void)<br>{<br>   /* request auto detection */<br>   int gdriver = DETECT, gmode, errorcode;<br>   char msg[80];<br>   /* initialize graphics and local variables */<br>   initgraph(&gdriver, &gmode, "");<br>   /* read result of initialization */<br>   errorcode = graphresult();<br>   if (errorcode != grOk)  /* an error occurred */<br>   {<br>      printf("Graphics error: %s\\n", grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>      exit(1); /* terminate with an error code */<br>   }<br>   /* move to the screen center point */<br>   moveto(getmaxx() / 2, getmaxy() / 2);<br>   /* create a message string */<br>   sprintf(msg, "< -(%d, %d) is the here.", getx(), gety());<br>   /* display the message */<br>   outtext(msg);<br>   /* clean up */<br>   getch();<br>   closegraph();<br>   return 0;<br>}\n
gmtime	<font color=blue>功  能</font>: 把日期和时间转换为格林尼治标准时间(GMT)<br><font color=blue>用  法</font>: struct tm *gmtime(long *clock);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < stdlib.h ><br>#include < time.h ><br>#include < dos.h ><br>/* Pacific Standard Time & Daylight Savings */<br>char *tzstr = "TZ=PST8PDT";<br>int main(void)<br>{<br>   time_t t;<br>   struct tm *gmt, *area;<br>   putenv(tzstr);<br>   tzset();<br>   t = time(NULL);<br>   area = localtime(&t);<br>   printf("Local time is: %s", asctime(area));<br>   gmt = gmtime(&t);<br>   printf("GMT is:        %s", asctime(gmt));<br>   return 0;<br>}\n
gotoxy	<font color=blue>功  能</font>: 在文本窗口中设置光标<br><font color=blue>用  法</font>: void gotoxy(int x, int y);<br><font color=blue>程序例</font>:<br>#include < conio.h ><br>int main(void)<br>{<br>   clrscr();<br>   gotoxy(35, 12);<br>   cprintf("Hello world");<br>   getch();<br>   return 0;<br>}\n
graphdefaults	<font color=blue>功  能</font>: 将所有图形设置复位为它们的缺省值<br><font color=blue>用  法</font>: void far graphdefaults(void);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>int main(void)<br>{<br>   /* request auto detection */<br>   int gdriver = DETECT, gmode, errorcode;<br>   int maxx, maxy;<br>   /* initialize graphics and local variables */<br>   initgraph(&gdriver, &gmode, "c:\\\\bor\\\\Borland\\\\bgi");<br>   /* read result of initialization */<br>   errorcode = graphresult();<br>   if (errorcode != grOk)  /* an error occurred */<br>   {<br>      printf("Graphics error: %s\\n", grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>      exit(1); /* terminate with an error code */<br>   }<br>   maxx = getmaxx();<br>   maxy = getmaxy();<br>   /* output line with non-default settings */<br>   setlinestyle(DOTTED_LINE, 0, 3);<br>   line(0, 0, maxx, maxy);<br>   outtextxy(maxx/2, maxy/3, "Before default values are restored.");<br>   getch();<br>   /* restore default values for everything */<br>   graphdefaults();<br>   /* clear the screen */<br>   cleardevice();<br>   /* output line with default settings */<br>   line(0, 0, maxx, maxy);<br>   outtextxy(maxx/2, maxy/3, "After restoring default values.");<br>   /* clean up */<br>   getch();<br>   closegraph();<br>   return 0;<br>}\n
grapherrormsg	<font color=blue>功  能</font>: 返回一个错误信息串的指针<br><font color=blue>用  法</font>: char *far grapherrormsg(int errorcode);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>#define NONSENSE -50<br>int main(void)<br>{<br>   /* FORCE AN ERROR TO OCCUR */<br>   int gdriver = NONSENSE, gmode, errorcode;<br>   /* initialize graphics mode */<br>   initgraph(&gdriver, &gmode, "");<br>   /* read result of initialization */<br>   errorcode = graphresult();<br>   /* if an error occurred, then output a */<br>   /* descriptive error message.          */<br>   if (errorcode != grOk)<br>   {<br>      printf("Graphics error: %s\\n", grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>      exit(1); /* terminate with an error code */<br>   }<br>   /* draw a line */<br>   line(0, 0, getmaxx(), getmaxy());<br>   /* clean up */<br>   getch();<br>   closegraph();<br>   return 0;<br>}\n
graphfreemem	<font color=blue>功  能</font>: 用户可修改的图形存储区释放函数<br><font color=blue>用  法</font>: void far _graphfreemem(void far *ptr, unsigned size);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>#include < alloc.h ><br>int main(void)<br>{<br>       /* request auto detection */<br>       int gdriver = DETECT, gmode, errorcode;<br>       int midx, midy;<br>       /* clear the text screen */<br>       clrscr();<br>       printf("Press any key to initialize graphics mode:");<br>       getch();<br>       clrscr();<br>       /* initialize graphics and local variables */<br>   initgraph(&gdriver, &gmode, "");<br>       /* read result of initialization */<br>       errorcode = graphresult();<br>       if (errorcode != grOk)  /* an error occurred */<br>       {<br>          printf("Graphics error: %s\\n", grapherrormsg(errorcode));<br>          printf("Press any key to halt:");<br>          getch();<br>          exit(1); /* terminate with an error code */<br>       }<br>       midx = getmaxx() / 2;<br>       midy = getmaxy() / 2;<br>       /* display a message */<br>       settextjustify(CENTER_TEXT, CENTER_TEXT);<br>       outtextxy(midx, midy, "Press any key to exit graphics mode:");<br>       /* clean up */<br>       getch();<br>       closegraph();<br>       return 0;<br>}<br>/* called by the graphics kernel to allocate memory */<br>void far * far _graphgetmem(unsigned size)<br>{<br>       printf("_graphgetmem called to allocate %d bytes.\\n", size);<br>       printf("hit any key:");<br>       getch();<br>       printf("\\n");<br>       /* allocate memory from far heap */<br>       return farmalloc(size);<br>}<br>/* called by the graphics kernel to free memory */<br>void far _graphfreemem(void far *ptr, unsigned size)<br>{<br>       printf("_graphfreemem called to free %d bytes.\\n", size);<br>       printf("hit any key:");<br>       getch();<br>       printf("\\n");<br>      /* free ptr from far heap */<br>      farfree(ptr);<br>}<br> <br>\n
graphgetmem	<font color=blue>功  能</font>: 用户可修改的图形存储区分配函数<br><font color=blue>用  法</font>: void far *far _graphgetmem(unsigned size);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>#include < alloc.h ><br>int main(void)<br>{<br>   /* request autodetection */<br>   int gdriver = DETECT, gmode, errorcode;<br>   int midx, midy;<br>   /* clear the text screen */<br>   clrscr();<br>   printf("Press any key to initialize graphics mode:");<br>   getch();<br>   clrscr();<br>   /* initialize graphics and local variables */<br>   initgraph(&gdriver, &gmode, "");<br>   /* read result of initialization */<br>   errorcode = graphresult();<br>   if (errorcode != grOk)      /* an error occurred */<br>   {<br>      printf("Graphics error: %s\\n", grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>      exit(1);                 /* terminate with an error code */<br>   }<br>   midx = getmaxx() / 2;<br>   midy = getmaxy() / 2;<br>   /* display a message */<br>   settextjustify(CENTER_TEXT, CENTER_TEXT);<br>   outtextxy(midx, midy, "Press any key to exit graphics mode:");<br>   /* clean up */<br>   getch();<br>   closegraph();<br>   return 0;<br>}<br>/* called by the graphics kernel to allocate memory */<br>void far * far _graphgetmem(unsigned size)<br>{<br>   printf("_graphgetmem called to allocate %d bytes.\\n", size);<br>   printf("hit any key:");<br>   getch();<br>   printf("\\n");<br>   /* allocate memory from far heap */<br>   return farmalloc(size);<br>}<br>/* called by the graphics kernel to free memory */<br>void far _graphfreemem(void far *ptr, unsigned size)<br>{<br>   printf("_graphfreemem called to free %d bytes.\\n", size);<br>   printf("hit any key:");<br>   getch();<br>   printf("\\n");<br>   /* free ptr from far heap */<br>   farfree(ptr);<br>}<br>  <br>\n
graphresult	<font color=blue>功  能</font>: 返回最后一次不成功的图形操作的错误代码<br><font color=blue>用  法</font>: int far graphresult(void);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>int main(void)<br>{<br>   /* request auto detection */<br>   int gdriver = DETECT, gmode, errorcode;<br>   /* initialize graphics and local variables */<br>   initgraph(&gdriver, &gmode, "");<br>   /* read result of initialization */<br>   errorcode = graphresult();<br>   if (errorcode != grOk)  /* an error occurred */<br>   {<br>      printf("Graphics error: %s\\n", grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>      exit(1); /* terminate with an error code */<br>   }<br>   /* draw a line */<br>   line(0, 0, getmaxx(), getmaxy());<br>   /* clean up */<br>   getch();<br>   closegraph();<br>   return 0;<br>}<br> <br>\n
harderr	<font color=blue>功  能</font>: 建立一个硬件错误处理程序<br><font color=blue>用  法</font>: void harderr(int (*fptr)());<br><font color=blue>程序例</font>:<br>/*This program will trap disk errors and prompt<br>the user for action. Try running it with no<br>disk in drive A: to invoke its functions.*/<br>#include < stdio.h ><br>#include < conio.h ><br>#include < dos.h ><br>#define IGNORE  0<br>#define RETRY   1<br>#define ABORT   2<br>int buf[500];<br>/*define the error messages for trapping disk problems*/<br>static char *err_msg[] = {<br>    "write protect",<br>    "unknown unit",<br>    "drive not ready",<br>    "unknown command",<br>    "data error (CRC)",<br>    "bad request",<br>    "seek error",<br>    "unknown media type",<br>    "sector not found",<br>    "printer out of paper",<br>    "write fault",<br>    "read fault",<br>    "general failure",<br>    "reserved",<br>    "reserved",<br>    "invalid disk change"<br>};<br>error_win(char *msg)<br>{<br>   int retval;<br>   cputs(msg);<br>/*prompt for user to press a key to abort, retry, ignore*/<br>   while(1)<br>   {<br>       retval= getch();<br>       if (retval == 'a' || retval == 'A')<br>       {<br>    retval = ABORT;<br>    break;<br>       }<br>       if (retval == 'r' || retval == 'R')<br>       {<br>    retval = RETRY;<br>    break;<br>       }<br>       if (retval == 'i' || retval == 'I')<br>       {<br>           retval = IGNORE;<br>           break;<br>       }<br>   }<br>   return(retval);<br>}<br>/*pragma warn -par reduces warnings which occur<br>due to the non use of the parameters errval,<br>bp and si to the handler.*/<br>#pragma warn -par<br>int handler(int errval,int ax,int bp,int si)<br>{<br>   static char msg[80];<br>   unsigned di;<br>   int drive;<br>   int errorno;<br>   di= _DI;<br>/*if this is not a disk error then it was<br>another device having trouble*/<br>   if (ax < 0)<br>   {<br>      /* report the error */<br>      error_win("Device error");<br>      /* and return to the program directly requesting abort */<br>      hardretn(ABORT);<br>   }<br>/* otherwise it was a disk error */<br>   drive = ax & 0x00FF;<br>   errorno = di & 0x00FF;<br>/* report which error it was */<br>   sprintf(msg, "Error: %s on drive %c\\r\\nA)bort, R)etry, I)gnore: ",<br>    err_msg[errorno], 'A' + drive);<br>/<br>*return to the program via dos interrupt 0x23 with abort, retry,<br>or ignore as input by the user.<br>*/<br>   hardresume(error_win(msg));<br>   return ABORT;<br>}<br>#pragma warn +par<br>int main(void)<br>{<br>/<br>*install our handler on the hardware problem interrupt<br>*/<br>   harderr(handler);<br>   clrscr();<br>   printf("Make sure there is no disk in drive A:\\n");<br>   printf("Press any key ....\\n");<br>   getch();<br>   printf("Trying to access drive A:\\n");<br>   printf("fopen returned %p\\n",fopen("A:temp.dat", "w"));<br>   return 0;<br>}\n
hardresume	<font color=blue>功  能</font>: 硬件错误处理函数<br><font color=blue>用  法</font>: void hardresume(int rescode);<br><font color=blue>程序例</font>:<br> <br>/* This program will trap disk errors and prompt the user for action. */<br>/* Try running it with no disk in drive A: to invoke its functions    */<br>#include < stdio.h ><br>#include < conio.h ><br>#include < dos.h ><br>#define IGNORE  0<br>#define RETRY   1<br>#define ABORT   2<br>int buf[500];<br>/* define the error messages for trapping disk problems */<br>static char *err_msg[] = {<br>    "write protect",<br>    "unknown unit",<br>    "drive not ready",<br>    "unknown command",<br>    "data error (CRC)",<br>    "bad request",<br>    "seek error",<br>    "unknown media type",<br>    "sector not found",<br>    "printer out of paper",<br>    "write fault",<br>    "read fault",<br>    "general failure",<br>    "reserved",<br>    "reserved",<br>    "invalid disk change"<br>};<br>error_win(char *msg)<br>{<br>   int retval;<br>   cputs(msg);<br>/* prompt for user to press a key to abort, retry, ignore */<br>   while(1)<br>   {<br>       retval= getch();<br>       if (retval == 'a' || retval == 'A')<br>       {<br>           retval = ABORT;<br>           break;<br>       }<br>       if (retval == 'r' || retval == 'R')<br>       {<br>           retval = RETRY;<br>           break;<br>       }<br>       if (retval == 'i' || retval == 'I')<br>       {<br>           retval = IGNORE;<br>           break;<br>       }<br>   }<br>   return(retval);<br>}<br>/* pragma warn -par reduces warnings which occur due to the non use */<br>/* of the parameters errval, bp and si to the handler.              */<br>#pragma warn -par<br>int handler(int errval,int ax,int bp,int si)<br>{<br>   static char msg[80];<br>   unsigned di;<br>   int drive;<br>   int errorno;<br>   di= _DI;<br>/* if this is not a disk error then it was another device having trouble */<br>   if (ax < 0)<br>   {<br>      /* report the error */<br>      error_win("Device error");<br>      /* and return to the program directly<br>      requesting abort */<br>      hardretn(ABORT);<br>   }<br>/* otherwise it was a disk error */<br>   drive = ax & 0x00FF;<br>   errorno = di & 0x00FF;<br>/* report which error it was */<br>   sprintf(msg, "Error: %s on drive %c\\r\\nA)bort, R)etry, I)gnore: ",<br>           err_msg[errorno], 'A' + drive);<br>/* return to the program via dos interrupt 0x23 with abort, retry */<br>/* or ignore as input by the user.  */<br>   hardresume(error_win(msg));<br>   return ABORT;<br>}<br>#pragma warn +par<br>int main(void)<br>{<br>/* install our handler on the hardware problem interrupt */<br>   harderr(handler);<br>   clrscr();<br>   printf("Make sure there is no disk in drive A:\\n");<br>   printf("Press any key ....\\n");<br>   getch();<br>   printf("Trying to access drive A:\\n");<br>   printf("fopen returned %p\\n",fopen("A:temp.dat", "w"));<br>   return 0;<br>}\n
highvideo	<font color=blue>功  能</font>: 选择高亮度文本字符<br><font color=blue>用  法</font>: void highvideo(void);<br><font color=blue>程序例</font>:<br>#include < conio.h ><br>int main(void)<br>{<br>   clrscr();<br>   lowvideo();<br>   cprintf("Low Intensity text\\r\\n");<br>   highvideo();<br>   gotoxy(1,2);<br>   cprintf("High Intensity Text\\r\\n");<br>   return 0;<br>}\n
hypot	<font color=blue>功  能</font>: 计算直角三角形的斜边长<br><font color=blue>用  法</font>: double hypot(double x, double y);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < math.h ><br>int main(void)<br>{<br>   double result;<br>   double x = 3.0;<br>   double y = 4.0;<br>   result = hypot(x, y);<br>   printf("The hypotenuse is: %lf\\n", result);<br>   return 0;<br>}<br>\n
imagesize	<font color=blue>功  能</font>: 返回保存位图像所需的字节数<br><font color=blue>用  法</font>: unsigned far imagesize(int left, int top, int right, int bottom);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>#define ARROW_SIZE 10<br>void draw_arrow(int x, int y);<br>int main(void)<br>{<br>   /* request autodetection */<br>   int gdriver = DETECT, gmode, errorcode;<br>   void *arrow;<br>   int x, y, maxx;<br>   unsigned int size;<br>   /* initialize graphics and local variables */<br>   initgraph(&gdriver, &gmode, "");<br>   /* read result of initialization */<br>   errorcode = graphresult();<br>   if (errorcode != grOk)  /* an error occurred */<br>   {<br>      printf("Graphics error: %s\\n", grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>      exit(1); /* terminate with an error code */<br>   }<br>   maxx = getmaxx();<br>   x = 0;<br>   y = getmaxy() / 2;<br>   /* draw the image to be grabbed */<br>   draw_arrow(x, y);<br>   /* calculate the size of the image */<br>   size = imagesize(x, y-ARROW_SIZE, x+(4*ARROW_SIZE), y+ARROW_SIZE);<br>   /* allocate memory to hold the image */<br>   arrow = malloc(size);<br>   /* grab the image */<br>   getimage(x, y-ARROW_SIZE, x+(4*ARROW_SIZE), y+ARROW_SIZE, arrow);<br>   /* repeat until a key is pressed */<br>   while (!kbhit())<br>   {<br>      /* erase old image */<br>      putimage(x, y-ARROW_SIZE, arrow, XOR_PUT);<br>      x += ARROW_SIZE;<br>      if (x >= maxx)<br>          x = 0;<br>      /* plot new image */<br>      putimage(x, y-ARROW_SIZE, arrow, XOR_PUT);<br>   }<br>   /* clean up */<br>   free(arrow);<br>   closegraph();<br>   return 0;<br>}<br>void draw_arrow(int x, int y)<br>{<br>   /* draw an arrow on the screen */<br>   moveto(x, y);<br>   linerel(4*ARROW_SIZE, 0);<br>   linerel(-2*ARROW_SIZE, -1*ARROW_SIZE);<br>   linerel(0, 2*ARROW_SIZE);<br>   linerel(2*ARROW_SIZE, -1*ARROW_SIZE);<br>}</>\n
initgraph	<font color=blue>功  能</font>: 初始化图形系统<br><font color=blue>用  法</font>: void far initgraph(int far *graphdriver, int far *graphmode,<br>    char far *pathtodriver);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>int main(void)<br>{<br>   /* request auto detection */<br>   int gdriver = DETECT, gmode, errorcode;<br>   /* initialize graphics mode */<br>   initgraph(&gdriver, &gmode, "");<br>   /* read result of initialization */<br>   errorcode = graphresult();<br>   if (errorcode != grOk)  /* an error occurred */<br>   {<br>      printf("Graphics error: %s\\n", grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>      exit(1);             /* return with error code */<br>   }<br>   /* draw a line */<br>   line(0, 0, getmaxx(), getmaxy());<br>   /* clean up */<br>   getch();<br>   closegraph();<br>   return 0;<br>}\n
inport	<font color=blue>功  能</font>: 从硬件端口中输入<br><font color=blue>用  法</font>: int inp(int protid);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < dos.h ><br>int main(void)<br>{<br>   int result;<br>   int port = 0;  /* serial port 0 */<br>   result = inport(port);<br>   printf("Word read from port %d = 0x%X\\n", port, result);<br>   return 0;<br>}\n
insline	<font color=blue>功  能</font>: 在文本窗口中插入一个空行<br><font color=blue>用  法</font>: void insline(void);<br><font color=blue>程序例</font>:<br>#include < conio.h ><br>int main(void)<br>{<br>   clrscr();<br>   cprintf("INSLINE inserts an empty line in the text window\\r\\n");<br>   cprintf("at the cursor position using the current text\\r\\n");<br>   cprintf("background color.  All lines below the empty one\\r\\n");<br>   cprintf("move down one line and the bottom line scrolls\\r\\n");<br>   cprintf("off the bottom of the window.\\r\\n");<br>   cprintf("\\r\\nPress any key to continue:");<br>   gotoxy(1, 3);<br>   getch();<br>   insline();<br>   getch();<br>   return 0;<br>}</>\n
installuserdriver	<font color=blue>功  能</font>: 安装设备驱动程序到BGI设备驱动程序表中<br><font color=blue>用  法</font>: int far installuserdriver(char far *name, int (*detect)(void));<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>/* function prototypes */<br>int huge detectEGA(void);<br>void checkerrors(void);<br>int main(void)<br>{<br>   int gdriver, gmode;<br>   /* install a user written device driver */<br>   gdriver = installuserdriver("EGA", detectEGA);<br>   /* must force use of detection routine */<br>   gdriver = DETECT;<br>   /* check for any installation errors */<br>   checkerrors();<br>   /* initialize graphics and local variables */<br>   initgraph(&gdriver, &gmode, "");<br>   /* check for any initialization errors */<br>   checkerrors();<br>   /* draw a line */<br>   line(0, 0, getmaxx(), getmaxy());<br>   /* clean up */<br>   getch();<br>   closegraph();<br>   return 0;<br>}<br>/* detects EGA or VGA cards */<br>int huge detectEGA(void)<br>{<br>   int driver, mode, sugmode = 0;<br>   detectgraph(&driver, &mode);<br>   if ((driver == EGA) || (driver == VGA))<br>      /* return suggested video mode number */<br>      return sugmode;<br>   else<br>      /* return an error code */<br>      return grError;<br>}<br>/* check for and report any graphics errors */<br>void checkerrors(void)<br>{<br>   int errorcode;<br>   /* read result of last graphics operation */<br>   errorcode = graphresult();<br>   if (errorcode != grOk)<br>   {<br>      printf("Graphics error: %s\\n", grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>      exit(1);<br>   }<br>}<br>\n
installuserfont	<font color=blue>功  能</font>: 安装未嵌入BGI系统的字体文件(CHR)<br><font color=blue>用  法</font>: int far installuserfont(char far *name);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>/* function prototype */<br>void checkerrors(void);<br>int main(void)<br>{<br>   /* request auto detection */<br>   int gdriver = DETECT, gmode;<br>   int userfont;<br>   int midx, midy;<br>   /* initialize graphics and local variables */<br>   initgraph(&gdriver, &gmode, "");<br>   midx = getmaxx() / 2;<br>   midy = getmaxy() / 2;<br>   /* check for any initialization errors */<br>   checkerrors();<br>   /* install a user defined font file */<br>   userfont = installuserfont("USER.CHR");<br>   /* check for any installation errors */<br>   checkerrors();<br>   /* select the user font */<br>   settextstyle(userfont, HORIZ_DIR, 4);<br>   /* output some text */<br>   outtextxy(midx, midy, "Testing!");<br>   /* clean up */<br>   getch();<br>   closegraph();<br>   return 0;<br>}<br>/* check for and report any graphics errors */<br>void checkerrors(void)<br>{<br>   int errorcode;<br>   /* read result of last graphics operation */<br>   errorcode = graphresult();<br>   if (errorcode != grOk)<br>   {<br>      printf("Graphics error: %s\\n", grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>      exit(1);<br>   }<br> }</>\n
int86	<font color=blue>功  能</font>: 通用8086软中断接口<br><font color=blue>用  法</font>: int int86(int intr_num, union REGS *inregs, union REGS *outregs);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < conio.h ><br>#include < dos.h ><br>#define VIDEO 0x10<br>void movetoxy(int x, int y)<br>{<br>   union REGS regs;<br>   regs.h.ah = 2;  /* set cursor postion */<br>   regs.h.dh = y;<br>   regs.h.dl = x;<br>   regs.h.bh = 0;  /* video page 0 */<br>   int86(VIDEO, &regs, &regs);<br>}<br>int main(void)<br>{<br>   clrscr();<br>   movetoxy(35, 10);<br>   printf("Hello\\n");<br>   return 0;<br>}\n
int86x	<font color=blue>功  能</font>: 通用8086软中断接口<br><font color=blue>用  法</font>: int int86x(int intr_num, union REGS *insegs, union REGS *outregs,<br>     struct SREGS *segregs);<br><font color=blue>程序例</font>:<br>#include < dos.h ><br>#include < process.h ><br>#include < stdio.h ><br>int main(void)<br>{<br>   char filename[80];<br>   union REGS inregs, outregs;<br>   struct SREGS segregs;<br>   printf("Enter filename: ");<br>   gets(filename);<br>   inregs.h.ah = 0x43;<br>   inregs.h.al = 0x21;<br>   inregs.x.dx = FP_OFF(filename);<br>   segregs.ds = FP_SEG(filename);<br>   int86x(0x21, &inregs, &outregs, &segregs);<br>   printf("File attribute: %X\\n", outregs.x.cx);<br>   return 0;<br>}</>\n
intdos	<font color=blue>功  能</font>: 通用DOS接口<br><font color=blue>用  法</font>: int intdos(union REGS *inregs, union REGS *outregs);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < dos.h ><br>/* deletes file name; returns 0 on success, nonzero on failure */<br>int delete_file(char near *filename)<br>{<br>   union REGS regs;<br>   int ret;<br>   regs.h.ah = 0x41;                            /* delete file */<br>   regs.x.dx = (unsigned) filename;<br>   ret = intdos(&regs, &regs);<br>   /* if carry flag is set, there was an error */<br>   return(regs.x.cflag ? ret : 0);<br>}<br>int main(void)<br>{<br>   int err;<br>   err = delete_file("NOTEXIST.$$$");<br>   if (!err)<br>      printf("Able to delete NOTEXIST.$$$\\n");<br>   else<br>      printf("Not Able to delete NOTEXIST.$$$\\n");<br>   return 0;<br>}</>\n
intdosx	<font color=blue>功  能</font>: 通用DOS中断接口<br><font color=blue>用  法</font>: int intdosx(union REGS *inregs, union REGS *outregs,<br>      struct SREGS *segregs);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < dos.h ><br>/* deletes file name; returns 0 on success, nonzero on failure */<br>int delete_file(char far *filename)<br>{<br>   union REGS regs; struct SREGS sregs;<br>   int ret;<br>   regs.h.ah = 0x41;                      /* delete file */<br>   regs.x.dx = FP_OFF(filename);<br>   sregs.ds = FP_SEG(filename);<br>   ret = intdosx(&regs, &regs, &sregs);<br>   /* if carry flag is set, there was an error */<br>   return(regs.x.cflag ? ret : 0);<br>}<br>int main(void)<br>{<br>   int err;<br>   err = delete_file("NOTEXIST.$$$");<br>   if (!err)<br>      printf("Able to delete NOTEXIST.$$$\\n");<br>   else<br>      printf("Not Able to delete NOTEXIST.$$$\\n");<br>   return 0;<br>}\n
intr	<font color=blue>功  能</font>: 改变软中断接口<br><font color=blue>用  法</font>: void intr(int intr_num, struct REGPACK *preg);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < string.h ><br>#include < dir.h ><br>#include < dos.h ><br>#define CF 1  /* Carry flag */<br>int main(void)<br>{<br>   char directory[80];<br>   struct REGPACK reg;<br>   printf("Enter directory to change to: ");<br>   gets(directory);<br>   reg.r_ax = 0x3B < < 8;         /* shift 3Bh into  AH */<br>   reg.r_dx = FP_OFF(directory);<br>   reg.r_ds = FP_SEG(directory);<br>   intr(0x21, &reg);<br>   if (reg.r_flags & CF)<br>      printf("Directory change failed\\n");<br>   getcwd(directory, 80);<br>   printf("The current directory is: %s\\n", directory);<br>   return 0;<br>}\n
ioctl	<font color=blue>功  能</font>: 控制I/O设备<br><font color=blue>用  法</font>: int ioctl(int handle, int cmd[,int *argdx, int argcx]);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < dir.h ><br>#include < io.h ><br>int main(void)<br>{<br>   int stat;<br>   /* use func 8 to determine if the default drive is removable */<br>   stat = ioctl(0, 8, 0, 0);<br>   if (!stat)<br>      printf("Drive %c is removable.\\n", getdisk() + 'A');<br>   else<br>      printf("Drive %c is not removable.\\n", getdisk() + 'A');<br>   return 0;<br>}</>\n
isatty	<font color=blue>功  能</font>: 检查设备类型<br><font color=blue>用  法</font>: int isatty(int handle);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < io.h ><br>int main(void)<br>{<br>   int handle;<br>   handle = fileno(stdprn);<br>   if (isatty(handle))<br>      printf("Handle %d is a device type\\n", handle);<br>   else<br>      printf("Handle %d isn't a device type\\n", handle);<br>   return 0;<br>}</>\n
itoa	<font color=blue>功  能</font>: 把一整数转换为字符串<br><font color=blue>用  法</font>: char *itoa(int value, char *string, int radix);<br><font color=blue>程序例</font>:<br>#include < stdlib.h ><br>#include < stdio.h ><br>int main(void)<br>{<br>   int number = 12345;<br>   char string[25];<br>   itoa(number, string, 10);<br>   printf("integer = %d string = %s\\n", number, string);<br>   return 0;<br>}<br>\n
kbhit	<font color=blue>功  能</font>: 检查当前按下的键<br><font color=blue>用  法</font>: int kbhit(void);<br><font color=blue>程序例</font>:<br>#include < conio.h ><br>int main(void)<br>{<br>   cprintf("Press any key to continue:");<br>   while (!kbhit()) /* do nothing */ ;<br>   cprintf("\\r\\nA key was pressed...\\r\\n");<br>   return 0;<br>}</>\n
keep	<font color=blue>功  能</font>: 退出并继续驻留<br><font color=blue>用  法</font>: void keep(int status, int size);<br><font color=blue>程序例</font>:<br>/***NOTE:<br>   This is an interrupt service routine.  You<br>   can NOT compile this program with Test<br>   Stack Overflow turned on and get an<br>   executable file which will operate<br>   correctly.  Due to the nature of this<br>   function the formula used to compute<br>   the number of paragraphs may not<br>   necessarily work in all cases.  Use with<br>   care!  Terminate Stay Resident (TSR)<br>   programs are complex and no other support<br>   for them is provided.  Refer to the<br>   MS-DOS technical documentation<br>   for more information.  */<br>#include < dos.h ><br>/* The clock tick interrupt */<br>#define INTR 0x1C<br>/* Screen attribute (blue on grey) */<br>#define ATTR 0x7900<br>/* reduce heaplength and stacklength<br>to make a smaller program in memory */<br>extern unsigned _heaplen = 1024;<br>extern unsigned _stklen  = 512;<br>void interrupt ( *oldhandler)(void);<br>void interrupt handler(void)<br>{<br>   unsigned int (far *screen)[80];<br>   static int count;<br>/* For a color screen the video memory<br>   is at B800:0000.  For a monochrome<br>   system use B000:000 */<br>   screen = MK_FP(0xB800,0);<br>/* increase the counter and keep it<br>   within 0 to 9 */<br>   count++;<br>   count %= 10;<br>/* put the number on the screen */<br>   screen[0][79] = count + '0' + ATTR;<br>/* call the old interrupt handler */<br>   oldhandler();<br>}<br>int main(void)<br>{<br>/* get the address of the current clock<br>   tick interrupt */<br>oldhandler = getvect(INTR);<br>/* install the new interrupt handler */<br>setvect(INTR, handler);<br>/* _psp is the starting address of the<br>   program in memory.  The top of the stack<br>   is the end of the program.  Using _SS and<br>   _SP together we can get the end of the<br>   stack.  You may want to allow a bit of<br>   saftey space to insure that enough room<br>   is being allocated ie:<br>   (_SS + ((_SP + safety space)/16) - _psp)<br>*/<br>keep(0, (_SS + (_SP/16) - _psp));<br>return 0;<br>}<br> <br> <br>\n
labs	<font color=blue>功  能</font>: 取长整型绝对值<br><font color=blue>用  法</font>: long labs(long n);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < math.h ><br>int main(void)<br>{<br>   long result;<br>   long x = -12345678L;<br>   result= labs(x);<br>   printf("number: %ld abs value: %ld\\n",<br>      x, result);<br>   return 0;<br>}</>\n
ldexp	<font color=blue>功  能</font>: 计算value*2的幂<br><font color=blue>用  法</font>: double ldexp(double value, int exp);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < math.h ><br>int main(void)<br>{<br>   double value;<br>   double x = 2;<br>   /* ldexp raises 2 by a power of 3<br>      then multiplies the result by 2   */<br>   value = ldexp(x,3);<br>   printf("The ldexp value is: %lf\\n",<br>      value);<br>   return 0;<br>}\n
ldiv	<font color=blue>功  能</font>: 两个长整型数相除, 返回商和余数<br><font color=blue>用  法</font>: ldiv_t ldiv(long lnumer, long ldenom);<br><font color=blue>程序例</font>:<br>/* ldiv example */<br>#include < stdlib.h ><br>#include < stdio.h ><br>int main(void)<br>{<br>   ldiv_t lx;<br>   lx = ldiv(100000L, 30000L);<br>   printf("100000 div 30000 = %ld remainder %ld\\n", lx.quot, lx.rem);<br>   return 0;<br>}</>\n
lfind	<font color=blue>功  能</font>: 执行线性搜索<br><font color=blue>用  法</font>: void *lfind(void *key, void *base, int *nelem, int width,<br>      int (*fcmp)());<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < stdlib.h ><br>int compare(int *x, int *y)<br>{<br>   return( *x - *y );<br>}<br>int main(void)<br>{<br>   int array[5] = {35, 87, 46, 99, 12};<br>   size_t nelem = 5;<br>   int key;<br>   int *result;<br>   key = 99;<br>   result = lfind(&key, array, &nelem,<br>        sizeof(int), (int(*)(const void *,const void *))compare);<br>   if (result)<br>      printf("Number %d found\\n",key);<br>   else<br>      printf("Number %d not found\\n",key);<br>   return 0;<br>}\n
line	<font color=blue>功  能</font>: 在指定两点间画一直线<br><font color=blue>用  法</font>: void far line(int x0, int y0, int x1, int y1);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>int main(void)<br>{<br>   /* request auto detection */<br>   int gdriver = DETECT, gmode, errorcode;<br>   int xmax, ymax;<br>   /* initialize graphics and local variables */<br>   initgraph(&gdriver, &gmode, "");<br>   /* read result of initialization */<br>   errorcode = graphresult();<br>   /* an error occurred */<br>   if (errorcode != grOk)<br>   {<br>      printf("Graphics error: %s\\n",<br>             grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>      exit(1);<br>   }<br>   setcolor(getmaxcolor());<br>   xmax = getmaxx();<br>   ymax = getmaxy();<br>   /* draw a diagonal line */<br>   line(0, 0, xmax, ymax);<br>   /* clean up */<br>   getch();<br>   closegraph();<br>   return 0;<br>}\n
linerel	<font color=blue>功  能</font>: 从当前位置点(CP)到与CP有一给定相对距离的点画一直线<br><font color=blue>用  法</font>: void far linerel(int dx, int dy);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>int main(void)<br>{<br>   /* request auto detection */<br>   int gdriver = DETECT, gmode, errorcode;<br>   char msg[80];<br>   /* initialize graphics and local variables */<br>   initgraph(&gdriver, &gmode, "");<br>   /* read result of initialization */<br>   errorcode = graphresult();<br>   if (errorcode != grOk)<br>   {<br>      printf("Graphics error: %s\\n",<br>  grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>      exit(1);<br>   }<br>   /* move the C.P. to location (20, 30) */<br>   moveto(20, 30);<br>   /* create and output a<br>      message at (20, 30) */<br>   sprintf(msg, " (%d, %d)", getx(), gety());<br>   outtextxy(20, 30, msg);<br>   /* draw a line to a point a relative<br>      distance away from the current<br>      value of C.P.   */<br>   linerel(100, 100);<br>   /* create and output a message at C.P. */<br>   sprintf(msg, " (%d, %d)", getx(), gety());<br>   outtext(msg);<br>   /* clean up */<br>   getch();<br>   closegraph();<br>   return 0;<br>}<br> <br>\n
localtime	<font color=blue>功  能</font>: 把日期和时间转变为结构<br><font color=blue>用  法</font>: struct tm *localtime(long *clock);<br><font color=blue>程序例</font>:<br>#include < time.h ><br>#include < stdio.h ><br>#include < dos.h ><br>int main(void)<br>{<br>   time_t timer;<br>   struct tm *tblock;<br>   /* gets time of day */<br>   timer = time(NULL);<br>   /* converts date/time to a structure */<br>   tblock = localtime(&timer);<br>   printf("Local time is: %s", asctime(tblock));<br>   return 0;<br>}</>\n
lock	<font color=blue>功  能</font>: 设置文件共享锁<br><font color=blue>用  法</font>: int lock(int handle, long offset, long length);<br><font color=blue>程序例</font>:<br>#include < io.h ><br>#include < fcntl.h ><br>#include < sys\\stat.h ><br>#include < process.h ><br>#include < share.h ><br>#include < stdio.h ><br>int main(void)<br>{<br>   int handle, status;<br>   long length;<br>   /* Must have DOS Share.exe loaded for */<br>   /* file locking to function properly */<br>   handle = sopen("c:\\\\autoexec.bat",<br>      O_RDONLY,SH_DENYNO,S_IREAD);<br>   if (handle < 0)<br>   {<br>      printf("sopen failed\\n");<br>      exit(1);<br>   }<br>   length = filelength(handle);<br>   status = lock(handle,0L,length/2);<br>   if (status == 0)<br>      printf("lock succeeded\\n");<br>   else<br>      printf("lock failed\\n");<br>   status = unlock(handle,0L,length/2);<br>   if (status == 0)<br>      printf("unlock succeeded\\n");<br>   else<br>      printf("unlock failed\\n");<br>   close(handle);<br>   return 0;<br>}\n
log	<font color=blue>功  能</font>: 对数函数ln(x)<br><font color=blue>用  法</font>: double log(double x);<br><font color=blue>程序例</font>:<br>#include < math.h ><br>#include < stdio.h ><br>int main(void)<br>{<br>   double result;<br>   double x = 8.6872;<br>   result = log(x);<br>   printf("The natural log of %lf is %lf\\n", x, result);<br>   return 0;<br>}\n
log10	<font color=blue>功  能</font>: 对数函数log<br><font color=blue>用  法</font>: double log10(double x);<br><font color=blue>程序例</font>:<br>#include < math.h ><br>#include < stdio.h ><br>int main(void)<br>{<br>   double result;<br>   double x = 800.6872;<br>   result = log10(x);<br>   printf("The common log of %lf is %lf\\n", x, result);<br>   return 0;<br>}</>\n
longjump	<font color=blue>功  能</font>: 执行非局部转移<br><font color=blue>用  法</font>: void longjump(jmp_buf env, int val);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < setjmp.h ><br>#include < stdlib.h ><br>void subroutine(jmp_buf);<br>int main(void)<br>{<br>   int value;<br>   jmp_buf jumper;<br>   value = setjmp(jumper);<br>   if (value != 0)<br>   {<br>      printf("Longjmp with value %d\\n", value);<br>      exit(value);<br>   }<br>   printf("About to call subroutine ... \\n");<br>   subroutine(jumper);<br>   return 0;<br>}<br>void subroutine(jmp_buf jumper)<br>{<br>   longjmp(jumper,1);<br>}</>\n
lowvideo	<font color=blue>功  能</font>: 选择低亮度字符<br><font color=blue>用  法</font>: void lowvideo(void);<br><font color=blue>程序例</font>:<br>#include < conio.h ><br>int main(void)<br>{<br>   clrscr();<br>   highvideo();<br>   cprintf("High Intesity Text\\r\\n");<br>   lowvideo();<br>   gotoxy(1,2);<br>   cprintf("Low Intensity Text\\r\\n");<br>   return 0;<br>}</>\n
lrotl	<font color=blue>功  能</font>: 将无符号长整型数向左循环移位<br><font color=blue>用  法</font>: unsigned long lrotl(unsigned long lvalue, int count);<br> unsigned long _lrotl(unsigned long lvalue, int count);<br><font color=blue>程序例</font>:<br>/* lrotl example */<br>#include < stdlib.h ><br>#include < stdio.h ><br>int main(void)<br>{<br>   unsigned long result;<br>   unsigned long value = 100;<br>   result = _lrotl(value,1);<br>   printf("The value %lu rotated left one bit is: %lu\\n", value, result);<br>   return 0;<br>}\n
lsearch	<font color=blue>功  能</font>: 线性搜索<br><font color=blue>用  法</font>: void *lsearch(const void *key, void *base, size_t *nelem,<br>       size_t width, int (*fcmp)(const void *, const void *));<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < stdlib.h ><br>int compare(int *x, int *y)<br>{<br>   return( *x - *y );<br>}<br>int main(void)<br>{<br>   int array[5] = {35, 87, 46, 99, 12};<br>   size_t nelem = 5;<br>   int key;<br>   int *result;<br>   key = 99;<br>   result = lfind(&key, array, &nelem,<br>               sizeof(int), (int(*)(const void *,const void *))compare);<br>   if (result)<br>      printf("Number %d found\\n",key);<br>   else<br>      printf("Number %d not found\\n",key);<br>   return 0;<br>}</>\n
lseek	<font color=blue>功  能</font>: 移动文件读/写指针<br><font color=blue>用  法</font>: long lseek(int handle, long offset, int fromwhere);<br><font color=blue>程序例</font>:<br>#include < sys\\stat.h ><br>#include < string.h ><br>#include < stdio.h ><br>#include < fcntl.h ><br>#include < io.h ><br>int main(void)<br>{<br>   int handle;<br>   char msg[] = "This is a test";<br>   char ch;<br>   /* create a file */<br>   handle = open("TEST.$$$", O_CREAT | O_RDWR, S_IREAD | S_IWRITE);<br>   /* write some data to the file */<br>   write(handle, msg, strlen(msg));<br>   /* seek to the begining of the file */<br>   lseek(handle, 0L, SEEK_SET);<br>   /* reads chars from the file until we hit EOF */<br>   do<br>   {<br>      read(handle, &ch, 1);<br>      printf("%c", ch);<br>   }  while (!eof(handle));<br>   close(handle);<br>   return 0;<br>}<br>\n
malloc	<font color=blue>功  能</font>: 内存分配函数<br><font color=blue>用  法</font>: void *malloc(unsigned size);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < string.h ><br>#include < alloc.h ><br>#include < process.h ><br>int main(void)<br>{<br>   char *str;<br>   /* allocate memory for string */<br>   /* This will generate an error when compiling */<br>   /* with C++, use the new operator instead. */<br>   if ((str = malloc(10)) == NULL)<br>   {<br>      printf("Not enough memory to allocate buffer\\n");<br>      exit(1);  /* terminate program if out of memory */<br>   }<br>   /* copy "Hello" into string */<br>   strcpy(str, "Hello");<br>   /* display string */<br>   printf("String is %s\\n", str);<br>   /* free memory */<br>   free(str);<br>   return 0;<br>}</>\n
matherr	<font color=blue>功  能</font>: 用户可修改的数学错误处理程序<br><font color=blue>用  法</font>: int matherr(struct exception *e);<br><font color=blue>程序例</font>:<br>/* This is a user-defined matherr function that prevents<br>   any error messages from being printed. */<br>#include< math.h ><br>int matherr(struct exception *a)<br>{<br>   return 1;<br>}</>\n
memccpy	<font color=blue>功  能</font>: 从源source中拷贝n个字节到目标destin中<br><font color=blue>用  法</font>: void *memccpy(void *destin, void *source, unsigned char ch,<br>       unsigned n);<br><font color=blue>程序例</font>:<br>#include < string.h ><br>#include < stdio.h ><br>int main(void)<br>{<br>   char *src = "This is the source string";<br>   char dest[50];<br>   char *ptr;<br>   ptr = memccpy(dest, src, 'c', strlen(src));<br>   if (ptr)<br>   {<br>      *ptr = '\\0';<br>      printf("The character was found:  %s\\n", dest);<br>   }<br>   else<br>      printf("The character wasn't found\\n");<br>   return 0;<br>}\n
memchr	<font color=blue>功  能</font>: 在数组的前n个字节中搜索字符<br><font color=blue>用  法</font>: void *memchr(void *s, char ch, unsigned n);<br><font color=blue>程序例</font>:<br>#include < string.h ><br>#include < stdio.h ><br>int main(void)<br>{<br>   char str[17];<br>   char *ptr;<br>   strcpy(str, "This is a string");<br>   ptr = memchr(str, 'r', strlen(str));<br>   if (ptr)<br>      printf("The character 'r' is at position: %d\\n", ptr - str);<br>   else<br>      printf("The character was not found\\n");<br>   return 0;<br>}<br> <br>\n
memcpy	<font color=blue>功  能</font>: 从源source中拷贝n个字节到目标destin中<br><font color=blue>用  法</font>: void *memcpy(void *destin, void *source, unsigned n);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < string.h ><br>int main(void)<br>{<br>   char src[] = "</></></>";<br>   char dest[] = "abcdefghijlkmnopqrstuvwxyz0123456709";<br>   char *ptr;<br>   printf("destination before memcpy: %s\\n", dest);<br>   ptr = memcpy(dest, src, strlen(src));<br>   if (ptr)<br>      printf("destination after memcpy:  %s\\n", dest);<br>   else<br>      printf("memcpy failed\\n");<br>   return 0;<br>}\n
memicmp	<font color=blue>功  能</font>: 比较两个串s1和s2的前n个字节, 忽略大小写<br><font color=blue>用  法</font>: int memicmp(void *s1, void *s2, unsigned n);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < string.h ><br>int main(void)<br>{<br>   char *buf1 = "ABCDE123";<br>   char *buf2 = "abcde456";<br>   int stat;<br>   stat = memicmp(buf1, buf2, 5);<br>   printf("The strings to position 5 are ");<br>   if (stat)<br>      printf("not ");<br>   printf("the same\\n");<br>   return 0;<br>}\n
memmove	<font color=blue>功  能</font>: 移动一块字节<br><font color=blue>用  法</font>: void *memmove(void *destin, void *source, unsigned n);<br><font color=blue>程序例</font>:<br>#include < string.h ><br>#include < stdio.h ><br>int main(void)<br>{<br>  char *dest = "abcdefghijklmnopqrstuvwxyz0123456789";<br>  char *src = "</></></>";<br>  printf("destination prior to memmove: %s\\n", dest);<br>  memmove(dest, src, 26);<br>  printf("destination after memmove:    %s\\n", dest);<br>  return 0;<br>}</>\n
memset	<font color=blue>功  能</font>: 设置s中的所有字节为ch, s数组的大小由n给定<br><font color=blue>用  法</font>: void *memset(void *s, char ch, unsigned n);<br><font color=blue>程序例</font>:<br>#include < string.h ><br>#include < stdio.h ><br>#include < mem.h ><br>int main(void)<br>{<br>   char buffer[] = "Hello world\\n";<br>   printf("Buffer before memset: %s\\n", buffer);<br>   memset(buffer, '*', strlen(buffer) - 1);<br>   printf("Buffer after memset:  %s\\n", buffer);<br>   return 0;<br>}\n
mkdir	<font color=blue>功  能</font>: 建立一个目录<br><font color=blue>用  法</font>: int mkdir(char *pathname);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < conio.h ><br>#include < process.h ><br>#include < dir.h ><br>int main(void)<br>{<br>  int status;<br>   clrscr();<br>   status = mkdir("asdfjklm");<br>   (!status) ? (printf("Directory created\\n")) :<br>               (printf("Unable to create directory\\n"));<br>   getch();<br>   system("dir");<br>   getch();<br>   status = rmdir("asdfjklm");<br>   (!status) ? (printf("Directory deleted\\n")) :<br>  (perror("Unable to delete directory"));<br>   return 0;<br>}</>\n
MK_FP	<font color=blue>功  能</font>: 设置一个远指针<br><font color=blue>用  法</font>: void far *MK_FP(unsigned seg, unsigned off);<br><font color=blue>程序例</font>:<br>#include < dos.h ><br>#include < graphics.h ><br>int main(void)<br>{<br>   int gd, gm, i;<br>   unsigned int far *screen;<br>   detectgraph(&gd, &gm);<br>   if (gd == HERCMONO)<br>       screen = MK_FP(0xB000, 0);<br>   else<br>       screen = MK_FP(0xB800, 0);<br>   for (i=0; i< 26; i++)<br>      screen[i] = 0x0700 + ('a' + i);<br>   return 0;<br>}\n
mktemp	<font color=blue>功  能</font>: 建立唯一的文件名<br><font color=blue>用  法</font>: char *mktemp(char *template);<br><font color=blue>程序例</font>:<br>#include < dir.h ><br>#include < stdio.h ><br>int main(void)<br>{<br>   /* fname defines the template for the<br>     temporary file.  */<br>   char *fname = "TXXXXXX", *ptr;<br>   ptr = mktemp(fname);<br>   printf("%s\\n",ptr);<br>   return 0;<br>}\n
modf	<font color=blue>功  能</font>: 把数分为指数和尾数<br><font color=blue>用  法</font>: double modf(double value, double *iptr);<br><font color=blue>程序例</font>:<br>#include < math.h ><br>#include < stdio.h ><br>int main(void)<br>{<br>   double fraction, integer;<br>   double number = 100000.567;<br>   fraction = modf(number, &integer);<br>   printf("The whole and fractional parts of %lf are %lf and %lf\\n",<br>          number, integer, fraction);<br>   return 0;<br>}\n
movedata	<font color=blue>功  能</font>: 拷贝字节<br><font color=blue>用  法</font>: void movedata(int segsrc, int offsrc, int segdest,<br>  int offdest, unsigned numbytes);<br><font color=blue>程序例</font>:<br>#include < mem.h ><br>#define MONO_BASE 0xB000<br>/* saves the contents of the monochrome screen in buffer */<br>void save_mono_screen(char near *buffer)<br>{<br>   movedata(MONO_BASE, 0, _DS, (unsigned)buffer, 80*25*2);<br>}<br>int main(void)<br>{<br>   char buf[80*25*2];<br>   save_mono_screen(buf);<br>}\n
movemem	<font color=blue>功  能</font>: 移动一块字节<br><font color=blue>用  法</font>: void movemem(void *source, void *destin, unsigned len);<br><font color=blue>程序例</font>:<br>#include < mem.h ><br>#include < alloc.h ><br>#include < stdio.h ><br>#include < string.h ><br>int main(void)<br>{<br>   char *source = "Borland International";<br>   char *destination;<br>   int length;<br>   length = strlen(source);<br>   destination = malloc(length + 1);<br>   movmem(source,destination,length);<br>   printf("%s\\n",destination);<br>   return 0;<br>}\n
moverel	<font color=blue>功  能</font>: 将当前位置(CP)移动一相对距离<br><font color=blue>用  法</font>: void far moverel(int dx, int dy);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>int main(void)<br>{<br>   /* request auto detection */<br>   int gdriver = DETECT, gmode, errorcode;<br>   char msg[80];<br>   /* initialize graphics and local variables */<br>   initgraph(&gdriver, &gmode, "");<br>   /* read result of initialization */<br>   errorcode = graphresult();<br>   if (errorcode != grOk)  /* an error occurred */<br>   {<br>      printf("Graphics error: %s\\n", grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>      exit(1); /* terminate with an error code */<br>   }<br>   /* move the C.P. to location (20, 30) */<br>   moveto(20, 30);<br>   /* plot a pixel at the C.P. */<br>   putpixel(getx(), gety(), getmaxcolor());<br>   /* create and output a message at (20, 30) */<br>   sprintf(msg, " (%d, %d)", getx(), gety());<br>   outtextxy(20, 30, msg);<br>   /* move to a point a relative distance */<br>   /* away from the current value of C.P. */<br>   moverel(100, 100);<br>   /* plot a pixel at the C.P. */<br>   putpixel(getx(), gety(), getmaxcolor());<br>   /* create and output a message at C.P. */<br>   sprintf(msg, " (%d, %d)", getx(), gety());<br>   outtext(msg);<br>   /* clean up */<br>   getch();<br>   closegraph();<br>   return 0;<br>}\n
movetext	<font color=blue>功  能</font>: 将屏幕文本从一个矩形区域拷贝到另一个矩形区域<br><font color=blue>用  法</font>: int movetext(int left, int top, int right, int bottom,<br>  int newleft, int newtop);<br><font color=blue>程序例</font>:<br>#include < conio.h ><br>#include < string.h ><br>int main(void)<br>{<br>   char *str = "This is a test string";<br>   clrscr();<br>   cputs(str);<br>   getch();<br>   movetext(1, 1, strlen(str), 2, 10, 10);<br>   getch();<br>   return 0;<br>}\n
moveto	<font color=blue>功  能</font>: 将CP移到(x, y)<br><font color=blue>用  法</font>: void far moveto(int x, int y);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>int main(void)<br>{<br>   /* request auto detection */<br>   int gdriver = DETECT, gmode, errorcode;<br>   char msg[80];<br>   /* initialize graphics and local variables */<br>   initgraph(&gdriver, &gmode, "");<br>   /* read result of initialization */<br>   errorcode = graphresult();<br>   if (errorcode != grOk)  /* an error occurred */<br>   {<br>      printf("Graphics error: %s\\n", grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>      exit(1); /* terminate with an error code */<br>   }<br>   /* move the C.P. to location (20, 30) */<br>   moveto(20, 30);<br>   /* plot a pixel at the C.P. */<br>   putpixel(getx(), gety(), getmaxcolor());<br>   /* create and output a message at (20, 30) */<br>   sprintf(msg, " (%d, %d)", getx(), gety());<br>   outtextxy(20, 30, msg);<br>   /* move to (100, 100) */<br>   moveto(100, 100);<br>   /* plot a pixel at the C.P. */<br>   putpixel(getx(), gety(), getmaxcolor());<br>   /* create and output a message at C.P. */<br>   sprintf(msg, " (%d, %d)", getx(), gety());<br>   outtext(msg);<br>   /* clean up */<br>   getch();<br>   closegraph();<br>   return 0;<br>}\n
normvideo	<font color=blue>功  能</font>: 选择正常亮度字符<br><font color=blue>用  法</font>: void normvideo(void);<br><font color=blue>程序例</font>:<br>#include < conio.h ><br>int main(void)<br>{<br>   normvideo();<br>   cprintf("NORMAL Intensity Text\\r\\n");<br>   return 0;<br>}\n
nosound	<font color=blue>功  能</font>: 关闭PC扬声器<br><font color=blue>用  法</font>: void nosound(void);<br><font color=blue>程序例</font>:<br>/* Emits a 7-Hz tone for 10 seconds.<br>     True story: 7 Hz is the resonant frequency of a chicken's skull cavity.<br>     This was determined empirically in Australia, where a new factory<br>     generating 7-Hz tones was located too close to a chicken ranch:<br>     When the factory started up, all the chickens died.<br>     Your PC may not be able to emit a 7-Hz tone.<br>*/<br>int main(void)<br>{<br>   sound(7);<br>   delay(10000);<br>   nosound();<br>}<br> <br> <br>\n
open	<font color=blue>功  能</font>: 打开一个文件用于读或写<br><font color=blue>用  法</font>: int open(char *pathname, int access[, int permiss]);<br><font color=blue>程序例</font>:<br>#include < string.h ><br>#include < stdio.h ><br>#include < fcntl.h ><br>#include < io.h ><br>int main(void)<br>{<br>   int handle;<br>   char msg[] = "Hello world";<br>   if ((handle = open("TEST.$$$", O_CREAT | O_TEXT)) == -1)<br>   {<br>      perror("Error:");<br>      return 1;<br>   }<br>   write(handle, msg, strlen(msg));<br>   close(handle);<br>   return 0;<br>}\n
outport	<font color=blue>功  能</font>: 输出整数到硬件端口中<br><font color=blue>用  法</font>: void outport(int port, int value);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < dos.h ><br>int main(void)<br>{<br>   int value = 64;<br>   int port = 0;<br>   outportb(port, value);<br>   printf("Value %d sent to port number %d\\n", value, port);<br>   return 0;<br>}\n
outportb	<font color=blue>功  能</font>: 输出字节到硬件端口中<br><font color=blue>用  法</font>: void outportb(int port, char byte);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < dos.h ><br>int main(void)<br>{<br>   int value = 64;<br>   int port = 0;<br>   outportb(port, value);<br>   printf("Value %d sent to port number %d\\n", value, port);<br>   return 0;<br>}\n
outtext	<font color=blue>功  能</font>: 在视区显示一个字符串<br><font color=blue>用  法</font>: void far outtext(char far *textstring);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>int main(void)<br>{<br>   /* request auto detection */<br>   int gdriver = DETECT, gmode, errorcode;<br>   int midx, midy;<br>   /* initialize graphics and local variables */<br>   initgraph(&gdriver, &gmode, "");<br>   /* read result of initialization */<br>   errorcode = graphresult();<br>   if (errorcode != grOk)  /* an error occurred */<br>   {<br>      printf("Graphics error: %s\\n", grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>      exit(1); /* terminate with an error code */<br>   }<br>   midx = getmaxx() / 2;<br>   midy = getmaxy() / 2;<br>   /* move the C.P. to the center of the screen */<br>   moveto(midx, midy);<br>   /* output text starting at the C.P. */<br>   outtext("This ");<br>   outtext("is ");<br>   outtext("a ");<br>   outtext("test.");<br>   /* clean up */<br>   getch();<br>   closegraph();<br>   return 0;<br>}\n
outtextxy	<font color=blue>功  能</font>: 在指定位置显示一字符串<br><font color=blue>用  法</font>: void far outtextxy(int x, int y, char *textstring);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>int main(void)<br>{<br>   /* request auto detection */<br>   int gdriver = DETECT, gmode, errorcode;<br>   int midx, midy;<br>   /* initialize graphics and local variables */<br>   initgraph( &gdriver, &gmode, "");<br>   /* read result of initialization */<br>   errorcode = graphresult();<br>   if (errorcode != grOk)  /* an error occurred */<br>   {<br>      printf("Graphics error: %s\\n", grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>      exit(1); /* terminate with an error code */<br>   }<br>   midx = getmaxx() / 2;<br>   midy = getmaxy() / 2;<br>   /* output text at the center of the screen*/<br>   /* Note: the C.P. doesn't get changed.*/<br>   outtextxy(midx, midy, "This is a test.");<br>   /* clean up */<br>   getch();<br>   closegraph();<br>   return 0;<br>}<br> <br> <br>\n
parsfnm	<font color=blue>功  能</font>: 分析文件名<br><font color=blue>用  法</font>: char *parsfnm (char *cmdline, struct fcb *fcbptr, int option);<br><font color=blue>程序例</font>:<br>#include < process.h ><br>#include < string.h ><br>#include < stdio.h ><br>#include < dos.h ><br>int main(void)<br>{<br>   char line[80];<br>   struct fcb blk;<br>   /* get file name */<br>   printf("Enter drive and file name (no path - ie. a:file.dat)\\n");<br>   gets(line);<br>   /* put file name in fcb */<br>   if (parsfnm(line, &blk, 1) == NULL)<br>      printf("Error in parsfm call\\n");<br>   else<br>      printf("Drive #%d  Name: %11s\\n", blk.fcb_drive, blk.fcb_name);<br>   return 0;<br>}\n
peek	<font color=blue>功  能</font>: 检查存储单元<br><font color=blue>用  法</font>: int peek(int segment, unsigned offset);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < conio.h ><br>#include < dos.h ><br>int main(void)<br>{<br>   int value = 0;<br>   printf("The current status of your keyboard is:\\n");<br>   value = peek(0x0040, 0x0017);<br>   if (value & 1)<br>      printf("Right shift on\\n");<br>   else<br>      printf("Right shift off\\n");<br>   if (value & 2)<br>      printf("Left shift on\\n");<br>   else<br>      printf("Left shift off\\n");<br>   if (value & 4)<br>      printf("Control key on\\n");<br>   else<br>      printf("Control key off\\n");<br>   if (value & 8)<br>      printf("Alt key on\\n");<br>   else<br>      printf("Alt key off\\n");<br>   if (value & 16)<br>      printf("Scroll lock on\\n");<br>   else<br>      printf("Scroll lock off\\n");<br>   if (value & 32)<br>      printf("Num lock on\\n");<br>   else<br>      printf("Num lock off\\n");<br>   if (value & 64)<br>      printf("Caps lock on\\n");<br>   else<br>      printf("Caps lock off\\n");<br>   return 0;<br>}\n
peekb	<font color=blue>功  能</font>: 检查存储单元<br><font color=blue>用  法</font>: char peekb (int segment, unsigned offset);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < conio.h ><br>#include < dos.h ><br>int main(void)<br>{<br>   int value = 0;<br>   printf("The current status of your keyboard is:\\n");<br>   value = peekb(0x0040, 0x0017);<br>   if (value & 1)<br>      printf("Right shift on\\n");<br>   else<br>      printf("Right shift off\\n");<br>   if (value & 2)<br>      printf("Left shift on\\n");<br>   else<br>      printf("Left shift off\\n");<br>   if (value & 4)<br>      printf("Control key on\\n");<br>   else<br>      printf("Control key off\\n");<br>   if (value & 8)<br>      printf("Alt key on\\n");<br>   else<br>      printf("Alt key off\\n");<br>   if (value & 16)<br>      printf("Scroll lock on\\n");<br>   else<br>      printf("Scroll lock off\\n");<br>   if (value & 32)<br>      printf("Num lock on\\n");<br>   else<br>      printf("Num lock off\\n");<br>   if (value & 64)<br>      printf("Caps lock on\\n");<br>   else<br>      printf("Caps lock off\\n");<br>   return 0;<br>}\n
perror	<font color=blue>功  能</font>: 系统错误信息<br><font color=blue>用  法</font>: void perror(char *string);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>int main(void)<br>{<br>   FILE *fp;<br>   fp = fopen("perror.dat", "r");<br>   if (!fp)<br>      perror("Unable to open file for reading");<br>   return 0;<br>}\n
pieslice	<font color=blue>功  能</font>: 绘制并填充一个扇形<br><font color=blue>用  法</font>: void far pieslice(int x, int stanle, int endangle, int radius);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>int main(void)<br>{<br>   /* request auto detection */<br>   int gdriver = DETECT, gmode, errorcode;<br>   int midx, midy;<br>   int stangle = 45, endangle = 135, radius = 100;<br>   /* initialize graphics and local variables */<br>   initgraph(&gdriver, &gmode, "");<br>   /* read result of initialization */<br>   errorcode = graphresult();<br>   if (errorcode != grOk)  /* an error occurred */<br>   {<br>      printf("Graphics error: %s\\n", grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>      exit(1); /* terminate with an error code */<br>   }<br>   midx = getmaxx() / 2;<br>   midy = getmaxy() / 2;<br>   /* set fill style and draw a pie slice */<br>   setfillstyle(EMPTY_FILL, getmaxcolor());<br>   pieslice(midx, midy, stangle, endangle, radius);<br>   /* clean up */<br>   getch();<br>   closegraph();<br>   return 0;<br>}\n
poke	<font color=blue>功  能</font>: 存值到一个给定存储单元<br><font color=blue>用  法</font>: void poke(int segment, int offset, int value);<br><font color=blue>程序例</font>:<br>#include < dos.h ><br>#include < conio.h ><br>int main(void)<br>{<br>   clrscr();<br>   cprintf("Make sure the scroll lock key is off and press any key\\r\\n");<br>   getch();<br>   poke(0x0000,0x0417,16);<br>   cprintf("The scroll lock is now on\\r\\n");<br>   return 0;<br>}\n
pokeb	<font color=blue>功  能</font>: 存值到一个给定存储单元<br><font color=blue>用  法</font>: void pokeb(int segment, int offset, char value);<br><font color=blue>程序例</font>:<br>#include < dos.h ><br>#include < conio.h ><br>int main(void)<br>{<br>   clrscr();<br>   cprintf("Make sure the scroll lock key is off and press any key\\r\\n");<br>   getch();<br>   pokeb(0x0000,0x0417,16);<br>   cprintf("The scroll lock is now on\\r\\n");<br>   return 0;<br>}\n
poly	<font color=blue>功  能</font>: 根据参数产生一个多项式<br><font color=blue>用  法</font>: double poly(double x, int n, double c[]);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < math.h ><br>/* polynomial:  x**3 - 2x**2 + 5x - 1 */<br>int main(void)<br>{<br>   double array[] = { -1.0, 5.0, -2.0, 1.0 };<br>   double result;<br>   result = poly(2.0, 3, array);<br>   printf("The polynomial: x**3 - 2.0x**2 + 5x - 1 at 2.0 is %lf\\n",<br>           result);<br>   return 0;<br>}\n
pow	<font color=blue>功  能</font>: 指数函数(x的y次方)<br><font color=blue>用  法</font>: double pow(double x, double y);<br><font color=blue>程序例</font>:<br>#include < math.h ><br>#include < stdio.h ><br>int main(void)<br>{<br>   double x = 2.0, y = 3.0;<br>   printf("%lf raised to %lf is %lf\\n", x, y, pow(x, y));<br>   return 0;<br>}<br> <br>\n
pow10	<font color=blue>功  能</font>: 指数函数(10的p次方)<br><font color=blue>用  法</font>: double pow10(int p);<br><font color=blue>程序例</font>:<br>#include < math.h ><br>#include < stdio.h ><br>int main(void)<br>{<br>   double p = 3.0;<br>   printf("Ten raised to %lf is %lf\\n", p, pow10(p));<br>   return 0;<br>}\n
printf	<font color=blue>功  能</font>: 产生格式化输出的函数<br><font color=blue>用  法</font>: int printf(char *format...);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < string.h ><br>#define I 555<br>#define R 5.5<br>int main(void)<br>{<br>   int i,j,k,l;<br>   char buf[7];<br>   char *prefix = buf;<br>   char tp[20];<br>   printf("prefix  6d      6o      8x        10.2e        "<br>          "10.2f\\n");<br>   strcpy(prefix,"%");<br>   for (i = 0; i < 2; i++)<br>   {<br>      for (j = 0; j < 2; j++)<br>         for (k = 0; k < 2; k++)<br>     for (l = 0; l < 2; l++)<br>            {<br>               if (i==0)  strcat(prefix,"-");<br>               if (j==0)  strcat(prefix,"+");<br>               if (k==0)  strcat(prefix,"#");<br>               if (l==0)  strcat(prefix,"0");<br>               printf("%5s |",prefix);<br>               strcpy(tp,prefix);<br>               strcat(tp,"6d |");<br>               printf(tp,I);<br>               strcpy(tp,"");<br>               strcpy(tp,prefix);<br>               strcat(tp,"6o |");<br>               printf(tp,I);<br>               strcpy(tp,"");<br>               strcpy(tp,prefix);<br>               strcat(tp,"8x |");<br>               printf(tp,I);<br>               strcpy(tp,"");<br>               strcpy(tp,prefix);<br>        strcat(tp,"10.2e |");<br>        printf(tp,R);<br>        strcpy(tp,prefix);<br>        strcat(tp,"10.2f |");<br>        printf(tp,R);<br>        printf("  \\n");<br>        strcpy(prefix,"%");<br>     }<br>       }<br>   return 0;<br>}\n
putc	<font color=blue>功  能</font>: 输出一字符到指定流中<br><font color=blue>用  法</font>: int putc(int ch, FILE *stream);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>int main(void)<br>{<br>   char msg[] = "Hello world\\n";<br>   int i = 0;<br>   while (msg[i])<br>      putc(msg[i++], stdout);<br>   return 0;<br>}\n
putch	<font color=blue>功  能</font>: 输出字符到控制台<br><font color=blue>用  法</font>: int putch(int ch);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < conio.h ><br>int main(void)<br>{<br>   char ch = 0;<br>   printf("Input a string:");<br>   while ((ch != '\\r'))<br>   {<br>      ch = getch();<br>      putch(ch);<br>   }<br>   return 0;<br>}\n
putchar	<font color=blue>功  能</font>: 在stdout上输出字符<br><font color=blue>用  法</font>: int putchar(int ch);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>/* define some box-drawing characters */<br>#define LEFT_TOP  0xDA<br>#define RIGHT_TOP 0xBF<br>#define HORIZ     0xC4<br>#define VERT      0xB3<br>#define LEFT_BOT  0xC0<br>#define RIGHT_BOT 0xD9<br>int main(void)<br>{<br>   char i, j;<br>   /* draw the top of the box */<br>   putchar(LEFT_TOP);<br>   for (i=0; i< 10; i++)<br>      putchar(HORIZ);<br>   putchar(RIGHT_TOP);<br>   putchar('\\n');<br>   /* draw the middle */<br>   for (i=0; i< 4; i++)<br>   {<br>      putchar(VERT);<br>      for (j=0; j< 10; j++)<br>         putchar(' ');<br>      putchar(VERT);<br>      putchar('\\n');<br>   }<br>   /* draw the bottom */<br>   putchar(LEFT_BOT);<br>   for (i=0; i< 10; i++)<br>      putchar(HORIZ);<br>   putchar(RIGHT_BOT);<br>   putchar('\\n');<br>   return 0;<br>}\n
putenv	<font color=blue>功  能</font>: 把字符串加到当前环境中<br><font color=blue>用  法</font>: int putenv(char *envvar);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < stdlib.h ><br>#include < alloc.h ><br>#include < string.h ><br>#include < dos.h ><br>int main(void)<br>{<br>   char *path, *ptr;<br>   int i = 0;<br>   /* get the current path environment */<br>   ptr = getenv("PATH");<br>   /* set up new path */<br>   path = malloc(strlen(ptr)+15);<br>   strcpy(path,"PATH=");<br>   strcat(path,ptr);<br>   strcat(path,";c:\\\\temp");<br>   /* replace the current path and display current environment */<br>   putenv(path);<br>   while (environ[i])<br>       printf("%s\\n",environ[i++]);<br>   return 0;<br>}\n
putimage	<font color=blue>功  能</font>: 在屏幕上输出一个位图<br><font color=blue>用  法</font>: void far putimage(int x, int y, void far *bitmap, int op);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>#define ARROW_SIZE 10<br>void draw_arrow(int x, int y);<br>int main(void)<br>{<br>   /* request autodetection */<br>   int gdriver = DETECT, gmode, errorcode;<br>   void *arrow;<br>   int x, y, maxx;<br>   unsigned int size;<br>   /* initialize graphics and local variables */<br>   initgraph(&gdriver, &gmode, "");<br>   /* read result of initialization */<br>   errorcode = graphresult();<br>   if (errorcode != grOk)  /* an error occurred */<br>   {<br>      printf("Graphics error: %s\\n", grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>      exit(1); /* terminate with an error code */<br>   }<br>   maxx = getmaxx();<br>   x = 0;<br>   y = getmaxy() / 2;<br>   /* draw the image to be grabbed */<br>   draw_arrow(x, y);<br>   /* calculate the size of the image */<br>   size = imagesize(x, y-ARROW_SIZE, x+(4*ARROW_SIZE), y+ARROW_SIZE);<br>   /* allocate memory to hold the image */<br>   arrow = malloc(size);<br>   /* grab the image */<br>   getimage(x, y-ARROW_SIZE, x+(4*ARROW_SIZE), y+ARROW_SIZE, arrow);<br>   /* repeat until a key is pressed */<br>   while (!kbhit())<br>   {<br>      /* erase old image */<br>      putimage(x, y-ARROW_SIZE, arrow, XOR_PUT);<br>      x += ARROW_SIZE;<br>      if (x >= maxx)<br>          x = 0;<br>      /* plot new image */<br>      putimage(x, y-ARROW_SIZE, arrow, XOR_PUT);<br>   }<br>   /* clean up */<br>   free(arrow);<br>   closegraph();<br>   return 0;<br>}<br>void draw_arrow(int x, int y)<br>{<br>   /* draw an arrow on the screen */<br>   moveto(x, y);<br>   linerel(4*ARROW_SIZE, 0);<br>   linerel(-2*ARROW_SIZE, -1*ARROW_SIZE);<br>   linerel(0, 2*ARROW_SIZE);<br>   linerel(2*ARROW_SIZE, -1*ARROW_SIZE);<br>}\n
putpixel	<font color=blue>功  能</font>: 在指定位置画一像素<br><font color=blue>用  法</font>: void far putpixel (int x, int y, int pixelcolor);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>#include < dos.h ><br>#define PIXEL_COUNT 1000<br>#define DELAY_TIME  100  /* in milliseconds */<br>int main(void)<br>{<br>   /* request autodetection */<br>   int gdriver = DETECT, gmode, errorcode;<br>   int i, x, y, color, maxx, maxy, maxcolor, seed;<br>   /* initialize graphics and local variables */<br>   initgraph(&gdriver, &gmode, "");<br>   /* read result of initialization */<br>   errorcode = graphresult();<br>   if (errorcode != grOk)  /* an error occurred */<br>   {<br>      printf("Graphics error: %s\\n", grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>      exit(1); /* terminate with an error code */<br>   }<br>   maxx = getmaxx() + 1;<br>   maxy = getmaxy() + 1;<br>   maxcolor = getmaxcolor() + 1;<br>   while (!kbhit())<br>   {<br>      /* seed the random number generator */<br>      seed = random(32767);<br>      srand(seed);<br>      for (i=0; i< PIXEL_COUNT; i++)<br>      {<br>  x = random(maxx);<br>         y = random(maxy);<br>         color = random(maxcolor);<br>         putpixel(x, y, color);<br>      }<br>      delay(DELAY_TIME);<br>      srand(seed);<br>      for (i=0; i< PIXEL_COUNT; i++)<br>      {<br>  x = random(maxx);<br>  y = random(maxy);<br>  color = random(maxcolor);<br>  if (color == getpixel(x, y))<br>     putpixel(x, y, 0);<br>      }<br>   }<br>   /* clean up */<br>   getch();<br>   closegraph();<br>   return 0;<br>}\n
puts	<font color=blue>功  能</font>: 送一字符串到流中<br><font color=blue>用  法</font>: int puts(char *string);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>int main(void)<br>{<br>   char string[] = "This is an example output string\\n";<br>   puts(string);<br>   return 0;<br>}\n
puttext	<font color=blue>功  能</font>: 将文本从存储区拷贝到屏幕<br><font color=blue>用  法</font>: int puttext(int left, int top, int right, int bottom, void *source);<br><font color=blue>程序例</font>:<br>#include < conio.h ><br>int main(void)<br>{<br>   char buffer[512];<br>   /* put some text to the console */<br>   clrscr();<br>   gotoxy(20, 12);<br>   cprintf("This is a test.  Press any key to continue ...");<br>   getch();<br>   /* grab screen contents */<br>   gettext(20, 12, 36, 21,buffer);<br>   clrscr();<br>   /* put selected characters back to the screen */<br>   gotoxy(20, 12);<br>   puttext(20, 12, 36, 21, buffer);<br>   getch();<br>   return 0;<br>}\n
putw	<font color=blue>功  能</font>: 把一字符或字送到流中<br><font color=blue>用  法</font>: int putw(int w, FILE *stream);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < stdlib.h ><br>#define FNAME "test.$$$"<br>int main(void)<br>{<br>   FILE *fp;<br>   int word;<br>   /* place the word in a file */<br>   fp = fopen(FNAME, "wb");<br>   if (fp == NULL)<br>   {<br>      printf("Error opening file %s\\n", FNAME);<br>      exit(1);<br>   }<br>   word = 94;<br>   putw(word,fp);<br>   if (ferror(fp))<br>       printf("Error writing to file\\n");<br>   else<br>       printf("Successful write\\n");<br>   fclose(fp);<br>   /* reopen the file */<br>   fp = fopen(FNAME, "rb");<br>   if (fp == NULL)<br>   {<br>      printf("Error opening file %s\\n", FNAME);<br>      exit(1);<br>   }<br>   /* extract the word */<br>   word = getw(fp);<br>   if (ferror(fp))<br>       printf("Error reading file\\n");<br>   else<br>       printf("Successful read: word = %d\\n", word);<br>   /* clean up */<br>   fclose(fp);<br>   unlink(FNAME);<br>   return 0;<br>}<br> <br> <br>\n
qsort	<font color=blue>功  能</font>: 使用快速排序例程进行排序<br><font color=blue>用  法</font>: void qsort(void *base, int nelem, int width, int (*fcmp)());<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < stdlib.h ><br>#include < string.h ><br>int sort_function( const void *a, const void *b);<br>char list[5][4] = { "cat", "car", "cab", "cap", "can" };<br> <br>int main(void)<br>{<br>   int  x;<br>   qsort((void *)list, 5, sizeof(list[0]), sort_function);<br>   for (x = 0; x < 5; x++)<br>      printf("%s\\n", list[x]);<br>   return 0;<br>}<br>int sort_function( const void *a, const void *b)<br>{<br>   return( strcmp(a,b) );<br>}<br> <br>  <br>\n
raise	<font color=blue>功  能</font>: 向正在执行的程序发送一个信号<br><font color=blue>用  法</font>: int raise(int sig);<br><font color=blue>程序例</font>:<br>#include < signal.h ><br>int main(void)<br>{<br>   int a, b;<br>   a = 10;<br>   b = 0;<br>   if (b == 0)<br>   /* preempt divide by zero error */<br>      raise(SIGFPE);<br>   a = a / b;<br>   return 0;<br>}\n
rand	<font color=blue>功  能</font>: 随机数发生器<br><font color=blue>用  法</font>: void rand(void);<br><font color=blue>程序例</font>:<br>#include < stdlib.h ><br>#include < stdio.h ><br>int main(void)<br>{<br>   int i;<br>   printf("Ten random numbers from 0 to 99\\n\\n");<br>   for(i=0; i< 10; i++)<br>      printf("%d\\n", rand() % 100);<br>   return 0;<br>}\n
randbrd	<font color=blue>功  能</font>: 随机块读<br><font color=blue>用  法</font>: int randbrd(struct fcb *fcbptr, int reccnt);<br><font color=blue>程序例</font>:<br>#include < process.h ><br>#include < string.h ><br>#include < stdio.h ><br>#include < dos.h ><br>int main(void)<br>{<br>   char far *save_dta;<br>   char line[80], buffer[256];<br>   struct fcb blk;<br>   int i, result;<br>   /* get user input file name for dta */<br>   printf("Enter drive and file name (no path - i.e. a:file.dat)\\n");<br>   gets(line);<br>   /* put file name in fcb */<br>   if (!parsfnm(line, &blk, 1))<br>   {<br>      printf("Error in call to parsfnm\\n");<br>      exit(1);<br>   }<br>   printf("Drive #%d  File: %s\\n\\n", blk.fcb_drive, blk.fcb_name);<br>   /* open file with DOS FCB open file */<br>   bdosptr(0x0F, &blk, 0);<br>   /* save old dta, and set new one */<br>   save_dta = getdta();<br>   setdta(buffer);<br>   /* set up info for the new dta */<br>   blk.fcb_recsize = 128;<br>   blk.fcb_random = 0L;<br>   result = randbrd(&blk, 1);<br>   /* check results from randbrd */<br>   if (!result)<br>      printf("Read OK\\n\\n");<br>   else<br>   {<br>      perror("Error during read");<br>      exit(1);<br>   }<br>   /* read in data from the new dta */<br>   printf("The first 128 characters are:\\n");<br>   for (i=0; i< 128; i++)<br>      putchar(buffer[i]);<br>   /* restore previous dta */<br>   setdta(save_dta);<br>   return 0;<br>}<br> <br>\n
randbwr	<font color=blue>功  能</font>: 随机块写<br><font color=blue>用  法</font>: int randbwr(struct fcp *fcbptr, int reccnt);<br><font color=blue>程序例</font>:<br>#include < process.h ><br>#include < string.h ><br>#include < stdio.h ><br>#include < dos.h ><br>int main(void)<br>{<br>   char far *save_dta;<br>   char line[80];<br>   char buffer[256] = "RANDBWR test!";<br>   struct fcb blk;<br>   int result;<br>   /* get new file name from user */<br>   printf("Enter a file name to create (no path - ie. a:file.dat\\n");<br>   gets(line);<br>   /* parse the new file name to the dta */<br>   parsfnm(line,&blk,1);<br>   printf("Drive #%d  File: %s\\n", blk.fcb_drive, blk.fcb_name);<br>   /* request DOS services to create file */<br>   if (bdosptr(0x16, &blk, 0) == -1)<br>   {<br>      perror("Error creating file");<br>      exit(1);<br>   }<br>   /* save old dta and set new dta */<br>   save_dta = getdta();<br>   setdta(buffer);<br>   /* write new records */<br>   blk.fcb_recsize = 256;<br>   blk.fcb_random = 0L;<br>   result = randbwr(&blk, 1);<br>   if (!result)<br>      printf("Write OK\\n");<br>   else<br>   {<br>      perror("Disk error");<br>      exit(1);<br>   }<br>   /* request DOS services to close the file */<br>   if (bdosptr(0x10, &blk, 0) == -1)<br>   {<br>      perror("Error closing file");<br>      exit(1);<br>   }<br>   /* reset the old dta */<br>   setdta(save_dta);<br>   return 0;<br>}\n
random	<font color=blue>功  能</font>: 随机数发生器<br><font color=blue>用  法</font>: int random(int num);<br><font color=blue>程序例</font>:<br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < time.h ><br>/* prints a random number in the range 0 to 99 */<br>int main(void)<br>{<br>   randomize();<br>   printf("Random number in the 0-99 range: %d\\n", random (100));<br>   return 0;<br>}\n
randomize	<font color=blue>功  能</font>: 初始化随机数发生器<br><font color=blue>用  法</font>: void randomize(void);<br><font color=blue>程序例</font>:<br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < time.h ><br>int main(void)<br>{<br>   int i;<br>   randomize();<br>   printf("Ten random numbers from 0 to 99\\n\\n");<br>   for(i=0; i< 10; i++)<br>       printf("%d\\n", rand() % 100);<br>   return 0;<br>}\n
read	<font color=blue>功  能</font>: 从文件中读<br><font color=blue>用  法</font>: int read(int handle, void *buf, int nbyte);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < io.h ><br>#include < alloc.h ><br>#include < fcntl.h ><br>#include < process.h ><br>#include < sys\\stat.h ><br>int main(void)<br>{<br>   void *buf;<br>   int handle, bytes;<br>   buf = malloc(10);<br>/<br>*   Looks for a file in the current directory named TEST.$$$ and attempts<br>   to read 10 bytes from it.  To use this example you should create the<br>   file TEST.$$$<br>*/<br>   if ((handle =<br>      open("TEST.$$$", O_RDONLY | O_BINARY, S_IWRITE | S_IREAD)) == -1)<br>   {<br>      printf("Error Opening File\\n");<br>      exit(1);<br>   }<br>   if ((bytes = read(handle, buf, 10)) == -1) {<br>      printf("Read Failed.\\n");<br>      exit(1);<br>   }<br>   else {<br>      printf("Read: %d bytes read.\\n", bytes);<br>   }<br>   return 0;<br>}\n
realloc	<font color=blue>功  能</font>: 重新分配主存<br><font color=blue>用  法</font>: void *realloc(void *ptr, unsigned newsize);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < alloc.h ><br>#include < string.h ><br>int main(void)<br>{<br>   char *str;<br>   /* allocate memory for string */<br>   str = malloc(10);<br>   /* copy "Hello" into string */<br>   strcpy(str, "Hello");<br>   printf("String is %s\\n  Address is %p\\n", str, str);<br>   str = realloc(str, 20);<br>   printf("String is %s\\n  New address is %p\\n", str, str);<br>   /* free memory */<br>   free(str);<br>   return 0;<br>}\n
rectangle	<font color=blue>功  能</font>: 画一个矩形<br><font color=blue>用  法</font>: void far rectangle(int left, int top, int right, int bottom);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>int main(void)<br>{<br>   /* request auto detection */<br>   int gdriver = DETECT, gmode, errorcode;<br>   int left, top, right, bottom;<br>   /* initialize graphics and local variables */<br>   initgraph(&gdriver, &gmode, "");<br>   /* read result of initialization */<br>   errorcode = graphresult();<br>   if (errorcode != grOk)  /* an error occurred */<br>   {<br>      printf("Graphics error: %s\\n", grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>      exit(1); /* terminate with an error code */<br>   }<br>   left = getmaxx() / 2 - 50;<br>   top = getmaxy() / 2 - 50;<br>   right = getmaxx() / 2 + 50;<br>   bottom = getmaxy() / 2 + 50;<br>   /* draw a rectangle */<br>   rectangle(left,top,right,bottom);<br>   /* clean up */<br>   getch();<br>   closegraph();<br>   return 0;<br>}\n
registerbgidriver	<font color=blue>功  能</font>: 登录已连接进来的图形驱动程序代码<br><font color=blue>用  法</font>: int registerbgidriver(void(*driver)(void));<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>int main(void)<br>{<br>   /* request auto detection */<br>   int gdriver = DETECT, gmode, errorcode;<br>   /* register a driver that was added into graphics.lib */<br>   errorcode = registerbgidriver(EGAVGA_driver);<br>   /* report any registration errors */<br>   if (errorcode < 0)<br>   {<br>      printf("Graphics error: %s\\n", grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>      exit(1); /* terminate with an error code */<br>   }<br>   /* initialize graphics and local variables */<br>   initgraph(&gdriver, &gmode, "");<br>   /* read result of initialization */<br>   errorcode = graphresult();<br>   if (errorcode != grOk)  /* an error occurred */<br>   {<br>      printf("Graphics error: %s\\n", grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>      exit(1); /* terminate with an error code */<br>   }<br>   /* draw a line */<br>   line(0, 0, getmaxx(), getmaxy());<br>   /* clean up */<br>   getch();<br>   closegraph();<br>   return 0;<br>}\n
remove	<font color=blue>功  能</font>: 删除一个文件<br><font color=blue>用  法</font>: int remove(char *filename);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>int main(void)<br>{<br>   char file[80];<br>   /* prompt for file name to delete */<br>   printf("File to delete: ");<br>   gets(file);<br>   /* delete the file */<br>   if (remove(file) == 0)<br>      printf("Removed %s.\\n",file);<br>   else<br>      perror("remove");<br>   return 0;<br>}\n
rename	<font color=blue>功  能</font>: 重命名文件<br><font color=blue>用  法</font>: int rename(char *oldname, char *newname);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>int main(void)<br>{<br>   char oldname[80], newname[80];<br>   /* prompt for file to rename and new name */<br>   printf("File to rename: ");<br>   gets(oldname);<br>   printf("New name: ");<br>   gets(newname);<br>   /* Rename the file */<br>   if (rename(oldname, newname) == 0)<br>      printf("Renamed %s to %s.\\n", oldname, newname);<br>   else<br>      perror("rename");<br>   return 0;<br>}\n
restorecrtmode	<font color=blue>功  能</font>: 将屏幕模式恢复为先前的imitgraph设置<br><font color=blue>用  法</font>: void far restorecrtmode(void);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>int main(void)<br>{<br>   /* request auto detection */<br>   int gdriver = DETECT, gmode, errorcode;<br>   int x, y;<br>   /* initialize graphics and local variables */<br>   initgraph(&gdriver, &gmode, "");<br>   /* read result of initialization */<br>   errorcode = graphresult();<br>   if (errorcode != grOk)  /* an error occurred */<br>   {<br>      printf("Graphics error: %s\\n", grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>      exit(1); /* terminate with an error code */<br>   }<br>   x = getmaxx() / 2;<br>   y = getmaxy() / 2;<br>   /* output a message */<br>   settextjustify(CENTER_TEXT, CENTER_TEXT);<br>   outtextxy(x, y, "Press any key to exit graphics:");<br>   getch();<br>   /* restore system to text mode */<br>   restorecrtmode();<br>   printf("We're now in text mode.\\n");<br>   printf("Press any key to return to graphics mode:");<br>   getch();<br>   /* return to graphics mode */<br>   setgraphmode(getgraphmode());<br>   /* output a message */<br>   settextjustify(CENTER_TEXT, CENTER_TEXT);<br>   outtextxy(x, y, "We're back in graphics mode.");<br>   outtextxy(x, y+textheight("W"), "Press any key to halt:");<br>   /* clean up */<br>   getch();<br>   closegraph();<br>   return 0;<br>}\n
rewind	<font color=blue>功  能</font>: 将文件指针重新指向一个流的开头<br><font color=blue>用  法</font>: int rewind(FILE *stream);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < dir.h ><br> int main(void)<br> {<br>    FILE *fp;<br>    char *fname = "TXXXXXX", *newname, first;<br>    newname = mktemp(fname);<br>    fp = fopen(newname,"w+");<br>    fprintf(fp,"abcdefghijklmnopqrstuvwxyz");<br>    rewind(fp);<br>    fscanf(fp,"%c",&first);<br>    printf("The first character is: %c\\n",first);<br>    fclose(fp);<br>    remove(newname);<br>    return 0;<br>}\n
rmdir	<font color=blue>功  能</font>: 删除DOS文件目录<br><font color=blue>用  法</font>: int rmdir(char *stream);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < conio.h ><br>#include < process.h ><br>#include < dir.h ><br>#define DIRNAME "testdir.$$$"<br>int main(void)<br>{<br>   int stat;<br>   stat = mkdir(DIRNAME);<br>   if (!stat)<br>          printf("Directory created\\n");<br>   else<br>   {<br>      printf("Unable to create directory\\n");<br>      exit(1);<br>   }<br>   getch();<br>   system("dir/p");<br>   getch();<br>   stat = rmdir(DIRNAME);<br>   if (!stat)<br>          printf("\\nDirectory deleted\\n");<br>   else<br>   {<br>   perror("\\nUnable to delete directory\\n");<br>      exit(1);<br>   }<br>   return 0;<br>}<br>  <br>\n
sbrk	<font color=blue>功  能</font>: 改变数据段空间位置<br><font color=blue>用  法</font>: char *sbrk(int incr);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < alloc.h ><br>int main(void)<br>{<br>   printf("Changing allocation with sbrk()\\n");<br>   printf("Before sbrk() call: %lu bytes free\\n",<br>   (unsigned long) coreleft());<br>   sbrk(1000);<br>   printf(" After sbrk() call: %lu bytes free\\n",<br>   (unsigned long) coreleft());<br>   return 0;<br>}\n
scanf	<font color=blue>功  能</font>: 执行格式化输入<br><font color=blue>用  法</font>: int scanf(char *format[,argument,...]);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < conio.h ><br>int main(void)<br>{<br>   char label[20];<br>   char name[20];<br>   int entries = 0;<br>   int loop, age;<br>   double salary;<br>   struct Entry_struct<br>   {<br>      char  name[20];<br>      int   age;<br>      float salary;<br>   } entry[20];<br>/* Input a label as a string of characters restricting to 20 characters */<br>   printf("\\n\\nPlease enter a label for the chart: ");<br>   scanf("%20s", label);<br>   fflush(stdin);  /* flush the input stream in case of bad input */<br>/* Input number of entries as an integer */<br>   printf("How many entries will there be? (less than 20) ");<br>   scanf("%d", &entries);<br>   fflush(stdin);   /* flush the input stream in case of bad input */<br>/* input a name restricting input to only letters upper or lower case */<br>   for (loop=0;loop< entries;++loop)<br>   {<br>      printf("Entry %d\\n", loop);<br>      printf("  Name   : ");<br>      scanf("%[A-Za-z]", entry[loop].name);<br>      fflush(stdin);  /* flush the input stream in case of bad input */<br>/* input an age as an integer */<br>      printf("  Age    : ");<br>      scanf("%d", &entry[loop].age);<br>      fflush(stdin);  /* flush the input stream in case of bad input */<br>/* input a salary as a float */<br>      printf("  Salary : ");<br>      scanf("%f", &entry[loop].salary);<br>      fflush(stdin); /* flush the input stream in case of bad input */<br>   }<br>/* Input a name, age and salary as a string, integer, and double */<br>   printf("\\nPlease enter your name, age and salary\\n");<br>   scanf("%20s %d %lf", name, &age, &salary);<br> <br>/* Print out the data that was input */<br>   printf("\\n\\nTable %s\\n",label);<br>   printf("Compiled by %s  age %d  $%15.2lf\\n", name, age, salary);<br>   printf("-----------------------------------------------------\\n");<br>   for (loop=0;loop< entries;++loop)<br>      printf("%4d | %-20s | %5d | %15.2lf\\n",<br>         loop + 1,<br>  entry[loop].name,<br>  entry[loop].age,<br>         entry[loop].salary);<br>   printf("-----------------------------------------------------\\n");<br>   return 0;<br>}\n
searchpath	<font color=blue>功  能</font>: 搜索DOS路径<br><font color=blue>用  法</font>: char *searchpath(char *filename);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < dir.h ><br>int main(void)<br>{<br>   char *p;<br>   /* Looks for TLINK and returns a pointer<br>      to the path  */<br>   p = searchpath("TLINK.EXE");<br>   printf("Search for TLINK.EXE : %s\\n", p);<br>   /* Looks for non-existent file  */<br>   p = searchpath("NOTEXIST.FIL");<br>   printf("Search for NOTEXIST.FIL : %s\\n", p);<br>   return 0;<br>}\n
sector	<font color=blue>功  能</font>: 画并填充椭圆扇区<br><font color=blue>用  法</font>: void far sector(int x, int y, int stangle, int endangle);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>int main(void)<br>{<br>   /* request auto detection */<br>   int gdriver = DETECT, gmode, errorcode;<br>   int midx, midy, i;<br>   int stangle = 45, endangle = 135;<br>   int xrad = 100, yrad = 50;<br>   /* initialize graphics and local variables */<br>   initgraph(&gdriver, &gmode, "");<br>   /* read result of initialization */<br>   errorcode = graphresult();<br>   if (errorcode != grOk)  /* an error occurred */<br>   {<br>      printf("Graphics error: %s\\n", grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>      exit(1); /* terminate with an error code */<br>   }<br>   midx = getmaxx() / 2;<br>   midy = getmaxy() / 2;<br>   /* loop through the fill patterns */<br>   for (i=EMPTY_FILL; i< USER_FILL; i++)<br>   {<br>      /* set the fill style */<br>      setfillstyle(i, getmaxcolor());<br>      /* draw the sector slice */<br>      sector(midx, midy, stangle, endangle, xrad, yrad);<br>      getch();<br>   }<br>   /* clean up */<br>   closegraph();<br>   return 0;<br>}<br> <br>\n
segread	<font color=blue>功  能</font>: 读段寄存器值<br><font color=blue>用  法</font>: void segread(struct SREGS *segtbl);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < dos.h ><br>int main(void)<br>{<br>   struct SREGS segs;<br>   segread(&segs);<br>   printf("Current segment register settings\\n\\n");<br>   printf("CS: %X   DS: %X\\n", segs.cs, segs.ds);<br>   printf("ES: %X   SS: %X\\n", segs.es, segs.ss);<br>   return 0;<br>}\nsetactivepage\n<font color=blue>功  能</font>: 设置图形输出活动页<br><font color=blue>用  法</font>: void far setactivepage(int pagenum);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>int main(void)<br>{<br>   /* select a driver and mode that supports */<br>   /* multiple pages.                        */<br>   int gdriver = EGA, gmode = EGAHI, errorcode;<br>   int x, y, ht;<br>   /* initialize graphics and local variables */<br>   initgraph(&gdriver, &gmode, "");<br>   /* read result of initialization */<br>   errorcode = graphresult();<br>   if (errorcode != grOk)  /* an error occurred */<br>   {<br>      printf("Graphics error: %s\\n", grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>      exit(1); /* terminate with an error code */<br>   }<br>   x = getmaxx() / 2;<br>   y = getmaxy() / 2;<br>   ht = textheight("W");<br>   /*  select the off screen page for drawing */<br>   setactivepage(1);<br>   /* draw a line on page #1 */<br>   line(0, 0, getmaxx(), getmaxy());<br>   /* output a message on page #1 */<br>   settextjustify(CENTER_TEXT, CENTER_TEXT);<br>   outtextxy(x, y, "This is page #1:");<br>   outtextxy(x, y+ht, "Press any key to halt:");<br>   /* select drawing to page #0 */<br>   setactivepage(0);<br>   /* output a message  on page #0 */<br>   outtextxy(x, y, "This is page #0.");<br>   outtextxy(x, y+ht, "Press any key to view page #1:");<br>   getch();<br>   /* select page #1 as the visible page */<br>   setvisualpage(1);<br>   /* clean up */<br>   getch();<br>   closegraph();<br>   return 0;<br>}\n
setallpallette	<font color=blue>功  能</font>: 按指定方式改变所有的调色板颜色<br><font color=blue>用  法</font>: void far setallpallette(struct palette, far *pallette);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>int main(void)<br>{<br>   /* request auto detection */<br>   int gdriver = DETECT, gmode, errorcode;<br>   struct palettetype pal;<br>   int color, maxcolor, ht;<br>   int y = 10;<br>   char msg[80];<br>   /* initialize graphics and local variables */<br>   initgraph(&gdriver, &gmode, "");<br>   /* read result of initialization */<br>   errorcode = graphresult();<br>   if (errorcode != grOk)  /* an error occurred */<br>   {<br>      printf("Graphics error: %s\\n", grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>      exit(1); /* terminate with an error code */<br>   }<br>   maxcolor = getmaxcolor();<br>   ht = 2 * textheight("W");<br>   /* grab a copy of the palette */<br>   getpalette(&pal);<br>   /* display the default palette colors */<br>   for (color=1; color< =maxcolor; color++)<br>   {<br>      setcolor(color);<br>      sprintf(msg, "Color: %d", color);<br>      outtextxy(1, y, msg);<br>      y += ht;<br>   }<br>   /* wait for a key */<br>   getch();<br>   /* black out the colors one by one */<br>   for (color=1; color< =maxcolor; color++)<br>   {<br>      setpalette(color, BLACK);<br>      getch();<br>   }<br>   /* restore the palette colors */<br>   setallpalette(&pal);<br>   /* clean up */<br>   getch();<br>   closegraph();<br>   return 0;<br>}\n
setaspectratio	<font color=blue>功  能</font>: 设置图形纵横比<br><font color=blue>用  法</font>: void far setaspectratio(int xasp, int yasp);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>int main(void)<br>{<br>   /* request auto detection */<br>   int gdriver = DETECT, gmode, errorcode;<br>   int xasp, yasp, midx, midy;<br>   /* initialize graphics and local variables */<br>   initgraph(&gdriver, &gmode, "");<br>   /* read result of initialization */<br>   errorcode = graphresult();<br>   if (errorcode != grOk)  /* an error occurred */<br>   {<br>      printf("Graphics error: %s\\n", grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>      exit(1); /* terminate with an error code */<br>   }<br>   midx = getmaxx() / 2;<br>   midy = getmaxy() / 2;<br>   setcolor(getmaxcolor());<br>   /* get current aspect ratio settings */<br>   getaspectratio(&xasp, &yasp);<br>   /* draw normal circle */<br>   circle(midx, midy, 100);<br>   getch();<br>   /* claer the screen */<br>   cleardevice();<br>   /* adjust the aspect for a wide circle */<br>   setaspectratio(xasp/2, yasp);<br>   circle(midx, midy, 100);<br>   getch();<br>   /* adjust the aspect for a narrow circle */<br>   cleardevice();<br>   setaspectratio(xasp, yasp/2);<br>   circle(midx, midy, 100);<br>   /* clean up */<br>   getch();<br>   closegraph();<br>   return 0;<br>}\n
setbkcolor	<font color=blue>功  能</font>: 用调色板设置当前背景颜色<br><font color=blue>用  法</font>: void far setbkcolor(int color);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>int main(void)<br>{<br>   /* select a driver and mode that supports */<br>   /* multiple background colors.            */<br>   int gdriver = EGA, gmode = EGAHI, errorcode;<br>   int bkcol, maxcolor, x, y;<br>   char msg[80];<br>   /* initialize graphics and local variables */<br>   initgraph(&gdriver, &gmode, "");<br>   /* read result of initialization */<br>   errorcode = graphresult();<br>   if (errorcode != grOk)  /* an error occurred */<br>   {<br>      printf("Graphics error: %s\\n", grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>      exit(1); /* terminate with an error code */<br>   }<br>   /* maximum color index supported */<br>   maxcolor = getmaxcolor();<br>   /* for centering text messages */<br>   settextjustify(CENTER_TEXT, CENTER_TEXT);<br>   x = getmaxx() / 2;<br>   y = getmaxy() / 2;<br>   /* loop through the available colors */<br>   for (bkcol=0; bkcol< =maxcolor; bkcol++)<br>   {<br>      /* clear the screen */<br>      cleardevice();<br>      /* select a new background color */<br>      setbkcolor(bkcol);<br>      /* output a messsage */<br>      if (bkcol == WHITE)<br>  setcolor(EGA_BLUE);<br>      sprintf(msg, "Background color: %d", bkcol);<br>      outtextxy(x, y, msg);<br>      getch();<br>   }<br>   /* clean up */<br>   closegraph();<br>   return 0;<br>}\n
setblock	<font color=blue>功  能</font>: 修改先前已分配的DOS存储段大小<br><font color=blue>用  法</font>: int setblock(int seg, int newsize);<br><font color=blue>程序例</font>:<br>#include < dos.h ><br>#include < alloc.h ><br>#include < stdio.h ><br>#include < stdlib.h ><br>int main(void)<br>{<br>   unsigned int size, segp;<br>   int stat;<br>   size = 64; /* (64 x 16) = 1024 bytes */<br>   stat = allocmem(size, &segp);<br>   if (stat == -1)<br>      printf("Allocated memory at segment: %X\\n", segp);<br>   else<br>   {<br>      printf("Failed: maximum number of paragraphs available is %d\\n",<br>      stat);<br>      exit(1);<br>   }<br>   stat = setblock(segp, size * 2);<br>   if (stat == -1)<br>      printf("Expanded memory block at segment: %X\\n", segp);<br>   else<br>      printf("Failed: maximum number of paragraphs available is %d\\n",<br>             stat);<br>   freemem(segp);<br>   return 0;<br>}\n
setbuf	<font color=blue>功  能</font>: 把缓冲区与流相联<br><font color=blue>用  法</font>: void setbuf(FILE *steam, char *buf);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>/* BUFSIZ is defined in stdio.h */<br>char outbuf[BUFSIZ];<br>int main(void)<br>{<br>   /* attach a buffer to the standard output stream */<br>   setbuf(stdout, outbuf);<br>   /* put some characters into the buffer */<br>   puts("This is a test of buffered output.\\n\\n");<br>   puts("This output will go into outbuf\\n");<br>   puts("and won't appear until the buffer\\n");<br>   puts("fills up or we flush the stream.\\n");<br>   /* flush the output buffer */<br>   fflush(stdout);<br>   return 0;<br>}\n
setcbrk	<font color=blue>功  能</font>: 设置Control-break<br><font color=blue>用  法</font>: int setcbrk(int value);<br><font color=blue>程序例</font>:<br>#include < dos.h ><br>#include < conio.h ><br>#include < stdio.h ><br>int main(void)<br>{<br>   int break_flag;<br>   printf("Enter 0 to turn control break off\\n");<br>   printf("Enter 1 to turn control break on\\n");<br>   break_flag = getch() - 0;<br>   setcbrk(break_flag);<br>   if (getcbrk())<br>      printf("Cntrl-brk flag is on\\n");<br>   else<br>      printf("Cntrl-brk flag is off\\n");<br>   return 0;<br>}</>\n
setcolor	<font color=blue>功  能</font>: 设置当前画线颜色<br><font color=blue>用  法</font>: void far setcolor(int color);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>int main(void)<br>{<br>   /* select a driver and mode that supports */<br>   /* multiple drawing colors.               */<br>   int gdriver = EGA, gmode = EGAHI, errorcode;<br>   int color, maxcolor, x, y;<br>   char msg[80];<br>   /* initialize graphics and local variables */<br>   initgraph(&gdriver, &gmode, "");<br>   /* read result of initialization */<br>   errorcode = graphresult();<br>   if (errorcode != grOk)  /* an error occurred */<br>   {<br>      printf("Graphics error: %s\\n", grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>      exit(1); /* terminate with an error code */<br>   }<br>   /* maximum color index supported */<br>   maxcolor = getmaxcolor();<br>   /* for centering text messages */<br>   settextjustify(CENTER_TEXT, CENTER_TEXT);<br>   x = getmaxx() / 2;<br>   y = getmaxy() / 2;<br>   /* loop through the available colors */<br>   for (color=1; color< =maxcolor; color++)<br>   {<br>      /* clear the screen */<br>      cleardevice();<br>      /* select a new background color */<br>      setcolor(color);<br>      /* output a messsage */<br>      sprintf(msg, "Color: %d", color);<br>      outtextxy(x, y, msg);<br>      getch();<br>   }<br>   /* clean up */<br>   closegraph();<br>   return 0;<br>}\n
setdate	<font color=blue>功  能</font>: 设置DOS日期<br><font color=blue>用  法</font>: void setdate(struct date *dateblk);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < process.h ><br>#include < dos.h ><br>int main(void)<br>{<br>   struct date reset;<br>   struct date save_date;<br>   getdate(&save_date);<br>   printf("Original date:\\n");<br>   system("date");<br>   reset.da_year = 2001;<br>   reset.da_day = 1;<br>   reset.da_mon = 1;<br>   setdate(&reset);<br>   printf("Date after setting:\\n");<br>   system("date");<br>   setdate(&save_date);<br>   printf("Back to original date:\\n");<br>   system("date");<br>   return 0;<br>}\n
setdisk	<font color=blue>功  能</font>: 设置当前磁盘驱动器<br><font color=blue>用  法</font>: int setdisk(int drive);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < dir.h ><br>int main(void)<br>{<br>   int save, disk, disks;<br>   /* save original drive */<br>   save = getdisk();<br>   /* print number of logic drives */<br>   disks = setdisk(save);<br>   printf("%d logical drives on the system\\n\\n", disks);<br>   /* print the drive letters available */<br>   printf("Available drives:\\n");<br>   for (disk = 0;disk < 26;++disk)<br>   {<br>      setdisk(disk);<br>      if (disk == getdisk())<br>         printf("%c: drive is available\\n", disk + 'a');<br>   }<br>   setdisk(save);<br>   return 0;<br>}\n
setdta	<font color=blue>功  能</font>: 设置磁盘传输区地址<br><font color=blue>用  法</font>: void setdta(char far *dta);<br><font color=blue>程序例</font>:<br>#include < process.h ><br>#include < string.h ><br>#include < stdio.h ><br>#include < dos.h ><br>int main(void)<br>{<br>   char line[80], far *save_dta;<br>   char buffer[256] = "SETDTA test!";<br>   struct fcb blk;<br>   int result;<br>   /* get new file name from user */<br>   printf("Enter a file name to create:");<br>   gets(line);<br>   /* parse the new file name to the dta */<br>   parsfnm(line, &blk, 1);<br>   printf("%d %s\\n", blk.fcb_drive, blk.fcb_name);<br>   /* request DOS services to create file */<br>   if (bdosptr(0x16, &blk, 0) == -1)<br>   {<br>      perror("Error creating file");<br>      exit(1);<br>   }<br>   /* save old dta and set new dta */<br>   save_dta = getdta();<br>   setdta(buffer);<br>   /* write new records */<br>   blk.fcb_recsize = 256;<br>   blk.fcb_random = 0L;<br>   result = randbwr(&blk, 1);<br>   printf("result = %d\\n", result);<br>   if (!result)<br>      printf("Write OK\\n");<br>   else<br>   {<br>      perror("Disk error");<br>      exit(1);<br>   }<br>   /* request DOS services to close the file */<br>   if (bdosptr(0x10, &blk, 0) == -1)<br>   {<br>      perror("Error closing file");<br>      exit(1);<br>   }<br>   /* reset the old dta */<br>   setdta(save_dta);<br>   return 0;<br>}\n
setfillpattern	<font color=blue>功  能</font>: 选择用户定义的填充模式<br><font color=blue>用  法</font>: void far setfillpattern(char far *upattern, int color);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>int main(void)<br>{<br>   /* request auto detection */<br>   int gdriver = DETECT, gmode, errorcode;<br>   int maxx, maxy;<br>   /* a user defined fill pattern */<br>   char pattern[8] = {0x00, 0x70, 0x20, 0x27, 0x24, 0x24, 0x07, 0x00};<br>   /* initialize graphics and local variables */<br>   initgraph(&gdriver, &gmode, "");<br>   /* read result of initialization */<br>   errorcode = graphresult();<br>   if (errorcode != grOk)  /* an error occurred */<br>   {<br>      printf("Graphics error: %s\\n", grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>      exit(1); /* terminate with an error code */<br>   }<br>   maxx = getmaxx();<br>   maxy = getmaxy();<br>   setcolor(getmaxcolor());<br>   /* select a user defined fill pattern */<br>   setfillpattern(pattern, getmaxcolor());<br>   /* fill the screen with the pattern */<br>   bar(0, 0, maxx, maxy);<br>   /* clean up */<br>   getch();<br>   closegraph();<br>   return 0;<br>}\n
setfillstyle	<font color=blue>功  能</font>: 设置填充模式和颜色<br><font color=blue>用  法</font>: void far setfillstyle(int pattern, int color);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < string.h ><br>#include < stdio.h ><br>#include < conio.h ><br>/* the names of the fill styles supported */<br>char *fname[] = { "EMPTY_FILL",<br>                  "SOLID_FILL",<br>                  "LINE_FILL",<br>                  "LTSLASH_FILL",<br>                  "SLASH_FILL",<br>                  "BKSLASH_FILL",<br>                  "LTBKSLASH_FILL",<br>    "HATCH_FILL",<br>                  "XHATCH_FILL",<br>                  "INTERLEAVE_FILL",<br>                  "WIDE_DOT_FILL",<br>                  "CLOSE_DOT_FILL",<br>    "USER_FILL"<br>                };<br>int main(void)<br>{<br>   /* request auto detection */<br>   int gdriver = DETECT, gmode, errorcode;<br>   int style, midx, midy;<br>   char stylestr[40];<br>   /* initialize graphics and local variables */<br>   initgraph(&gdriver, &gmode, "");<br>   /* read result of initialization */<br>   errorcode = graphresult();<br>   if (errorcode != grOk)  /* an error occurred */<br>   {<br>      printf("Graphics error: %s\\n", grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>      exit(1); /* terminate with an error code */<br>   }<br>   midx = getmaxx() / 2;<br>   midy = getmaxy() / 2;<br>   for (style = EMPTY_FILL; style < USER_FILL; style++)<br>   {<br>      /* select the fill style */<br>      setfillstyle(style, getmaxcolor());<br>      /* convert style into a string */<br>      strcpy(stylestr, fname[style]);<br>      /* fill a bar */<br>      bar3d(0, 0, midx-10, midy, 0, 0);<br>      /* output a message */<br>      outtextxy(midx, midy, stylestr);<br>      /* wait for a key */<br>      getch();<br>      cleardevice();<br>   }<br>   /* clean up */<br>   getch();<br>   closegraph();<br>   return 0;<br>}\n
setftime	<font color=blue>功  能</font>: 设置文件日期和时间<br><font color=blue>用  法</font>: int setftime(int handle, struct ftime *ftimep);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < process.h ><br>#include < fcntl.h ><br>#include < io.h ><br>int main(void)<br>{<br>   struct ftime filet;<br>   FILE *fp;<br>   if ((fp = fopen("TEST.$$$", "w")) == NULL)<br>   {<br>      perror("Error:");<br>      exit(1);<br>   }<br>   fprintf(fp, "testing...\\n");<br>   /* load ftime structure with new time and date */<br>   filet.ft_tsec = 1;<br>   filet.ft_min = 1;<br>   filet.ft_hour = 1;<br>   filet.ft_day = 1;<br>   filet.ft_month = 1;<br>   filet.ft_year = 21;<br>   /* show current directory for time and date */<br>   system("dir TEST.$$$");<br>   /* change the time and date stamp*/<br>   setftime(fileno(fp), &filet);<br>   /* close and remove the temporary file */<br>   fclose(fp);<br>   system("dir TEST.$$$");<br>   unlink("TEST.$$$");<br>   return 0;<br>}\n
setgraphbufsize	<font color=blue>功  能</font>: 改变内部图形缓冲区的大小<br><font color=blue>用  法</font>: unsigned far setgraphbufsize(unsigned bufsize);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>#define BUFSIZE 1000 /* internal graphics buffer size */<br>int main(void)<br>{<br>   /* request auto detection */<br>   int gdriver = DETECT, gmode, errorcode;<br>   int x, y, oldsize;<br>   char msg[80];<br>   /* set the size of the internal graphics buffer */<br>   /* before making a call to initgraph.           */<br>   oldsize = setgraphbufsize(BUFSIZE);<br>   /* initialize graphics and local variables */<br>   initgraph(&gdriver, &gmode, "");<br>   /* read result of initialization */<br>   errorcode = graphresult();<br>   if (errorcode != grOk)  /* an error occurred */<br>   {<br>      printf("Graphics error: %s\\n", grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>      exit(1); /* terminate with an error code */<br>   }<br>   x = getmaxx() / 2;<br>   y = getmaxy() / 2;<br>   /* output some messages */<br>   sprintf(msg, "Graphics buffer size: %d", BUFSIZE);<br>   settextjustify(CENTER_TEXT, CENTER_TEXT);<br>   outtextxy(x, y, msg);<br>   sprintf(msg, "Old graphics buffer size: %d", oldsize);<br>   outtextxy(x, y+textheight("W"), msg);<br>   /* clean up */<br>   getch();<br>   closegraph();<br>   return 0;<br>}</>\n
setgraphmode	<font color=blue>功  能</font>: 将系统设置成图形模式且清屏<br><font color=blue>用  法</font>: void far setgraphmode(int mode);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>int main(void)<br>{<br>   /* request auto detection */<br>   int gdriver = DETECT, gmode, errorcode;<br>   int x, y;<br>   /* initialize graphics and local variables */<br>   initgraph(&gdriver, &gmode, "");<br>   /* read result of initialization */<br>   errorcode = graphresult();<br>   if (errorcode != grOk)  /* an error occurred */<br>   {<br>      printf("Graphics error: %s\\n", grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>      exit(1); /* terminate with an error code */<br>   }<br>   x = getmaxx() / 2;<br>   y = getmaxy() / 2;<br>   /* output a message */<br>   settextjustify(CENTER_TEXT, CENTER_TEXT);<br>   outtextxy(x, y, "Press any key to exit graphics:");<br>   getch();<br>   /* restore system to text mode */<br>   restorecrtmode();<br>   printf("We're now in text mode.\\n");<br>   printf("Press any key to return to graphics mode:");<br>   getch();<br>   /* return to graphics mode */<br>   setgraphmode(getgraphmode());<br>   /* output a message */<br>   settextjustify(CENTER_TEXT, CENTER_TEXT);<br>   outtextxy(x, y, "We're back in graphics mode.");<br>   outtextxy(x, y+textheight("W"), "Press any key to halt:");<br>   /* clean up */<br>   getch();<br>   closegraph();<br>   return 0;<br>}</>\n
setjmp	<font color=blue>功  能</font>: 非局部转移<br><font color=blue>用  法</font>: int setjmp(jmp_buf env);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < process.h ><br>#include < setjmp.h ><br>void subroutine(void);<br>jmp_buf jumper;<br>int main(void)<br>{<br>   int value;<br>   value = setjmp(jumper);<br>   if (value != 0)<br>   {<br>      printf("Longjmp with value %d\\n", value);<br>      exit(value);<br>   }<br>   printf("About to call subroutine ... \\n");<br>   subroutine();<br>   return 0;<br>}<br>void subroutine(void)<br>{<br>   longjmp(jumper,1);<br>}\n
setlinestyle	<font color=blue>功  能</font>: 设置当前画线宽度和类型<br><font color=blue>用  法</font>: void far setlinestyle(int linestype, unsigned upattern);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < string.h ><br>#include < stdio.h ><br>#include < conio.h ><br>/* the names of the line styles supported */<br>char *lname[] = {<br>   "SOLID_LINE",<br>   "DOTTED_LINE",<br>   "CENTER_LINE",<br>   "DASHED_LINE",<br>   "USERBIT_LINE"<br>   };<br>int main(void)<br>{<br>   /* request auto detection */<br>   int gdriver = DETECT, gmode, errorcode;<br>   int style, midx, midy, userpat;<br>   char stylestr[40];<br>   /* initialize graphics and local variables */<br>   initgraph(&gdriver, &gmode, "");<br>   /* read result of initialization */<br>   errorcode = graphresult();<br>   if (errorcode != grOk)  /* an error occurred */<br>   {<br>      printf("Graphics error: %s\\n", grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>      exit(1); /* terminate with an error code */<br>   }<br>   midx = getmaxx() / 2;<br>   midy = getmaxy() / 2;<br>   /* a user defined line pattern */<br>   /* binary: "0000000000000001"  */<br>   userpat = 1;<br>   for (style=SOLID_LINE; style< =USERBIT_LINE; style++)<br>   {<br>      /* select the line style */<br>      setlinestyle(style, userpat, 1);<br>      /* convert style into a string */<br>      strcpy(stylestr, lname[style]);<br>      /* draw a line */<br>      line(0, 0, midx-10, midy);<br>      /* draw a rectangle */<br>      rectangle(0, 0, getmaxx(), getmaxy());<br>      /* output a message */<br>      outtextxy(midx, midy, stylestr);<br>      /* wait for a key */<br>      getch();<br>      cleardevice();<br>   }<br>   /* clean up */<br>   closegraph();<br>   return 0;<br>}</>\n
setmem	<font color=blue>功  能</font>: 存值到存储区<br><font color=blue>用  法</font>: void setmem(void *addr, int len, char value);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < alloc.h ><br>#include < mem.h ><br>int main(void)<br>{<br>   char *dest;<br>   dest = calloc(21, sizeof(char));<br>   setmem(dest, 20, 'c');<br>   printf("%s\\n", dest);<br>   return 0;<br>}</>\n
setmode	<font color=blue>功  能</font>: 设置打开文件方式<br><font color=blue>用  法</font>: int setmode(int handle, unsigned mode);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < fcntl.h ><br>#include < io.h ><br>int main(void)<br>{<br>   int result;<br>   result = setmode(fileno(stdprn), O_TEXT);<br>   if (result == -1)<br>      perror("Mode not available\\n");<br>   else<br>      printf("Mode successfully switched\\n");<br>   return 0;<br>}</>\n
setpalette	<font color=blue>功  能</font>: 改变调色板的颜色<br><font color=blue>用  法</font>: void far setpalette(int index, int actural_color);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>int main(void)<br>{<br>   /* request auto detection */<br>   int gdriver = DETECT, gmode, errorcode;<br>   int color, maxcolor, ht;<br>   int y = 10;<br>   char msg[80];<br>   /* initialize graphics and local variables */<br>   initgraph(&gdriver, &gmode, "");<br>   /* read result of initialization */<br>   errorcode = graphresult();<br>   if (errorcode != grOk)  /* an error occurred */<br>   {<br>      printf("Graphics error: %s\\n", grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>      exit(1); /* terminate with an error code */<br>   }<br>   maxcolor = getmaxcolor();<br>   ht = 2 * textheight("W");<br>   /* display the default colors */<br>   for (color=1; color< =maxcolor; color++)<br>   {<br>      setcolor(color);<br>      sprintf(msg, "Color: %d", color);<br>      outtextxy(1, y, msg);<br>      y += ht;<br>   }<br>   /* wait for a key */<br>   getch();<br>   /* black out the colors one by one */<br>   for (color=1; color< =maxcolor; color++)<br>   {<br>      setpalette(color, BLACK);<br>      getch();<br>   }<br>   /* clean up */<br>   closegraph();<br>   return 0;<br>}\n
setrgbpalette	<font color=blue>功  能</font>: 定义IBM8514图形卡的颜色<br><font color=blue>用  法</font>: void far setrgbpalette(int colornum, int red, int green, int blue);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>int main(void)<br>{<br>   /* select a driver and mode that supports the use */<br>   /* of the setrgbpalette function.                 */<br>   int gdriver = VGA, gmode = VGAHI, errorcode;<br>   struct palettetype pal;<br>   int i, ht, y, xmax;<br>   /* initialize graphics and local variables */<br>   initgraph(&gdriver, &gmode, "");<br>   /* read result of initialization */<br>   errorcode = graphresult();<br>   if (errorcode != grOk)  /* an error occurred */<br>   {<br>      printf("Graphics error: %s\\n", grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>      exit(1); /* terminate with an error code */<br>   }<br>   /* grab a copy of the palette */<br>   getpalette(&pal);<br>   /* create gray scale */<br>   for (i=0; i< pal.size; i++)<br>      setrgbpalette(pal.colors[i], i*4, i*4, i*4);<br>   /* display the gray scale */<br>   ht = getmaxy() / 16;<br>   xmax = getmaxx();<br>   y = 0;<br>   for (i=0; i< pal.size; i++)<br>   {<br>      setfillstyle(SOLID_FILL, i);<br>      bar(0, y, xmax, y+ht);<br>      y += ht;<br>   }<br>   /* clean up */<br>   getch();<br>   closegraph();<br>   return 0;<br>}</>\n
settextjustify	<font color=blue>功  能</font>: 为图形函数设置文本的对齐方式<br><font color=blue>用  法</font>: void far settextjustify(int horiz, int vert);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>/* function prototype */<br>void xat(int x, int y);<br>/* horizontal text justification settings */<br>char *hjust[] = { "LEFT_TEXT",<br>                  "CENTER_TEXT",<br>                  "RIGHT_TEXT"<br>                };<br>/* vertical text justification settings */<br>char *vjust[] = { "LEFT_TEXT",<br>    "CENTER_TEXT",<br>    "RIGHT_TEXT"<br>                };<br>int main(void)<br>{<br>   /* request auto detection */<br>   int gdriver = DETECT, gmode, errorcode;<br>   int midx, midy, hj, vj;<br>   char msg[80];<br>   /* initialize graphics and local variables */<br>   initgraph(&gdriver, &gmode, "");<br>   /* read result of initialization */<br>   errorcode = graphresult();<br>   if (errorcode != grOk)  /* an error occurred */<br>   {<br>      printf("Graphics error: %s\\n", grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>      exit(1); /* terminate with an error code */<br>   }<br>   midx = getmaxx() / 2;<br>   midy = getmaxy() / 2;<br>   /* loop through text justifications */<br>   for (hj=LEFT_TEXT; hj< =RIGHT_TEXT; hj++)<br>      for (vj=LEFT_TEXT; vj< =RIGHT_TEXT; vj++)<br>      {<br>         cleardevice();<br>         /* set the text justification */<br>         settextjustify(hj, vj);<br>         /* create a message string */<br>         sprintf(msg, "%s  %s", hjust[hj], vjust[vj]);<br>  /* create cross hairs on the screen */<br>  xat(midx, midy);<br>         /* output the message */<br>         outtextxy(midx, midy, msg);<br>         getch();<br>      }<br>   /* clean up */<br>   closegraph();<br>   return 0;<br>}<br>/* draw an "x" at (x, y) */<br>void xat(int x, int y)<br>{<br>  line(x-4, y, x+4, y);<br>  line(x, y-4, x, y+4);<br>}\n
settextstyle	<font color=blue>功  能</font>: 为图形输出设置当前的文本属性<br><font color=blue>用  法</font>: void far settextstyle (int font, int direction, char size);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>/* the names of the text styles supported */<br>char *fname[] = { "DEFAULT font",<br>                  "TRIPLEX font",<br>                  "SMALL font",<br>                  "SANS SERIF font",<br>                  "GOTHIC font"<br>                };<br>int main(void)<br>{<br>   /* request auto detection */<br>   int gdriver = DETECT, gmode, errorcode;<br>   int style, midx, midy;<br>   int size = 1;<br>   /* initialize graphics and local variables */<br>   initgraph(&gdriver, &gmode, "");<br>   /* read result of initialization */<br>   errorcode = graphresult();<br>   if (errorcode != grOk)  /* an error occurred */<br>   {<br>      printf("Graphics error: %s\\n", grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>      exit(1); /* terminate with an error code */<br>   }<br>   midx = getmaxx() / 2;<br>   midy = getmaxy() / 2;<br>   settextjustify(CENTER_TEXT, CENTER_TEXT);<br>   /* loop through the available text styles */<br>   for (style=DEFAULT_FONT; style< =GOTHIC_FONT; style++)<br>   {<br>      cleardevice();<br>      if (style == TRIPLEX_FONT)<br>         size = 4;<br>      /* select the text style */<br>      settextstyle(style, HORIZ_DIR, size);<br>      /* output a message */<br>      outtextxy(midx, midy, fname[style]);<br>      getch();<br>   }<br>   /* clean up */<br>   closegraph();<br>   return 0;<br>}\n
settime	<font color=blue>功  能</font>: 设置系统时间<br><font color=blue>用  法</font>: void settime(struct time *timep);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < dos.h ><br>int main(void)<br>{<br>   struct  time t;<br>   gettime(&t);<br>   printf("The current minute is: %d\\n", t.ti_min);<br>   printf("The current hour is: %d\\n", t.ti_hour);<br>   printf("The current hundredth of a second is: %d\\n", t.ti_hund);<br>   printf("The current second is: %d\\n", t.ti_sec);<br>   /* Add one to the minutes struct element and then call settime  */<br>   t.ti_min++;<br>   settime(&t);<br>   return 0;<br>}\n
setusercharsize	<font color=blue>功  能</font>: 为矢量字体改变字符宽度和高度<br><font color=blue>用  法</font>: void far setusercharsize(int multx, int dirx, int multy, int diry);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>int main(void)<br>{<br>   /* request autodetection */<br>   int gdriver = DETECT, gmode, errorcode;<br>   /* initialize graphics and local variables */<br>   initgraph(&gdriver, &gmode, "");<br>   /* read result of initialization */<br>   errorcode = graphresult();<br>   if (errorcode != grOk)      /* an error occurred */<br>   {<br>      printf("Graphics error: %s\\n", grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>      exit(1);                 /* terminate with an error code */<br>   }<br>   /* select a text style */<br>   settextstyle(TRIPLEX_FONT, HORIZ_DIR, 4);<br>   /* move to the text starting position */<br>   moveto(0, getmaxy() / 2);<br>   /* output some normal text */<br>   outtext("Norm ");<br>   /* make the text 1/3 the normal width */<br>   setusercharsize(1, 3, 1, 1);<br>   outtext("Short ");<br>   /* make the text 3 times normal width */<br>   setusercharsize(3, 1, 1, 1);<br>   outtext("Wide");<br>   /* clean up */<br>   getch();<br>   closegraph();<br>   return 0;<br>}<br> <br>\n
setvbuf	<font color=blue>功  能</font>: 把缓冲区与流相关<br><font color=blue>用  法</font>: int setvbuf(FILE *stream, char *buf, int type, unsigned size);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>int main(void)<br>{<br>   FILE *input, *output;<br>   char bufr[512];<br>   input = fopen("file.in", "r+b");<br>   output = fopen("file.out", "w");<br>   /* set up input stream for minimal disk access,<br>      using our own character buffer */<br>   if (setvbuf(input, bufr, _IOFBF, 512) != 0)<br>      printf("failed to set up buffer for input file\\n");<br>   else<br>      printf("buffer set up for input file\\n");<br>   /* set up output stream for line buffering using space that<br>      will be obtained through an indirect call to malloc */<br>   if (setvbuf(output, NULL, _IOLBF, 132) != 0)<br>      printf("failed to set up buffer for output file\\n");<br>   else<br>      printf("buffer set up for output file\\n");<br>   /* perform file I/O here */<br>   /* close files */<br>   fclose(input);<br>   fclose(output);<br>   return 0;<br>}</>\n
setvect	<font color=blue>功  能</font>: 设置中断矢量入口<br><font color=blue>用  法</font>: void setvect(int intr_num, void interrupt(*isr)());<br><font color=blue>程序例</font>:<br>/***NOTE:<br>    This is an interrupt service routine.  You can NOT compile this<br>    program with Test Stack Overflow turned on and get an executable<br>    file which will operate correctly. */<br>#include < stdio.h ><br>#include < dos.h ><br>#include < conio.h ><br>#define INTR 0X1C    /* The clock tick interrupt */<br>void interrupt ( *oldhandler)(void);<br>int count=0;<br>void interrupt handler(void)<br>{<br>/* increase the global counter */<br>   count++;<br>/* call the old routine */<br>   oldhandler();<br>}<br>int main(void)<br>{<br>/* save the old interrupt vector */<br>   oldhandler = getvect(INTR);<br>/* install the new interrupt handler */<br>   setvect(INTR, handler);<br>/* loop until the counter exceeds 20 */<br>   while (count < 20)<br>      printf("count is %d\\n",count);<br>/* reset the old interrupt handler */<br>   setvect(INTR, oldhandler);<br>   return 0;<br>}\n
setverify	<font color=blue>功  能</font>: 设置验证状态<br><font color=blue>用  法</font>: void setverify(int value);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < conio.h ><br>#include < dos.h ><br>int main(void)<br>{<br>   int verify_flag;<br>   printf("Enter 0 to set verify flag off\\n");<br>   printf("Enter 1 to set verify flag on\\n");<br>   verify_flag = getch() - 0;<br>   setverify(verify_flag);<br>   if (getverify())<br>      printf("DOS verify flag is on\\n");<br>   else<br>      printf("DOS verify flag is off\\n");<br>   return 0;<br>}\n
setviewport	<font color=blue>功  能</font>: 为图形输出设置当前视口<br><font color=blue>用  法</font>: void far setviewport(int left, int top, int right,<br>        int bottom, int clipflag);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>#define CLIP_ON 1   /* activates clipping in viewport */<br>int main(void)<br>{<br>   /* request auto detection */<br>   int gdriver = DETECT, gmode, errorcode;<br>   /* initialize graphics and local variables */<br>   initgraph(&gdriver, &gmode, "");<br>   /* read result of initialization */<br>   errorcode = graphresult();<br>   if (errorcode != grOk)  /* an error occurred */<br>   {<br>      printf("Graphics error: %s\\n", grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>      exit(1); /* terminate with an error code */<br>   }<br>   setcolor(getmaxcolor());<br>   /* message in default full-screen viewport */<br>   outtextxy(0, 0, "* < -- (0, 0) in default viewport");<br>   /* create a smaller viewport */<br>   setviewport(50, 50, getmaxx()-50, getmaxy()-50, CLIP_ON);<br>   /* display some text */<br>   outtextxy(0, 0, "* < -- (0, 0) in smaller viewport");<br>   /* clean up */<br>   getch();<br>   closegraph();<br>   return 0;<br>}\n
setvisualpage	<font color=blue>功  能</font>: 设置可见图形页号<br><font color=blue>用  法</font>: void far setvisualpage(int pagenum);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>int main(void)<br>{<br>   /* select a driver and mode that supports */<br>   /* multiple pages.                        */<br>   int gdriver = EGA, gmode = EGAHI, errorcode;<br>   int x, y, ht;<br>   /* initialize graphics and local variables */<br>   initgraph(&gdriver, &gmode, "");<br>   /* read result of initialization */<br>   errorcode = graphresult();<br>   if (errorcode != grOk)  /* an error occurred */<br>   {<br>      printf("Graphics error: %s\\n", grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>      exit(1); /* terminate with an error code */<br>   }<br>   x = getmaxx() / 2;<br>   y = getmaxy() / 2;<br>   ht = textheight("W");<br>   /*  select the off screen page for drawing */<br>   setactivepage(1);<br>   /* draw a line on page #1 */<br>   line(0, 0, getmaxx(), getmaxy());<br>   /* output a message on page #1 */<br>   settextjustify(CENTER_TEXT, CENTER_TEXT);<br>   outtextxy(x, y, "This is page #1:");<br>   outtextxy(x, y+ht, "Press any key to halt:");<br>   /* select drawing to page #0 */<br>   setactivepage(0);<br>   /* output a message  on page #0 */<br>   outtextxy(x, y, "This is page #0.");<br>   outtextxy(x, y+ht, "Press any key to view page #1:");<br>   getch();<br>   /* select page #1 as the visible page */<br>   setvisualpage(1);<br>   /* clean up */<br>   getch();<br>   closegraph();<br>   return 0;<br>}\n
setwritemode	<font color=blue>功  能</font>: 设置图形方式下画线的输出模式<br><font color=blue>用  法</font>: void far setwritemode(int mode);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>int main()<br>{<br>   /* request auto detection */<br>   int gdriver = DETECT, gmode, errorcode;<br>   int xmax, ymax;<br>   /* initialize graphics and local variables */<br>   initgraph(&gdriver, &gmode, "");<br>   /* read result of initialization */<br>   errorcode = graphresult();<br>   if (errorcode != grOk)  /* an error occurred */<br>   {<br>      printf("Graphics error: %s\\n", grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>      exit(1); /* terminate with an error code */<br>   }<br>   xmax = getmaxx();<br>   ymax = getmaxy();<br>   /* select XOR drawing mode */<br>   setwritemode(XOR_PUT);<br>   /* draw a line */<br>   line(0, 0, xmax, ymax);<br>   getch();<br>   /* erase the line by drawing over it */<br>   line(0, 0, xmax, ymax);<br>   getch();<br>   /* select overwrite drawing mode */<br>   setwritemode(COPY_PUT);<br>   /* draw a line */<br>   line(0, 0, xmax, ymax);<br>   /* clean up */<br>   getch();<br>   closegraph();<br>   return 0;<br>}\n
signal	<font color=blue>功  能</font>: 设置某一信号的对应动作<br><font color=blue>用  法</font>: int signal(int sig, sigfun fname);<br><font color=blue>程序例</font>:<br>/* This example installs a signal handler routine for SIGFPE,<br>   catches an integer overflow condition, makes an adjustment<br>   to AX register, and returns. This example program MAY cause<br>   your computer to crash, and will produce runtime errors<br>   depending on which memory model is used.<br>*/<br>#pragma inline<br>#include < stdio.h ><br>#include < signal.h ><br>void Catcher(int sig, int type, int *reglist)<br>{<br>   printf("Caught it!\\n");<br>   *(reglist + 8) = 3;             /* make return AX = 3 */<br>}<br>int main(void)<br>{<br>   signal(SIGFPE, Catcher);<br>   asm     mov     ax,07FFFH       /* AX = 32767 */<br>   asm     inc     ax              /* cause overflow */<br>   asm     into                    /* activate handler */<br>   /* The handler set AX to 3 on return. If that hadn't happened,<br>      there would have been another exception when the next 'into'<br>      was executed after the 'dec' instruction. */<br>   asm     dec     ax              /* no overflow now */<br>   asm     into                    /* doesn't activate */<br>   return 0;<br>}</>\n
sin	<font color=blue>功  能</font>: 正弦函数<br><font color=blue>用  法</font>: double sin(double x);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < math.h ><br>int main(void)<br>{<br>   double result, x = 0.5;<br>   result = sin(x);<br>   printf("The sin() of %lf is %lf\\n", x, result);<br>   return 0;<br>}\n
sinh	<font color=blue>功  能</font>: 双曲正弦函数<br><font color=blue>用  法</font>: double sinh(double x);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < math.h ><br>int main(void)<br>{<br>   double result, x = 0.5;<br>   result = sinh(x);<br>   printf("The hyperbolic sin() of %lf is %lf\\n", x, result);<br>   return 0;<br>}</>\n
sleep	<font color=blue>功  能</font>: 执行挂起一段时间<br><font color=blue>用  法</font>: unsigned sleep(unsigned seconds);<br><font color=blue>程序例</font>:<br>#include < dos.h ><br>#include < stdio.h ><br>int main(void)<br>{<br>   int i;<br>   for (i=1; i< 5; i++)<br>   {<br>      printf("Sleeping for %d seconds\\n", i);<br>      sleep(i);<br>   }<br>   return 0;<br>}</>\n
sopen	<font color=blue>功  能</font>: 打开一共享文件<br><font color=blue>用  法</font>: int sopen(char *pathname, int access, int shflag, int permiss);<br><font color=blue>程序例</font>:<br>#include < io.h ><br>#include < fcntl.h ><br>#include < sys\\stat.h ><br>#include < process.h ><br>#include < share.h ><br>#include < stdio.h ><br>int main(void)<br>{<br>   int handle;<br>   int status;<br>   handle = sopen("c:\\\\autoexec.bat", O_RDONLY, SH_DENYNO, S_IREAD);<br>   if (!handle)<br>   {<br>      printf("sopen failed\\n");<br>      exit(1);<br>   }<br>   status = access("c:\\\\autoexec.bat", 6);<br>   if (status == 0)<br>      printf("read/write access allowed\\n");<br>   else<br>      printf("read/write access not allowed\\n");<br>   close(handle);<br>   return 0;<br>}</>\n
sound	<font color=blue>功  能</font>: 以指定频率打开PC扬声器<br><font color=blue>用  法</font>: void sound(unsigned frequency);<br><font color=blue>程序例</font>:<br>/* Emits a 7-Hz tone for 10 seconds.<br>   Your PC may not be able to emit a 7-Hz tone. */<br>#include < dos.h ><br>int main(void)<br>{<br>   sound(7);<br>   delay(10000);<br>   nosound();<br>   return 0;<br>}</>\n
spawnl	<font color=blue>功  能</font>: 创建并运行子程序<br><font color=blue>用  法</font>: int spawnl(int mode, char *pathname, char *arg0,arg1, ... argn, NULL);<br><font color=blue>程序例</font>:<br>#include < process.h ><br>#include < stdio.h ><br>#include < conio.h ><br>int main(void)<br>{<br>   int result;<br>   clrscr();<br>   result = spawnl(P_WAIT, "tcc.exe", NULL);<br>   if (result == -1)<br>   {<br>      perror("Error from spawnl");<br>      exit(1);<br>   }<br>   return 0;<br>}\n
spawnle	<font color=blue>功  能</font>: 创建并运行子程序<br><font color=blue>用  法</font>: int spawnle(int mode, char *pathname, char *arg0,arg1,..., argn, NULL);<br><font color=blue>程序例</font>:<br>/* spawnle() example */<br>#include < process.h ><br>#include < stdio.h ><br>#include < conio.h ><br>int main(void)<br>{<br>   int result;<br>   clrscr();<br>   result = spawnle(P_WAIT, "tcc.exe", NULL, NULL);<br>   if (result == -1)<br>   {<br>      perror("Error from spawnle");<br>      exit(1);<br>   }<br>   return 0;<br>}</>\n
sprintf	<font color=blue>功  能</font>: 送格式化输出到字符串中<br><font color=blue>用  法</font>: int sprintf(char *string, char *farmat [,argument,...]);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < math.h ><br>int main(void)<br>{<br>   char buffer[80];<br>   sprintf(buffer, "An approximation of Pi is %f\\n", M_PI);<br>   puts(buffer);<br>   return 0;<br>}\n
sqrt	<font color=blue>功  能</font>: 计算平方根<br><font color=blue>用  法</font>: double sqrt(double x);<br><font color=blue>程序例</font>:<br>#include < math.h ><br> #include < stdio.h ><br> int main(void)<br> {<br>    double x = 4.0, result;<br>    result = sqrt(x);<br>    printf("The square root of %lf is %lf\\n", x, result);<br>    return 0;<br>}<br> <br>\n
srand	<font color=blue>功  能</font>: 初始化随机数发生器<br><font color=blue>用  法</font>: void srand(unsigned seed);<br><font color=blue>程序例</font>:<br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < time.h ><br>int main(void)<br>{<br>   int i;<br>   time_t t;<br>   srand((unsigned) time(&t));<br>   printf("Ten random numbers from 0 to 99\\n\\n");<br>   for(i=0; i< 10; i++)<br>       printf("%d\\n", rand() % 100);<br>   return 0;<br>}\n
sscanf	<font color=blue>功  能</font>: 执行从字符串中的格式化输入<br><font color=blue>用  法</font>: int sscanf(char *string, char *format[,argument,...]);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < conio.h ><br>int main(void)<br>{<br>   char label[20];<br>   char name[20];<br>   int entries = 0;<br>   int loop, age;<br>   double salary;<br>   struct Entry_struct<br>   {<br>      char  name[20];<br>      int   age;<br>      float salary;<br>   } entry[20];<br>/* Input a label as a string of characters restricting to 20 characters */<br>   printf("\\n\\nPlease enter a label for the chart: ");<br>   scanf("%20s", label);<br>   fflush(stdin);  /* flush the input stream in case of bad input */<br>/* Input number of entries as an integer */<br>   printf("How many entries will there be? (less than 20) ");<br>   scanf("%d", &entries);<br>   fflush(stdin);   /* flush the input stream in case of bad input */<br>/* input a name restricting input to only letters upper or lower case */<br>   for (loop=0;loop< entries;++loop)<br>   {<br>      printf("Entry %d\\n", loop);<br>      printf("  Name   : ");<br>      scanf("%[A-Za-z]", entry[loop].name);<br>      fflush(stdin);  /* flush the input stream in case of bad input */<br>/* input an age as an integer */<br>      printf("  Age    : ");<br>      scanf("%d", &entry[loop].age);<br>      fflush(stdin);  /* flush the input stream in case of bad input */<br>/* input a salary as a float */<br>      printf("  Salary : ");<br>      scanf("%f", &entry[loop].salary);<br>      fflush(stdin); /* flush the input stream in case of bad input */<br>   }<br>/* Input a name, age and salary as a string, integer, and double */<br>   printf("\\nPlease enter your name, age and salary\\n");<br>   scanf("%20s %d %lf", name, &age, &salary);<br> <br>/* Print out the data that was input */<br>   printf("\\n\\nTable %s\\n",label);<br>   printf("Compiled by %s  age %d  $%15.2lf\\n", name, age, salary);<br>   printf("-----------------------------------------------------\\n");<br>   for (loop=0;loop< entries;++loop)<br>      printf("%4d | %-20s | %5d | %15.2lf\\n",<br>         loop + 1,<br>  entry[loop].name,<br>  entry[loop].age,<br>  entry[loop].salary);<br>   printf("-----------------------------------------------------\\n");<br>   return 0;<br>}\n
stat	<font color=blue>功  能</font>: 读取打开文件信息<br><font color=blue>用  法</font>: int stat(char *pathname, struct stat *buff);<br><font color=blue>程序例</font>:<br>#include < sys\\stat.h ><br>#include < stdio.h ><br>#include < time.h ><br>#define FILENAME "TEST.$$$"<br>int main(void)<br>{<br>   struct stat statbuf;<br>   FILE *stream;<br>   /* open a file for update */<br>   if ((stream = fopen(FILENAME, "w+")) == NULL)<br>   {<br>      fprintf(stderr, "Cannot open output file.\\n");<br>      return(1);<br>   }<br>   /* get information about the file */<br>   stat(FILENAME, &statbuf);<br>   fclose(stream);<br>   /* display the information returned */<br>   if (statbuf.st_mode & S_IFCHR)<br>      printf("Handle refers to a device.\\n");<br>   if (statbuf.st_mode & S_IFREG)<br>      printf("Handle refers to an ordinary file.\\n");<br>   if (statbuf.st_mode & S_IREAD)<br>      printf("User has read permission on file.\\n");<br>   if (statbuf.st_mode & S_IWRITE)<br>      printf("User has write permission on file.\\n");<br>   printf("Drive letter of file: %c\\n", 'A'+statbuf.st_dev);<br>   printf("Size of file in bytes: %ld\\n", statbuf.st_size);<br>   printf("Time file last opened: %s\\n", ctime(&statbuf.st_ctime));<br>   return 0;<br>}</>\n
status87	<font color=blue>功  能</font>: 取浮点状态<br><font color=blue>用  法</font>: unsigned int _status87(void);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < float.h ><br>int main(void)<br>{<br>   float x;<br>   double y = 1.5e-100;<br>   printf("Status 87 before error: %x\\n", _status87());<br>   x = y;  /* < -- force an error to occur */<br>   y = x;<br>   printf("Status 87 after error : %x\\n", _status87());<br>   return 0;<br>}\n
stime	<font color=blue>功  能</font>: 设置时间<br><font color=blue>用  法</font>: int stime(long *tp);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < time.h ><br>#include < dos.h ><br>int main(void)<br>{<br>   time_t t;<br>   struct tm *area;<br>   t = time(NULL);<br>   area = localtime(&t);<br>   printf("Number of seconds since 1/1/1970 is: %ld\\n", t);<br>   printf("Local time is: %s", asctime(area));<br>   t++;<br>   area = localtime(&t);<br>   printf("Add a second:  %s", asctime(area));<br>   t += 60;<br>   area = localtime(&t);<br>   printf("Add a minute:  %s", asctime(area));<br>   t += 3600;<br>   area = localtime(&t);<br>   printf("Add an hour:   %s", asctime(area));<br>   t += 86400L;<br>   area = localtime(&t);<br>   printf("Add a day:     %s", asctime(area));<br>   t += 2592000L;<br>   area = localtime(&t);<br>   printf("Add a month:   %s", asctime(area));<br>   t += 31536000L;<br>   area = localtime(&t);<br>   printf("Add a year:    %s", asctime(area));<br>   return 0;<br>}</>\n
stpcpy	<font color=blue>功  能</font>: 拷贝一个字符串到另一个<br><font color=blue>用  法</font>: char *stpcpy(char *destin, char *source);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < string.h ><br>int main(void)<br>{<br>   char string[10];<br>   char *str1 = "abcdefghi";<br>   stpcpy(string, str1);<br>   printf("%s\\n", string);<br>   return 0;<br>}</>\n
strcat	<font color=blue>功  能</font>: 字符串拼接函数<br><font color=blue>用  法</font>: char *strcat(char *destin, char *source);<br><font color=blue>程序例</font>:<br>#include < string.h ><br>#include < stdio.h ><br>int main(void)<br>{<br>   char destination[25];<br>   char *blank = " ", *c = "C++", *Borland = "Borland";<br>   strcpy(destination, Borland);<br>   strcat(destination, blank);<br>   strcat(destination, c);<br>   printf("%s\\n", destination);<br>   return 0;<br>}</>\n
strchr	<font color=blue>功  能</font>: 在一个串中查找给定字符的第一个匹配之处\\<br><font color=blue>用  法</font>: char *strchr(char *str, char c);<br><font color=blue>程序例</font>:<br>#include < string.h ><br>#include < stdio.h ><br>int main(void)<br> {<br>    char string[15];<br>    char *ptr, c = 'r';<br>    strcpy(string, "This is a string");<br>    ptr = strchr(string, c);<br>    if (ptr)<br>       printf("The character %c is at position: %d\\n", c, ptr-string);<br>    else<br>       printf("The character was not found\\n");<br>    return 0;<br> }</>\n
strcmp	<font color=blue>功  能</font>: 串比较<br><font color=blue>用  法</font>: int strcmp(char *str1, char *str2);<br><font color=blue>程序例</font>:<br>#include < string.h ><br>#include < stdio.h ><br>int main(void)<br> {<br>    char *buf1 = "aaa", *buf2 = "bbb", *buf3 = "ccc";<br>    int ptr;<br>    ptr = strcmp(buf2, buf1);<br>    if (ptr > 0)<br>       printf("buffer 2 is greater than buffer 1\\n");<br>    else<br>       printf("buffer 2 is less than buffer 1\\n");<br>    ptr = strcmp(buf2, buf3);<br>    if (ptr > 0)<br>       printf("buffer 2 is greater than buffer 3\\n");<br>    else<br>       printf("buffer 2 is less than buffer 3\\n");<br>    return 0;<br> }</>\n
strcmpi	<font color=blue>功  能</font>: 将一个串与另一个比较, 不管大小写<br><font color=blue>用  法</font>: int strcmpi(char *str1, char *str2);<br><font color=blue>程序例</font>:<br>#include < string.h ><br>#include < stdio.h ><br>int main(void)<br>{<br>   char *buf1 = "BBB", *buf2 = "bbb";<br>   int ptr;<br>   ptr = strcmpi(buf2, buf1);<br>   if (ptr > 0)<br>      printf("buffer 2 is greater than buffer 1\\n");<br>   if (ptr < 0)<br>      printf("buffer 2 is less than buffer 1\\n");<br>   if (ptr == 0)<br>      printf("buffer 2 equals buffer 1\\n");<br>   return 0;<br>}</>\n
strcpy	<font color=blue>功  能</font>: 串拷贝<br><font color=blue>用  法</font>: char *strcpy(char *str1, char *str2);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < string.h ><br>int main(void)<br> {<br>    char string[10];<br>    char *str1 = "abcdefghi";<br>    strcpy(string, str1);<br>    printf("%s\\n", string);<br>    return 0;<br> }</>\n
strcspn	<font color=blue>功  能</font>: 在串中查找第一个给定字符集内容的段<br><font color=blue>用  法</font>: int strcspn(char *str1, char *str2);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < string.h ><br>#include < alloc.h ><br>int main(void)<br> {<br>    char *string1 = "1234567890";<br>    char *string2 = "747DC8";<br>    int length;<br>    length = strcspn(string1, string2);<br>    printf("Character where strings intersect is at position %d\\n", length);<br>    return 0;<br> }</>\n
strdup	<font color=blue>功  能</font>: 将串拷贝到新建的位置处<br><font color=blue>用  法</font>: char *strdup(char *str);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < string.h ><br>#include < alloc.h ><br>int main(void)<br> {<br>    char *dup_str, *string = "abcde";<br>    dup_str = strdup(string);<br>    printf("%s\\n", dup_str);<br>    free(dup_str);<br>    return 0;<br> }</>\n
strerror	<font color=blue>功  能</font>: 返回指向错误信息字符串的指针<br><font color=blue>用  法</font>: char *strerror(int errnum);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < errno.h ><br>int main(void)<br>{<br>   char *buffer;<br>   buffer = strerror(errno);<br>   printf("Error: %s\\n", buffer);<br>   return 0;<br>}</>\n
stricmp	<font color=blue>功  能</font>: 以大小写不敏感方式比较两个串<br><font color=blue>用  法</font>: int stricmp(char *str1, char *str2);<br><font color=blue>程序例</font>:<br>#include < string.h ><br>#include < stdio.h ><br>int main(void)<br>{<br>   char *buf1 = "BBB", *buf2 = "bbb";<br>   int ptr;<br>   ptr = stricmp(buf2, buf1);<br>   if (ptr > 0)<br>      printf("buffer 2 is greater than buffer 1\\n");<br>   if (ptr < 0)<br>      printf("buffer 2 is less than buffer 1\\n");<br>   if (ptr == 0)<br>      printf("buffer 2 equals buffer 1\\n");<br>   return 0;<br>}\n
strncmp	<font color=blue>功  能</font>: 串比较<br><font color=blue>用  法</font>: int strncmp(char *str1, char *str2, int maxlen);<br><font color=blue>程序例</font>:<br>#include < string.h ><br>#include < stdio.h ><br>int  main(void)<br>{<br>   char *buf1 = "aaabbb", *buf2 = "bbbccc", *buf3 = "ccc";<br>   int ptr;<br>   ptr = strncmp(buf2,buf1,3);<br>   if (ptr > 0)<br>      printf("buffer 2 is greater than buffer 1\\n");<br>   else<br>      printf("buffer 2 is less than buffer 1\\n");<br>   ptr = strncmp(buf2,buf3,3);<br>   if (ptr > 0)<br>      printf("buffer 2 is greater than buffer 3\\n");<br>   else<br>      printf("buffer 2 is less than buffer 3\\n");<br>   return(0);<br>}\n
strncmpi	<font color=blue>功  能</font>: 将一个串中的一部分与另一个串比较, 不管大小写<br><font color=blue>用  法</font>: int strncmpi(char *str1, char *str2, unsigned maxlen);<br><font color=blue>程序例</font>:<br>#include < string.h ><br>#include < stdio.h ><br>int main(void)<br>{<br>   char *buf1 = "BBB", *buf2 = "bbb";<br>   int ptr;<br>   ptr = strcmpi(buf2, buf1);<br>   if (ptr > 0)<br>      printf("buffer 2 is greater than buffer 1\\n");<br>   if (ptr < 0)<br>      printf("buffer 2 is less than buffer 1\\n");<br>   if (ptr == 0)<br>      printf("buffer 2 equals buffer 1\\n");<br>   return 0;<br>}</>\n
strncmpi	<font color=blue>功  能</font>: 把串中的一部分与另一串中的一部分比较, 不管大小写<br><font color=blue>用  法</font>: int strncmpi(char *str1, char *str2);<br><font color=blue>程序例</font>:<br>#include < string.h ><br>#include < stdio.h ><br>int main(void)<br>{<br>   char *buf1 = "BBBccc", *buf2 = "bbbccc";<br>   int ptr;<br>   ptr = strncmpi(buf2,buf1,3);<br>   if (ptr > 0)<br>      printf("buffer 2 is greater than buffer 1\\n");<br>   if (ptr < 0)<br>      printf("buffer 2 is less than buffer 1\\n");<br>   if (ptr == 0)<br>      printf("buffer 2 equals buffer 1\\n");<br>   return 0;<br>}\n
strncpy	<font color=blue>功  能</font>: 串拷贝<br><font color=blue>用  法</font>: char *strncpy(char *destin, char *source, int maxlen);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < string.h ><br>int main(void)<br>{<br>   char string[10];<br>   char *str1 = "abcdefghi";<br>   strncpy(string, str1, 3);<br>   string[3] = '\\0';<br>   printf("%s\\n", string);<br>   return 0;<br>}\n
strnicmp	<font color=blue>功  能</font>: 不注重大小写地比较两个串<br><font color=blue>用  法</font>: int strnicmp(char *str1, char *str2, unsigned maxlen);<br><font color=blue>程序例</font>:<br>#include < string.h ><br>#include < stdio.h ><br>int main(void)<br>{<br>   char *buf1 = "BBBccc", *buf2 = "bbbccc";<br>   int ptr;<br>   ptr = strnicmp(buf2, buf1, 3);<br>   if (ptr > 0)<br>      printf("buffer 2 is greater than buffer 1\\n");<br>   if (ptr < 0)<br>      printf("buffer 2 is less than buffer 1\\n");<br>   if (ptr == 0)<br>      printf("buffer 2 equals buffer 1\\n");<br>   return 0;<br>}</>\n
strnset	<font color=blue>功  能</font>: 将一个串中的所有字符都设为指定字符<br><font color=blue>用  法</font>: char *strnset(char *str, char ch, unsigned n);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < string.h ><br>int main(void)<br>{<br>   char *string = "abcdefghijklmnopqrstuvwxyz";<br>   char letter = 'x';<br>   printf("string before strnset: %s\\n", string);<br>   strnset(string, letter, 13);<br>   printf("string after  strnset: %s\\n", string);<br>   return 0;<br>}\n
strpbrk	<font color=blue>功  能</font>: 在串中查找给定字符集中的字符<br><font color=blue>用  法</font>: char *strpbrk(char *str1, char *str2);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < string.h ><br>int main(void)<br>{<br>   char *string1 = "abcdefghijklmnopqrstuvwxyz";<br>   char *string2 = "onm";<br>   char *ptr;<br>   ptr = strpbrk(string1, string2);<br>   if (ptr)<br>      printf("strpbrk found first character: %c\\n", *ptr);<br>   else<br>      printf("strpbrk didn't find character in set\\n");<br>   return 0;<br>}</>\n
strrchr	<font color=blue>功  能</font>: 在串中查找指定字符的最后一个出现<br><font color=blue>用  法</font>: char *strrchr(char *str, char c);<br><font color=blue>程序例</font>:<br>#include < string.h ><br>#include < stdio.h ><br>int main(void)<br>{<br>   char string[15];<br>   char *ptr, c = 'r';<br>   strcpy(string, "This is a string");<br>   ptr = strrchr(string, c);<br>   if (ptr)<br>      printf("The character %c is at position: %d\\n", c, ptr-string);<br>   else<br>      printf("The character was not found\\n");<br>   return 0;<br>}</>\n
strrev	<font color=blue>功  能</font>: 串倒转<br><font color=blue>用  法</font>: char *strrev(char *str);<br><font color=blue>程序例</font>:<br>#include < string.h ><br>#include < stdio.h ><br>int main(void)<br>{<br>   char *forward = "string";<br>   printf("Before strrev(): %s\\n", forward);<br>   strrev(forward);<br>   printf("After strrev():  %s\\n", forward);<br>   return 0;<br>}<br> <br>\n
strset	<font color=blue>功  能</font>: 将一个串中的所有字符都设为指定字符<br><font color=blue>用  法</font>: char *strset(char *str, char c);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < string.h ><br>int main(void)<br>{<br>   char string[10] = "123456789";<br>   char symbol = 'c';<br>   printf("Before strset(): %s\\n", string);<br>   strset(string, symbol);<br>   printf("After strset():  %s\\n", string);<br>   return 0;<br>}</>\n
strspn	<font color=blue>功  能</font>: 在串中查找指定字符集的子集的第一次出现<br><font color=blue>用  法</font>: int strspn(char *str1, char *str2);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < string.h ><br>#include < alloc.h ><br>int main(void)<br>{<br>   char *string1 = "1234567890";<br>   char *string2 = "123DC8";<br>   int length;<br>   length = strspn(string1, string2);<br>   printf("Character where strings differ is at position %d\\n", length);<br>   return 0;<br>}\n
strstr	<font color=blue>功  能</font>: 在串中查找指定字符串的第一次出现<br><font color=blue>用  法</font>: char *strstr(char *str1, char *str2);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < string.h ><br>int main(void)<br>{<br>   char *str1 = "Borland International", *str2 = "nation", *ptr;<br>   ptr = strstr(str1, str2);<br>   printf("The substring is: %s\\n", ptr);<br>   return 0;<br>}\n
strtod	<font color=blue>功  能</font>: 将字符串转换为double型值<br><font color=blue>用  法</font>: double strtod(char *str, char **endptr);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < stdlib.h ><br>int main(void)<br>{<br>   char input[80], *endptr;<br>   double value;<br>   printf("Enter a floating point number:");<br>   gets(input);<br>   value = strtod(input, &endptr);<br>   printf("The string is %s the number is %lf\\n", input, value);<br>   return 0;<br>}</>\n
strtok	<font color=blue>功  能</font>: 查找由在第二个串中指定的分界符分隔开的单词<br><font color=blue>用  法</font>: char *strtok(char *str1, char *str2);<br><font color=blue>程序例</font>:<br>#include < string.h ><br>#include < stdio.h ><br>int main(void)<br>{<br>   char input[16] = "abc,d";<br>   char *p;<br>   /* strtok places a NULL terminator<br>   in front of the token, if found */<br>   p = strtok(input, ",");<br>   if (p)   printf("%s\\n", p);<br>   /* A second call to strtok using a NULL<br>   as the first parameter returns a pointer<br>   to the character following the token  */<br>   p = strtok(NULL, ",");<br>   if (p)   printf("%s\\n", p);<br>   return 0;<br>}</>\n
strtol	<font color=blue>功  能</font>: 将串转换为长整数<br><font color=blue>用  法</font>: long strtol(char *str, char **endptr, int base);<br><font color=blue>程序例</font>:<br>#include < stdlib.h ><br>#include < stdio.h ><br>int main(void)<br>{<br>   char *string = "87654321", *endptr;<br>   long lnumber;<br>   /* strtol converts string to long integer  */<br>   lnumber = strtol(string, &endptr, 10);<br>   printf("string = %s  long = %ld\\n", string, lnumber);<br>   return 0;<br>}<br> <br>\n
strupr	<font color=blue>功  能</font>: 将串中的小写字母转换为大写字母<br><font color=blue>用  法</font>: char *strupr(char *str);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < string.h ><br>int main(void)<br>{<br>   char *string = "abcdefghijklmnopqrstuvwxyz", *ptr;<br>   /* converts string to upper case characters */<br>   ptr = strupr(string);<br>   printf("%s\\n", ptr);<br>   return 0;<br>}</>\n
swab	<font color=blue>功  能</font>: 交换字节<br><font color=blue>用  法</font>: void swab (char *from, char *to, int nbytes);<br><font color=blue>程序例</font>:<br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < string.h ><br>char source[15] = "rFna koBlrna d";<br>char target[15];<br>int main(void)<br>{<br>   swab(source, target, strlen(source));<br>   printf("This is target: %s\\n", target);<br>   return 0;<br>}</>\n
system	<font color=blue>功  能</font>: 发出一个DOS命令<br><font color=blue>用  法</font>: int system(char *command);<br><font color=blue>程序例</font>:<br>#include < stdlib.h ><br>#include < stdio.h ><br>int main(void)<br>{<br>   printf("About to spawn command.com and run a DOS command\\n");<br>   system("dir");<br>   return 0;<br>}<br> <br> <br>\n
tan	<font color=blue>功  能</font>: 正切函数<br><font color=blue>用  法</font>: double tan(double x);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < math.h ><br>int main(void)<br>{<br>   double result, x;<br>   x = 0.5;<br>   result = tan(x);<br>   printf("The tan of %lf is %lf\\n", x, result);<br>   return 0;<br>}</>\n
tanh	<font color=blue>功  能</font>: 双曲正切函数<br><font color=blue>用  法</font>: double tanh(double x);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < math.h ><br>int main(void)<br>{<br>   double result, x;<br>   x = 0.5;<br>   result = tanh(x);<br>   printf("The hyperbolic tangent of %lf is %lf\\n", x, result);<br>   return 0;<br>}<br> </>\n
tell	<font color=blue>功  能</font>: 取文件指针的当前位置<br><font color=blue>用  法</font>: long tell(int handle);<br><font color=blue>程序例</font>:<br>#include < string.h ><br>#include < stdio.h ><br>#include < fcntl.h ><br>#include < io.h ><br>int main(void)<br>{<br>   int handle;<br>   char msg[] = "Hello world";<br>   if ((handle = open("TEST.$$$", O_CREAT | O_TEXT | O_APPEND)) == -1)<br>   {<br>      perror("Error:");<br>      return 1;<br>   }<br>   write(handle, msg, strlen(msg));<br>   printf("The file pointer is at byte %ld\\n", tell(handle));<br>   close(handle);<br>   return 0;<br>}<br> </>\n
textattr	<font color=blue>功  能</font>: 设置文本属性<br><font color=blue>用  法</font>: void textattr(int attribute);<br><font color=blue>程序例</font>:<br>#include < conio.h ><br>int main(void)<br>{<br>   int i;<br>   clrscr();<br>   for (i=0; i< 9; i++)<br>   {<br>       textattr(i + ((i+1) < < 4));<br>       cprintf("This is a test\\r\\n");<br>   }<br>   return 0;<br>}</>\n
textbackground	<font color=blue>功  能</font>: 选择新的文本背景颜色<br><font color=blue>用  法</font>: void textbackground(int color);<br><font color=blue>程序例</font>:<br>#include < conio.h ><br>int main(void)<br>{<br>   int i, j;<br>   clrscr();<br>   for (i=0; i< 9; i++)<br>   {<br>       for (j=0; j< 80; j++)<br>         cprintf("C");<br>       cprintf("\\r\\n");<br>       textcolor(i+1);<br>       textbackground(i);<br>   }<br>   return 0;<br>}</>\n
textcolor	<font color=blue>功  能</font>: 在文本模式中选择新的字符颜色<br><font color=blue>用  法</font>: void textcolor(int color);<br><font color=blue>程序例</font>:<br>#include < conio.h ><br>int main(void)<br>{<br>   int i;<br>   for (i=0; i< 15; i++)<br>   {<br>       textcolor(i);<br>       cprintf("Foreground Color\\r\\n");<br>   }<br>   return 0;<br>}</>\n
textheight	<font color=blue>功  能</font>: 返回以像素为单位的字符串高度<br><font color=blue>用  法</font>: int far textheight(char far *textstring);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>int main(void)<br>{<br>   /* request auto detection */<br>   int gdriver = DETECT, gmode, errorcode;<br>   int y = 0;<br>   int i;<br>   char msg[80];<br>   /* initialize graphics and local variables */<br>   initgraph(&gdriver, &gmode, "");<br>   /* read result of initialization */<br>   errorcode = graphresult();<br>   if (errorcode != grOk)  /* an error occurred */<br>   {<br>      printf("Graphics error: %s\\n", grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>      exit(1); /* terminate with an error code */<br>   }<br>   /* draw some text on the screen */<br>   for (i=1; i< 11; i++)<br>   {<br>      /* select the text style, direction, and size */<br>      settextstyle(TRIPLEX_FONT, HORIZ_DIR, i);<br>      /* create a message string */<br>      sprintf(msg, "Size: %d", i);<br>      /* output the message */<br>      outtextxy(1, y, msg);<br>      /* advance to the next text line */<br>      y += textheight(msg);<br>   }<br>   /* clean up */<br>   getch();<br>   closegraph();<br>   return 0;<br>}</>\n
textmode	<font color=blue>功  能</font>: 将屏幕设置成文本模式<br><font color=blue>用  法</font>: void textmode(int mode);<br><font color=blue>程序例</font>:<br>#include < conio.h ><br>int main(void)<br>{<br>   textmode(BW40);<br>   cprintf("ABC");<br>   getch();<br>   textmode(C40);<br>   cprintf("ABC");<br>   getch();<br>   textmode(BW80);<br>   cprintf("ABC");<br>   getch();<br>   textmode(C80);<br>   cprintf("ABC");<br>   getch();<br>   textmode(MONO);<br>   cprintf("ABC");<br>   getch();<br>   return 0;<br>}\n
textwidth	<font color=blue>功  能</font>: 返回以像素为单位的字符串宽度<br><font color=blue>用  法</font>: int far textwidth(char far *textstring);<br><font color=blue>程序例</font>:<br>#include < graphics.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>#include < conio.h ><br>int main(void)<br>{<br>   /* request auto detection */<br>   int gdriver = DETECT, gmode, errorcode;<br>   int x = 0, y = 0;<br>   int i;<br>   char msg[80];<br>   /* initialize graphics and local variables */<br>   initgraph(&gdriver, &gmode, "");<br>   /* read result of initialization */<br>   errorcode = graphresult();<br>   if (errorcode != grOk)  /* an error occurred */<br>   {<br>      printf("Graphics error: %s\\n", grapherrormsg(errorcode));<br>      printf("Press any key to halt:");<br>      getch();<br>      exit(1); /* terminate with an error code */<br>   }<br>   y = getmaxy() / 2;<br>   settextjustify(LEFT_TEXT, CENTER_TEXT);<br>   for (i=1; i< 11; i++)<br>   {<br>      /* select the text style, direction, and size */<br>      settextstyle(TRIPLEX_FONT, HORIZ_DIR, i);<br>      /* create a message string */<br>      sprintf(msg, "Size: %d", i);<br>      /* output the message */<br>      outtextxy(x, y, msg);<br>      /* advance to the end of the text */<br>      x += textwidth(msg);<br>   }<br>   /* clean up */<br>   getch();<br>   closegraph();<br>   return 0;<br>}\n
time	<font color=blue>功  能</font>: 取一天的时间<br><font color=blue>用  法</font>: logn time(long *tloc);<br><font color=blue>程序例</font>:<br>#include < time.h ><br>#include < stdio.h ><br>#include < dos.h ><br>int main(void)<br>{<br>   time_t t;<br>   t = time(NULL);<br>   printf("The number of seconds since January 1, 1970 is %ld",t);<br>   return 0;<br>}</>\n
tmpfile	<font color=blue>功  能</font>: 以二进制方式打开暂存文件<br><font color=blue>用  法</font>: FILE *tmpfile(void);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < process.h ><br>int main(void)<br>{<br>   FILE *tempfp;<br>   tempfp = tmpfile();<br>   if (tempfp)<br>      printf("Temporary file created\\n");<br>   else<br>   {<br>      printf("Unable to create temporary file\\n");<br>      exit(1);<br>   }<br>   return 0;<br>}</>\n
tmpnam	<font color=blue>功  能</font>: 创建一个唯一的文件名<br><font color=blue>用  法</font>: char *tmpnam(char *sptr);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>int main(void)<br>{<br>   char name[13];<br>   tmpnam(name);<br>   printf("Temporary name: %s\\n", name);<br>   return 0;<br>}</>\n
tolower	<font color=blue>功  能</font>: 把字符转换成小写字母<br><font color=blue>用  法</font>: int tolower(int c);<br><font color=blue>程序例</font>:<br>#include < string.h ><br>#include < stdio.h ><br>#include < ctype.h ><br>int main(void)<br>{<br>   int length, i;<br>   char *string = "THIS IS A STRING";<br>   length = strlen(string);<br>   for (i=0; i< length; i++)<br>   {<br>       string[i] = tolower(string[i]);<br>   }<br>   printf("%s\\n",string);<br>   return 0;<br>}\n
toupper	<font color=blue>功  能</font>: 把字符转换成大写字母<br><font color=blue>用  法</font>: int toupper(int c);<br><font color=blue>程序例</font>:<br>#include < string.h ><br>#include < stdio.h ><br>#include < ctype.h ><br>int main(void)<br>{<br>   int length, i;<br>   char *string = "this is a string";<br>   length = strlen(string);<br>   for (i=0; i< length; i++)<br>   {<br>      string[i] = toupper(string[i]);<br>   }<br>   printf("%s\\n",string);<br>   return 0;<br>}\n
tzset	<font color=blue>功  能</font>: UNIX时间兼容函数<br><font color=blue>用  法</font>: void tzset(void);<br><font color=blue>程序例</font>:<br>#include < time.h ><br>#include < stdlib.h ><br>#include < stdio.h ><br>int main(void)<br>{<br>   time_t td;<br>   putenv("TZ=PST8PDT");<br>   tzset();<br>   time(&td);<br>   printf("Current time = %s\\n", asctime(localtime(&td)));<br>   return 0;<br>}<br> <br>\n
ultoa	<font color=blue>功  能</font>: 转换一个无符号长整型数为字符串<br><font color=blue>用  法</font>: char *ultoa(unsigned long value, char *string, int radix);<br><font color=blue>程序例</font>:<br>#include < stdlib.h ><br>#include < stdio.h ><br>int main( void )<br>{<br>   unsigned long lnumber = 3123456789L;<br>   char string[25];<br>   ultoa(lnumber,string,10);<br>   printf("string = %s  unsigned long = %lu\\n",string,lnumber);<br>   return 0;<br>}</>\n
ungetc	<font color=blue>功  能</font>: 把一个字符退回到输入流中<br><font color=blue>用  法</font>: int ungetc(char c, FILE *stream);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < ctype.h ><br>int main( void )<br>{<br>   int i=0;<br>   char ch;<br>   puts("Input an integer followed by a char:");<br>   /* read chars until non digit or EOF */<br>   while((ch = getchar()) != EOF && isdigit(ch))<br>      i = 10 * i + ch - 48; /* convert ASCII into int value */<br>   /* if non digit char was read, push it back into input buffer */<br>   if (ch != EOF)<br>      ungetc(ch, stdin);<br>   printf("i = %d, next char in buffer = %c\\n", i, getchar());<br>   return 0;<br>}</>\n
ungetch	<font color=blue>功  能</font>: 把一个字符退回到键盘缓冲区中<br><font color=blue>用  法</font>: int ungetch(int c);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < ctype.h ><br>#include < conio.h ><br>int main( void )<br>{<br>   int i=0;<br>   char ch;<br>   puts("Input an integer followed by a char:");<br>   /* read chars until non digit or EOF */<br>   while((ch = getche()) != EOF && isdigit(ch))<br>      i = 10 * i + ch - 48; /* convert ASCII into int value */<br>   /* if non digit char was read, push it back into input buffer */<br>   if (ch != EOF)<br>      ungetch(ch);<br>   printf("\\n\\ni = %d, next char in buffer = %c\\n", i, getch());<br>   return 0;<br>}</>\n
unixtodos	<font color=blue>功  能</font>: 把日期和时间转换成DOS格式<br><font color=blue>用  法</font>: void unixtodos(long utime, struct date *dateptr,<br>   struct time *timeptr);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < dos.h ><br>char *month[] = {"---", "Jan", "Feb", "Mar", "Apr", "May", "Jun",<br>                 "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};<br>#define SECONDS_PER_DAY 86400L  /* the number of seconds in one day */<br>struct date dt;<br>struct time tm;<br>int main(void)<br>{<br>   unsigned long val;<br>/* get today's date and time */<br>   getdate(&dt);<br>   gettime(&tm);<br>   printf("today is %d %s %d\\n", dt.da_day, month[dt.da_mon], dt.da_year);<br>/* convert date and time to unix format (number of seconds since Jan 1, 1970 */<br>   val = dostounix(&dt, &tm);<br>/* subtract 42 days worth of seconds */<br>   val -= (SECONDS_PER_DAY * 42);<br>/* convert back to dos time and date */<br>   unixtodos(val, &dt, &tm);<br>   printf("42 days ago it was %d %s %d\\n",<br>        dt.da_day, month[dt.da_mon], dt.da_year);<br>   return 0;<br>}</>\n
unlink	<font color=blue>功  能</font>: 删掉一个文件<br><font color=blue>用  法</font>: int unlink(char *filename);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < io.h ><br>int main(void)<br>{<br>   FILE *fp = fopen("junk.jnk","w");<br>   int status;<br>   fprintf(fp,"junk");<br>   status = access("junk.jnk",0);<br>   if (status == 0)<br>      printf("File exists\\n");<br>   else<br>      printf("File doesn't exist\\n");<br>   fclose(fp);<br>   unlink("junk.jnk");<br>   status = access("junk.jnk",0);<br>   if (status == 0)<br>      printf("File exists\\n");<br>   else<br>      printf("File doesn't exist\\n");<br> <br>   return 0;<br>}</>\n
unlock	<font color=blue>功  能</font>: 解除文件共享锁<br><font color=blue>用  法</font>: int unlock(int handle, long offset, long length);<br><font color=blue>程序例</font>:<br>#include < io.h ><br>#include < fcntl.h ><br>#include < sys\\stat.h ><br>#include < process.h ><br>#include < share.h ><br>#include < stdio.h ><br>int main(void)<br>{<br>   int handle, status;<br>   long length;<br>   handle = sopen("c:\\\\autoexec.bat",O_RDONLY,SH_DENYNO,S_IREAD);<br>   if (handle < 0)<br>   {<br>       printf("sopen failed\\n");<br>       exit(1);<br>   }<br>   length = filelength(handle);<br>   status = lock(handle,0L,length/2);<br>   if (status == 0)<br>      printf("lock succeeded\\n");<br>   else<br>      printf("lock failed\\n");<br>   status = unlock(handle,0L,length/2);<br>   if (status == 0)<br>      printf("unlock succeeded\\n");<br>   else<br>      printf("unlock failed\\n");<br>   close(handle);<br>   return 0;<br>}<br>  <br> <br>\n
vfprintf	<font color=blue>功  能</font>: 送格式化输出到一流中<br><font color=blue>用  法</font>: int vfprintf(FILE *stream, char *format, va_list param);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < stdlib.h ><br>#include < stdarg.h ><br>FILE *fp;<br>int vfpf(char *fmt, ...)<br>{<br>   va_list argptr;<br>   int cnt;<br>   va_start(argptr, fmt);<br>   cnt = vfprintf(fp, fmt, argptr);<br>   va_end(argptr);<br>   return(cnt);<br>}<br>int main(void)<br>{<br>   int inumber = 30;<br>   float fnumber = 90.0;<br>   char string[4] = "abc";<br>   fp = tmpfile();<br>   if (fp == NULL)<br>   {<br>      perror("tmpfile() call");<br>      exit(1);<br>   }<br>   vfpf("%d %f %s", inumber, fnumber, string);<br>   rewind(fp);<br>   fscanf(fp,"%d %f %s", &inumber, &fnumber, string);<br>   printf("%d %f %s\\n", inumber, fnumber, string);<br>   fclose(fp);<br>   return 0;<br>}</>\n
vfscanf	<font color=blue>功  能</font>: 从流中执行格式化输入<br><font color=blue>用  法</font>: int vfscanf(FILE *stream, char *format, va_list param);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < stdlib.h ><br>#include < stdarg.h ><br>FILE *fp;<br>int vfsf(char *fmt, ...)<br>{<br>   va_list  argptr;<br>   int cnt;<br>   va_start(argptr, fmt);<br>   cnt = vfscanf(fp, fmt, argptr);<br>   va_end(argptr);<br>   return(cnt);<br>}<br>int main(void)<br>{<br>   int inumber = 30;<br>   float fnumber = 90.0;<br>         char string[4] = "abc";<br>   fp = tmpfile();<br>   if (fp == NULL)<br>   {<br>      perror("tmpfile() call");<br>      exit(1);<br>   }<br>   fprintf(fp,"%d %f %s\\n",inumber,fnumber,string);<br>   rewind(fp);<br>   vfsf("%d %f %s",&inumber,&fnumber,string);<br>   printf("%d %f %s\\n",inumber,fnumber,string);<br>   fclose(fp);<br>   return 0;<br>}\n
vprintf	<font color=blue>功  能</font>: 送格式化输出到stdout中<br><font color=blue>用  法</font>: int vprintf(char *format, va_list param);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < stdarg.h ><br>int vpf(char *fmt, ...)<br>{<br>   va_list argptr;<br>   int cnt;<br>   va_start(argptr, format);<br>   cnt = vprintf(fmt, argptr);<br>   va_end(argptr);<br>   return(cnt);<br>}<br>int main(void)<br>{<br>   int inumber = 30;<br>   float fnumber = 90.0;<br>   char *string = "abc";<br>   vpf("%d %f %s\\n",inumber,fnumber,string);<br>   return 0;<br>}\n
vscanf	<font color=blue>功  能</font>: 从stdin中执行格式化输入<br><font color=blue>用  法</font>: int vscanf(char *format, va_list param);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < conio.h ><br>#include < stdarg.h ><br>int vscnf(char *fmt, ...)<br>{<br>   va_list argptr;<br>   int cnt;<br>   printf("Enter an integer, a float,  and a string (e.g. i,f,s,)\\n");<br>   va_start(argptr, fmt);<br>   cnt = vscanf(fmt, argptr);<br>   va_end(argptr);<br>   return(cnt);<br>}<br>int main(void)<br>{<br>   int inumber;<br>   float fnumber;<br>   char string[80];<br>   vscnf("%d, %f, %s", &inumber, &fnumber, string);<br>   printf("%d %f %s\\n", inumber, fnumber, string);<br>   return 0;<br>}</>\n
vsprintf	<font color=blue>功  能</font>: 送格式化输出到串中<br><font color=blue>用  法</font>: int vsprintf(char *string, char *format, va_list param);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < conio.h ><br>#include < stdarg.h ><br>char buffer[80];<br>int vspf(char *fmt, ...)<br>{<br>   va_list argptr;<br>   int cnt;<br>   va_start(argptr, fmt);<br>   cnt = vsprintf(buffer, fmt, argptr);<br>   va_end(argptr);<br>   return(cnt);<br>}<br>int main(void)<br>{<br>   int inumber = 30;<br>   float fnumber = 90.0;<br>   char string[4] = "abc";<br>   vspf("%d %f %s", inumber, fnumber, string);<br>   printf("%s\\n", buffer);<br>   return 0;<br>}</>\n
vsscanf	<font color=blue>功  能</font>: 从流中执行格式化输入<br><font color=blue>用  法</font>: int vsscanf(char *s, char *format, va_list param);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < conio.h ><br>#include < stdarg.h ><br>char buffer[80] = "30 90.0 abc";<br>int vssf(char *fmt, ...)<br>{<br>   va_list  argptr;<br>   int cnt;<br>   fflush(stdin);<br>   va_start(argptr, fmt);<br>   cnt = vsscanf(buffer, fmt, argptr);<br>   va_end(argptr);<br>   return(cnt);<br>}<br>int main(void)<br>{<br>   int inumber;<br>   float fnumber;<br>   char string[80];<br>   vssf("%d %f %s", &inumber, &fnumber, string);<br>   printf("%d %f %s\\n", inumber, fnumber, string);<br>   return 0;<br>}<br> <br> <br>\n
wherex	<font color=blue>功  能</font>: 返回窗口内水平光标位置<br><font color=blue>用  法</font>: int wherex(void);<br><font color=blue>程序例</font>:<br>#include < conio.h ><br>int main(void)<br>{<br>   clrscr();<br>   gotoxy(10,10);<br>   cprintf("Current location is X: %d  Y: %d\\r\\n", wherex(), wherey());<br>   getch();<br>   return 0;<br>}</>\n
wherey	<font color=blue>功  能</font>: 返回窗口内垂直光标位置<br><font color=blue>用  法</font>: int wherey(void);<br><font color=blue>程序例</font>:<br>#include < conio.h ><br>int main(void)<br>{<br>   clrscr();<br>   gotoxy(10,10);<br>   cprintf("Current location is X: %d  Y: %d\\r\\n", wherex(), wherey());<br>   getch();<br>   return 0;<br>}</>\n
window	<font color=blue>功  能</font>: 定义活动文本模式窗口<br><font color=blue>用  法</font>: void window(int left, int top, int right, int bottom);<br><font color=blue>程序例</font>:<br>#include < conio.h ><br>int main(void)<br>{<br>   window(10,10,40,11);<br>   textcolor(BLACK);<br>   textbackground(WHITE);<br>   cprintf("This is a test\\r\\n");<br>   return 0;<br>}</>\n
write	<font color=blue>功  能</font>: 写到一文件中<br><font color=blue>用  法</font>: int write(int handel, void *buf, int nbyte);<br><font color=blue>程序例</font>:<br>#include < stdio.h ><br>#include < stdlib.h ><br>#include < fcntl.h ><br>#include < sys\\stat.h ><br>#include < io.h ><br>#include < string.h ><br>int main(void)<br>{<br>   int handle;<br>   char string[40];<br>   int length, res;<br>   /<br>*    Create a file named "TEST.$$$" in the current directory and write<br>    a string to it.  If "TEST.$$$" already exists, it will be overwritten.<br>   */<br>   if ((handle = open("TEST.$$$", O_WRONLY | O_CREAT | O_TRUNC,<br>                         S_IREAD | S_IWRITE)) == -1)<br>   {<br>      printf("Error opening file.\\n");<br>      exit(1);<br>   }<br>   strcpy(string, "Hello, world!\\n");<br>   length = strlen(string);<br>   if ((res = write(handle, string, length)) != length)<br>   {<br>      printf("Error writing to the file.\\n");<br>      exit(1);<br>   }<br>   printf("Wrote %d bytes to the file.\\n", res);<br>   close(handle);<br>   return 0;<br>}<br> <br>\n
